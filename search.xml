<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序初步了解</title>
    <url>/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io">个人博客</a> : <a href="https://ityongzhen.github.io">https://ityongzhen.github.io</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小程序开发与网页开发有很大的相似性</p>
<ul>
<li>在小程序开发中<ul>
<li>编写样式时建议多使用 flex 布局</li>
<li>支持 TypeScript</li>
<li>也可以自行搭建less、sass开发环境</li>
</ul>
</li>
</ul>
<h2 id="小程序开发-vs-网页开发"><a href="#小程序开发-vs-网页开发" class="headerlink" title="小程序开发 vs 网页开发"></a>小程序开发 vs 网页开发</h2><ul>
<li><p>网页开发中的渲染线程和脚本线程是互斥的，长时间的脚本运行可能会导致页面失去响应</p>
</li>
<li><p>网页开发者可以使用到各种浏览器暴露出来的DOMAPI，进行DOM选中和操作</p>
</li>
<li><p>在小程序中，页面渲染和业务逻辑是分开的，分别运行在不同的线程中</p>
<ul>
<li>逻辑层运行在JSCore中，并没有一个完整浏览器对象，因而缺少相关的DOMAPI和BOMAPI </li>
<li>因此非常熟悉的一些库，例如jQuery、Zepto等，在小程序中是无法运行的</li>
<li>同时JSCore的环境同NodeJS环境也是不完全相同的，所以一些NPM的包在小程序中也是无法运行的</li>
</ul>
</li>
<li><p>小程序的性能介于纯网页开发与原生（native）开发之间</p>
</li>
</ul>
<h2 id="小程序的运行环境"><a href="#小程序的运行环境" class="headerlink" title="小程序的运行环境"></a>小程序的运行环境</h2><table>
<thead>
<tr>
<th align="center">运行环境</th>
<th align="center">逻辑层</th>
<th align="center">渲染层</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iOS</td>
<td align="center">JavaScriptCore</td>
<td align="center">WKWebView</td>
</tr>
<tr>
<td align="center">Android</td>
<td align="center">V8</td>
<td align="center">chromium定制内核</td>
</tr>
<tr>
<td align="center">开发者工具</td>
<td align="center">NWJS</td>
<td align="center">ChromeWebView</td>
</tr>
</tbody></table>
<h2 id="小程序-vs-APP"><a href="#小程序-vs-APP" class="headerlink" title="小程序 vs APP"></a>小程序 vs APP</h2><ul>
<li><p>安装使用</p>
<ul>
<li>小程序：无需安装、无需卸载、简单易用、占用内存较小</li>
<li>APP：需要主动联网下载安装APP、不想用了需要主动卸载</li>
</ul>
</li>
<li><p>开发</p>
<ul>
<li>小程序：跨平台、开发门槛低、开发周期短、开发成本低（对初创企业来说，是个很好的选择）</li>
<li>APP：开发成本高、每一个平台都要维护一套代码（目前也有ReactiveNative、Flutter等跨平台方案）</li>
</ul>
</li>
<li><p>发布上线</p>
<ul>
<li>小程序：提交到微信公众平台审核</li>
<li>APP：提交到应用商店审核（Apple的AppStore常有审核不通过的情况，审核周期也较长</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>小程序用户体验、功能丰富度、开放性不如APP</li>
</ul>
</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">开发文档</a> : <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p>
</li>
<li><p>[开发指南] (<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener">https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a</a> ) :<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener">https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a</a> </p>
</li>
<li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">开发工具</a>: <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
</li>
</ul>
<p>(官方开发工具不太好用，可以选择VS Code等)</p>
<ul>
<li><a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener">官方Demo</a> : <a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener">https://github.com/wechat-miniprogram/miniprogram-demo</a></li>
</ul>
<h2 id="注册小程序"><a href="#注册小程序" class="headerlink" title="注册小程序"></a>注册小程序</h2><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/introduction/" target="_blank" rel="noopener">注册指南</a>：<a href="https://developers.weixin.qq.com/miniprogram/introduction/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/introduction/</a></li>
<li><a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">利用邮箱注册小程序</a>：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a> </li>
<li>注册完毕后会有一个小程序的AppID（唯一标识）</li>
</ul>
<h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><ul>
<li><a href="https://github.com/opendigg/awesome-github-wechat-weapp" target="_blank" rel="noopener">微信小程序开源项目库汇总</a>: <a href="https://github.com/opendigg/awesome-github-wechat-weapp" target="_blank" rel="noopener">https://github.com/opendigg/awesome-github-wechat-weapp</a></li>
<li><a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">微信小程序开发资源汇总</a>:<a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">https://github.com/justjavac/awesome-wechat-weapp</a></li>
</ul>
<h2 id="UI组件库"><a href="#UI组件库" class="headerlink" title="UI组件库"></a>UI组件库</h2><ul>
<li><a href="https://github.com/TalkingData/iview-weapp" target="_blank" rel="noopener">https://github.com/TalkingData/iview-weapp</a> </li>
<li><a href="https://github.com/youzan/vant-weapp" target="_blank" rel="noopener">https://github.com/youzan/vant-weapp</a> </li>
<li><a href="https://github.com/meili/minui" target="_blank" rel="noopener">https://github.com/meili/minui</a> </li>
<li><a href="https://github.com/wux-weapp/wux-weapp" target="_blank" rel="noopener">https://github.com/wux-weapp/wux-weapp</a> </li>
<li><a href="https://github.com/weilanwl/ColorUI" target="_blank" rel="noopener">https://github.com/weilanwl/ColorUI</a> </li>
<li><a href="https://github.com/Tencent/weui-wxss" target="_blank" rel="noopener">微信官方</a>：<a href="https://github.com/Tencent/weui-wxss" target="_blank" rel="noopener">https://github.com/Tencent/weui-wxss</a> </li>
<li><a href="https://github.com/NervJS/taro-ui" target="_blank" rel="noopener">京东凹凸实验室</a>：<a href="https://github.com/NervJS/taro-ui" target="_blank" rel="noopener">https://github.com/NervJS/taro-ui</a></li>
</ul>
<p>QQ交流群：592831498</p>
<p>参考资料：<a href="https://ke.qq.com/course/435191" target="_blank" rel="noopener">https://ke.qq.com/course/435191</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
  </entry>
  <entry>
    <title>实现iOS中的多语言切换</title>
    <url>/%E5%AE%9E%E7%8E%B0iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/实现iOS中的多语言切换.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>我们日常使用App中，只有中文就够了，然而如果我们的App是面向国际化的，那么多语言就必不可少。本文整理了在iOS中多语言的实现。</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加支持的语言"><a href="#添加支持的语言" class="headerlink" title="添加支持的语言"></a>添加支持的语言</h3><ul>
<li>选择工程，在info下面的<code>Localizations</code>中，点击加号按钮，添加支持的语言</li>
</ul>
<h3 id="建立strings文件"><a href="#建立strings文件" class="headerlink" title="建立strings文件"></a>建立strings文件</h3><ul>
<li>方法1.选择一个<code>storyboard</code>,例如默认的<code>Main.storyboard,</code>在<code>Localization</code>栏中勾选支持的语言。系统就会生成对应的文件。</li>
<li>方法2.我们直接新建<code>strings</code>资源文件。在该文件的<code>File Inspecter</code>的<code>Localizatio</code>n栏中勾选支持的语言。</li>
</ul>
<h3 id="准备对应文案"><a href="#准备对应文案" class="headerlink" title="准备对应文案"></a>准备对应文案</h3><ul>
<li>例如在<code>Localizable.strings(English)</code>中，</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="string">"消息"</span> = <span class="string">"Messages"</span><span class="comment">;</span></span><br><span class="line"><span class="string">"搜索"</span> = <span class="string">" Search"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>思路：<ul>
<li>偏好设置中存储我们设置的语言，默认是简体中文</li>
<li>当我们切换多语言的时候，更改偏好设置中存储的语言</li>
<li>显示的时候，传入key。</li>
<li>如果设置了其他语言，就根据对应的bundle中的key取出对应value来显示</li>
</ul>
</li>
</ul>
<h3 id="切换多语言的实现"><a href="#切换多语言的实现" class="headerlink" title="切换多语言的实现"></a>切换多语言的实现</h3><h4 id="定义宏"><a href="#定义宏" class="headerlink" title="定义宏"></a>定义宏</h4><ul>
<li>定义多语言的宏，如下，定义了三种宏，分别是简体中文，繁体中文，英文，韩文</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Chinese_Simple @<span class="meta-string">"zh-Hans"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Chinese_Traditional @<span class="meta-string">"zh-Hant"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> English_US @<span class="meta-string">"en"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Korean @<span class="meta-string">"ko"</span></span></span><br></pre></td></tr></table></figure>

<p>定义偏好设置的文件名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Language_Key @<span class="meta-string">"eagle_languageKey"</span></span></span><br></pre></td></tr></table></figure>


<h4 id="设置多语言"><a href="#设置多语言" class="headerlink" title="设置多语言"></a>设置多语言</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 设置多语言</span></span><br><span class="line"><span class="comment">/// @param language 语言</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">setNewLanguage:</span>(NSString *)language</span><br><span class="line">&#123;</span><br><span class="line">    NSString * setLanguage = [[NSUserDefaults standardUserDefaults] <span class="string">objectForKey:</span>Language_Key];</span><br><span class="line">    <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>setLanguage]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简体中文</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>Chinese_Simple]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>Chinese_Simple <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 繁体中文</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>Chinese_Traditional]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>Chinese_Traditional <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 英文</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>English_US]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>English_US <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 韩语</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>Korean]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>Korean <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> languageStringWithKey(key) [[LanguageTools sharedInstance] getStringForKey:key]</span></span><br><span class="line"></span><br><span class="line">NSString *<span class="keyword">title</span> = languageStringWithKey(@<span class="string">"确定"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>具体实现如下，先偏好设置存储的当前语言获取对应bundle，然后拿到这个bundle之后，根据key找到对应的值。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据语言名获取bundle</span></span><br><span class="line">- (<span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * setLanguage = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:Language_Key];</span><br><span class="line">    <span class="comment">//默认是简体中文</span></span><br><span class="line">    <span class="keyword">if</span> (setLanguage == <span class="literal">nil</span> || [setLanguage isEqualToString:<span class="string">@"zh-Hans-CN"</span>]) &#123;</span><br><span class="line">        setLanguage = Chinese_Simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> * bundlePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:setLanguage ofType:<span class="string">@"lproj"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key获取value</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)getStringForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSBundle</span> * bundle = [[LanguageTools sharedInstance] bundle];</span><br><span class="line">    <span class="keyword">if</span> (bundle) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> * valueString = <span class="built_in">NSLocalizedStringFromTableInBundle</span>(key, <span class="string">@"Localizable"</span>, bundle, <span class="string">@"HelloWord"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!KCNSSTRING_ISEMPTY(valueString)) &#123;</span><br><span class="line">            <span class="keyword">return</span> valueString;</span><br><span class="line">        &#125;</span><br><span class="line">        DDLogInfo(<span class="string">@"\n********** have not add key **********\n \"%@\" = \"%@\" \n****************************"</span>,key,key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(key, <span class="string">@"HelloWord"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(key, <span class="string">@"HelloWord"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSLocalizedString"><a href="#NSLocalizedString" class="headerlink" title="NSLocalizedString"></a><code>NSLocalizedString</code></h2><ul>
<li><p><code>NSLocalizedString</code>是一个定义在<code>NSBundle.h</code>中的宏，用途是寻找当前系统语言对应的<code>Localizable.strings</code>文件中的某个<code>key</code>的值。</p>
</li>
<li><p>第一个参数是<code>key</code>的名字，第二个参数是对这个“键值对”的注释，在用<code>genstrings</code>工具生成<code>Loclizable.strings</code>文件时会自动加上去。例如上面代码中的<code>HelloWord</code>就是注释。</p>
</li>
</ul>
<ul>
<li><code>NSLocalizedString</code>系列的四个宏，其实最终都是调用了<code>[bundle localizedStringForKey:(key) value:(val) table:(tbl)]</code>。根据我们的自定义程度不同可以选择不同的宏。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">NSLocalizedString(<span class="params">key</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">	    <span class="literal">[NSB<span class="identifier">undle</span>.<span class="identifier">mainBundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:@"" <span class="identifier">table</span>:<span class="identifier">nil</span>]</span></span><br><span class="line">#define <span class="constructor">NSLocalizedStringFromTable(<span class="params">key</span>, <span class="params">tbl</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">	    <span class="literal">[NSB<span class="identifier">undle</span>.<span class="identifier">mainBundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:@"" <span class="identifier">table</span>:(<span class="identifier">tbl</span>)]</span></span><br><span class="line">#define <span class="constructor">NSLocalizedStringFromTableInBundle(<span class="params">key</span>, <span class="params">tbl</span>, <span class="params">bundle</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">	    <span class="literal">[<span class="identifier">bundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:@"" <span class="identifier">table</span>:(<span class="identifier">tbl</span>)]</span></span><br><span class="line">#define <span class="constructor">NSLocalizedStringWithDefaultValue(<span class="params">key</span>, <span class="params">tbl</span>, <span class="params">bundle</span>, <span class="params">val</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">	    <span class="literal">[<span class="identifier">bundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:(<span class="identifier">val</span>) <span class="identifier">table</span>:(<span class="identifier">tbl</span>)]</span></span><br></pre></td></tr></table></figure>


<p>上面基本就是实现一个可控的多语言版本的实现过程。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>Dart中的Future使用</title>
    <url>/Dart%E4%B8%AD%E7%9A%84Future%E4%BD%BF%E7%94%A8.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Dart中的异步使用.html/">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于异步，相信很多开发者都是经常用到的。不过，不同的语言有不同的处理方式</p>
<h3 id="一般耗时操作的处理"><a href="#一般耗时操作的处理" class="headerlink" title="一般耗时操作的处理"></a>一般耗时操作的处理</h3><p>针对如何处理耗时的操作，不同的语言有不同的处理方式。</p>
<ul>
<li><p>处理方式一： 多线程，比如<code>Java</code>、<code>C++</code>，<code>Objective C</code>我们普遍的做法是开启一个新的线程（<code>Thread</code>），在新的线程中完成这些异步的操作，再通过线程间通信的方式，将拿到的数据传递给主线程。</p>
</li>
<li><p>处理方式二： 单线程+事件循环，比如<code>JavaScript</code>、<code>Dart</code>都是基于单线程加事件循环来完成耗时操作的处理。</p>
</li>
</ul>
<h3 id="阻塞式调用和非阻塞式调用"><a href="#阻塞式调用和非阻塞式调用" class="headerlink" title="阻塞式调用和非阻塞式调用"></a>阻塞式调用和非阻塞式调用</h3><ul>
<li><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p>
</li>
<li><p>阻塞式调用： 调用结果返回之前，当前线程会被挂起，调用线程只有在得到调用结果之后才会继续执行。</p>
</li>
<li><p>非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。</p>
</li>
</ul>
<p>例如你平时做饭的时候，把米放在电饭煲里面煮，这时候你可以在旁边坐着等着米饭做好，然后去做菜，这就是阻塞式调用。当然了。你也可以煮饭时候，准备菜，啤酒鸭，麻辣小龙虾。。这就是非阻塞式调用。</p>
<h2 id="Dart事件循环"><a href="#Dart事件循环" class="headerlink" title="Dart事件循环"></a>Dart事件循环</h2><h3 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h3><p>单线程模型中主要就是在维护着一个事件循环（Event Loop）。</p>
<p>事件循环是什么呢？</p>
<ul>
<li><p>事实上事件循环并不复杂，它就是将需要处理的一系列事件（包括点击事件、IO事件、网络事件）放在一个事件队列（Event Queue）中。</p>
</li>
<li><p>不断的从事件队列（Event Queue）中取出事件，并执行其对应需要执行的代码块，直到事件队列清空位置。</p>
</li>
<li><p>当我们有一些事件时，比如点击事件、IO事件、网络事件时，它们就会被加入到eventLoop中，当发现事件队列不为空时发现，就会取出事件，并且执行。</p>
</li>
</ul>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们先看一个例子：如下代码中，用sleep代替网络请求的耗时操作</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  <span class="built_in">String</span> res = getData();</span><br><span class="line">  <span class="built_in">print</span>(res);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> getData()&#123;</span><br><span class="line">  sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<blockquote>
<p>start</p>
</blockquote>
<p>2秒钟之后输出</p>
<blockquote>
<p>hello world</p>
<p>end</p>
</blockquote>
<p>很显然阻塞了后面的代码执行</p>
<h2 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h2><p><code>Future</code> 表示一件“将来”会发生的事情，将来可以从Future中取到一个值。<br>有了Future之后，通过.then的回调去获取请求到的结果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">var</span> res = getData();</span><br><span class="line">  res.then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getData()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Future&lt;<span class="built_in">String</span>&gt;(() &#123;</span><br><span class="line">     sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a><code>catchError</code></h3><p>如果有异常的话，我们可以用catchError来捕获</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">var</span> res = getData();</span><br><span class="line">  res.then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value);</span><br><span class="line">  &#125;).catchError((error)&#123;<span class="comment">// 捕获出现异常时的情况</span></span><br><span class="line">    <span class="built_in">print</span>(error);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getData()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Future&lt;<span class="built_in">String</span>&gt;(() &#123;</span><br><span class="line">     sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//  return "hello world";</span></span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">"请求异常"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<blockquote>
<p>start</p>
</blockquote>
<blockquote>
<p>end</p>
</blockquote>
<blockquote>
<p>Exception: 请求异常</p>
</blockquote>
<h3 id="Future的链式调用"><a href="#Future的链式调用" class="headerlink" title="Future的链式调用"></a>Future的链式调用</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">import <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">ma<span class="meta">in(</span><span class="meta">List</span>&lt;String&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  p<span class="meta">rint(</span><span class="string">"start"</span>);</span><br><span class="line">  var res = getData();</span><br><span class="line">  res.th<span class="meta">en(</span>(value) &#123;</span><br><span class="line">    p<span class="meta">rint(</span>value);</span><br><span class="line">    <span class="meta">return</span> <span class="string">"第一次调用完成"</span>;</span><br><span class="line">  &#125;).th<span class="meta">en(</span>(value2)&#123;</span><br><span class="line"></span><br><span class="line">     p<span class="meta">rint(</span>value2);</span><br><span class="line">    <span class="meta">return</span> <span class="string">"第二次调用完成"</span>;</span><br><span class="line">  &#125;).th<span class="meta">en(</span>(value3)&#123;</span><br><span class="line"></span><br><span class="line">     p<span class="meta">rint(</span>value3);</span><br><span class="line">  &#125;).catchError((<span class="meta">error</span>)&#123;</span><br><span class="line">    p<span class="meta">rint(</span><span class="meta">error</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  p<span class="meta">rint(</span><span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; getData()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">return</span> Future&lt;String&gt;(() &#123;</span><br><span class="line">     sleep(Durati<span class="meta">on(</span>seconds: 2));</span><br><span class="line">     <span class="meta">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    // throw Excepti<span class="meta">on(</span><span class="string">"请求异常"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<blockquote>
<p>start</p>
<p>end</p>
<p>hello world</p>
<p>第一次调用完成</p>
<p>第二次调用完成</p>
</blockquote>
<h3 id="直接获取一个完成的Future，该Future会直接调用then的回调函数"><a href="#直接获取一个完成的Future，该Future会直接调用then的回调函数" class="headerlink" title="直接获取一个完成的Future，该Future会直接调用then的回调函数"></a>直接获取一个完成的Future，该Future会直接调用then的回调函数</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  </span><br><span class="line">  Future.value(<span class="string">"测试"</span>).then((value)&#123;</span><br><span class="line">    <span class="built_in">print</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<blockquote>
<p>start</p>
<p>end</p>
<p>测试</p>
</blockquote>
<p>我们可以看到，<code>测试</code>是最后才打印，这是因为Future中的then会作为新的任务会加入到事件队列中（Event Queue），加入之后你需要排队执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>创建一个Future（可能是我们创建的，也可能是调用内部API或者第三方API获取到的一个Future，总之你需要获取到一个Future实例，Future通常会对一些异步的操作进行封装）；</li>
<li>通过.then(成功回调函数)的方式来监听Future内部执行完成时获取到的结果；</li>
<li>通过.catchError(失败或异常回调函数)的方式来监听Future内部执行失败或者出现异常时的错误信息；</li>
<li>可以链式调用</li>
<li>直接获取一个完成的Future，该Future会直接调用then的回调函数</li>
</ul>
<p>QQ交流群：592831498</p>
<p><a href="https://ityongzhen.github.io/Dart中的异步使用.html/">个人博客</a>：<a href="https://ityongzhen.github.io">https://ityongzhen.github.io</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Dart语法之泛型</title>
    <url>/Dart%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%B3%9B%E5%9E%8B.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Dart语法之泛型.html/">个人博客</a></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>泛型是很多语言都支持的一种语法。例如Swift,Java,C++等。之前的文章<a href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/">C++语法之模板</a> 详细介绍了C++中的泛型。</li>
</ul>
<h2 id="List泛型使用"><a href="#List泛型使用" class="headerlink" title="List泛型使用"></a>List泛型使用</h2><ul>
<li>List 的泛型使用</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建List的方式</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'eagle'</span>,<span class="string">'ityongzhen'</span>,<span class="string">"abc"</span>];</span><br><span class="line"><span class="built_in">print</span>(names); <span class="comment">//[eagle, ityongzhen, abc]</span></span><br><span class="line"><span class="built_in">print</span>(names.runtimeType); <span class="comment">//List&lt;String&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们没有指定具体类型，但是跟根据类型推断可知其类型为 <code>List&lt;String&gt;</code><br>除了类型的自动推断，还可以限制类型。如下</p>
<ul>
<li>限制类型</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 限制类型</span></span><br><span class="line"><span class="keyword">var</span> names2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">'eagle'</span>,<span class="string">'ityongzhen'</span>,<span class="string">"abc"</span>]; <span class="comment">//List&lt;String&gt;</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names3 = [<span class="string">'eagle'</span>,<span class="string">'ityongzhen'</span>,<span class="string">"abc"</span>]; <span class="comment">//List&lt;String&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Map泛型使用"><a href="#Map泛型使用" class="headerlink" title="Map泛型使用"></a>Map泛型使用</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Map的方式</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="string">'name'</span>:<span class="string">'eagle'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(person.runtimeType);<span class="comment">//_InternalLinkedHashMap&lt;String, Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//限制类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; person2 = &#123;<span class="string">'name'</span>:<span class="string">'eagle'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> person3 = &lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;&#123;<span class="string">'name'</span>:<span class="string">'eagle'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="类定义的泛型"><a href="#类定义的泛型" class="headerlink" title="类定义的泛型"></a>类定义的泛型</h2><ul>
<li><p>如果我们需要定义一个类, 用于存储位置信息Location, 但是并不确定使用者希望使用的是int类型,还是double类型,  甚至是一个字符串, 这个时候如何定义呢?</p>
</li>
<li><p>一种方案是使用Object类型, 但是在之后使用时, 非常不方便</p>
</li>
<li><p>另一种方案就是使用泛型.</p>
</li>
</ul>
<h3 id="Location类的定义-Object方式"><a href="#Location类的定义-Object方式" class="headerlink" title="Location类的定义: Object方式"></a>Location类的定义: Object方式</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"></span><br><span class="line">Location loc1 = Location(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">Location loc2 = Location(<span class="number">10.6</span>, <span class="number">18.8</span>);</span><br><span class="line"><span class="built_in">print</span>(loc1.x.runtimeType); <span class="comment">//int</span></span><br><span class="line"><span class="built_in">print</span>(loc2.x.runtimeType); <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> x;</span><br><span class="line">  <span class="built_in">Object</span> y;</span><br><span class="line">  Location(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Location类的定义-泛型方式"><a href="#Location类的定义-泛型方式" class="headerlink" title="Location类的定义: 泛型方式"></a>Location类的定义: 泛型方式</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断</span></span><br><span class="line">Location loc1 = Location(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">print</span>(loc1.x.runtimeType); <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型  double</span></span><br><span class="line">Location loc2 = Location&lt;<span class="built_in">double</span>&gt;(<span class="number">10.6</span>, <span class="number">18.8</span>);</span><br><span class="line"><span class="built_in">print</span>(loc2.x.runtimeType); <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型  String</span></span><br><span class="line">Location loc3 = Location&lt;<span class="built_in">String</span>&gt;(<span class="string">'abc'</span>, <span class="string">"ad"</span>);</span><br><span class="line"><span class="built_in">print</span>(loc3.x.runtimeType); <span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  T x;</span><br><span class="line">  T y;</span><br><span class="line">  Location(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="如果我们希望类型只能是num类型"><a href="#如果我们希望类型只能是num类型" class="headerlink" title="如果我们希望类型只能是num类型"></a>如果我们希望类型只能是num类型</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">main(<span class="type">List</span>&lt;<span class="type">String</span>&gt; args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断</span></span><br><span class="line"><span class="type">Location</span> loc1 = <span class="type">Location</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">print(loc1.x.runtimeType); <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型  double</span></span><br><span class="line"><span class="type">Location</span> loc2 = <span class="type">Location</span>&lt;double&gt;(<span class="number">10.6</span>, <span class="number">18.8</span>);</span><br><span class="line">print(loc2.x.runtimeType); <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错 因为类型必须继承自num</span></span><br><span class="line"><span class="type">Location</span> loc3 = <span class="type">Location</span>&lt;<span class="type">String</span>&gt;(<span class="symbol">'ab</span>c', <span class="string">"ad"</span>); <span class="comment">//报错</span></span><br><span class="line">print(loc3.x.runtimeType); <span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location&lt;T</span> <span class="keyword">extends</span> <span class="title">num&gt;</span></span>&#123;</span><br><span class="line">  <span class="type">T</span> x;</span><br><span class="line">  <span class="type">T</span> y;</span><br><span class="line">  <span class="type">Location</span>(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h2><ul>
<li>之前，Dart仅仅在类中支持泛型。后来在方法和函数中使用泛型的类型参数。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">'eagle'</span>, <span class="string">'ityongzhen'</span>];</span><br><span class="line">  <span class="keyword">var</span> first = getFirst(names);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$first</span> <span class="subst">$&#123;first.runtimeType&#125;</span>'</span>); <span class="comment">// eagle String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T getFirst&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="keyword">return</span> ts[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考 <a href="https://ke.qq.com/course/469774" target="_blank" rel="noopener">https://ke.qq.com/course/469774</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter学习之Dart语法(三)</title>
    <url>/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%89).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(三).html/">个人博客</a></p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote>
<p>Dart是一个面向对象的语言，面向对象中非常重要的概念就是类，类产生了对象。</p>
</blockquote>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>在Dart中，定义类用class关键字。<br>类通常有两部分组成：成员（member）和方法（method）。<br>定义类的伪代码如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">  类型 成员名;</span><br><span class="line">  返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个简单的Person类：</p>
<ul>
<li>这里有一个注意点: 我们在方法中使用属性(成员/实例变量)时，并没有加this；</li>
<li>Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略；</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在吃东西'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来使用这个类，创建对应的对象：</p>
<ul>
<li>注意：从Dart2开始，new关键字可以省略。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.创建类的对象</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">// 直接使用Person()也可以创建</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.给对象的属性赋值</span></span><br><span class="line">  p.name = <span class="string">'eagle'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.调用对象的方法</span></span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="普通构造方法"><a href="#普通构造方法" class="headerlink" title="普通构造方法"></a>普通构造方法</h3><p>我们知道, 当通过类创建一个对象时，会调用这个类的构造方法。</p>
<ul>
<li>当类中没有明确指定构造方法时，将默认拥有一个无参的构造方法。</li>
<li>前面的Person中我们就是在调用这个构造方法.</li>
</ul>
<p>我们也可以根据自己的需求，定义自己的构造方法:</p>
<p><strong>注意一：</strong>当有了自己的构造方法时，默认的构造方法将会失效，不能使用</p>
<ul>
<li>当然，你可能希望明确的写一个默认的构造方法，但是会和我们自定义的构造方法冲突；</li>
<li>这是因为Dart本身不支持函数的重载（名称相同, 参数不同的方式）。</li>
</ul>
<p><strong>注意二：</strong>这里我还实现了toString方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在实现构造方法时，通常做的事情就是通过<strong>参数给属性</strong>赋值<br>为了简化这一过程, Dart提供了一种更加简洁的语法糖形式.<br>上面的构造方法可以优化成下面的写法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">Person(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span> &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="constructor">Person(<span class="params">this</span>.<span class="params">name</span>, <span class="params">this</span>.<span class="params">age</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="命名构造方法"><a href="#命名构造方法" class="headerlink" title="命名构造方法"></a>命名构造方法</h3><p>但是在开发中, 我们确实希望实现更多的构造方法，怎么办呢？</p>
<p>因为不支持方法（函数）的重载，所以我们没办法创建相同名称的构造方法。</p>
<p>我们需要使用命名构造方法:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person() &#123;</span><br><span class="line">    name = <span class="string">''</span>;</span><br><span class="line">    age = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 命名构造方法</span></span><br><span class="line">  Person.withArgments(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">print</span>(p1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.withArgments(<span class="string">'eagle'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">print</span>(p2);</span><br></pre></td></tr></table></figure>

<p>在之后的开发中, 我们也可以利用命名构造方法，提供更加便捷的创建对象方式:</p>
<p>比如开发中，我们需要经常将一个Map转成对象，可以提供如下的构造方法</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 新的构造方法</span></span><br><span class="line">Person.fromMap(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span>) &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="built_in">map</span>[<span class="string">'name'</span>];</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="built_in">map</span>[<span class="string">'age'</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上面的构造方法创建对象</span></span><br><span class="line"> var p3 = <span class="keyword">new</span> Person.fromMap(&#123;<span class="string">'name'</span>: <span class="string">'kobe'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;);</span><br><span class="line"> <span class="built_in">print</span>(p3);</span><br></pre></td></tr></table></figure>

<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>我们来重新定义一个类Point, 传入x/y，可以得到它们的距离distance:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误写法</span></span><br><span class="line">  <span class="comment">// Point(this.x, this.y) &#123;</span></span><br><span class="line">  <span class="comment">//   distance = sqrt(x * x + y * y);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的写法</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : distance = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种初始化变量的方法, 我们称之为初始化列表(Initializer list)</p>
<h3 id="重定向构造方法"><a href="#重定向构造方法" class="headerlink" title="重定向构造方法"></a>重定向构造方法</h3><p>在某些情况下, 我们希望在一个构造方法中去调用另外一个构造方法, 这个时候可以使用重定向构造方法：</p>
<p>在一个构造函数中，去调用另外一个构造函数（注意：是在冒号后面使用this调用）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="constructor">Person(<span class="params">this</span>.<span class="params">name</span>, <span class="params">this</span>.<span class="params">age</span>)</span>;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>from<span class="constructor">Name(String <span class="params">name</span>)</span> : this(name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量构造方法"><a href="#常量构造方法" class="headerlink" title="常量构造方法"></a>常量构造方法</h3><p>在某些情况下，传入相同值时，我们希望返回同一个对象，这个时候，可以使用常量构造方法.<br>默认情况下，创建对象时，即使传入相同的参数，创建出来的也不是同一个对象，看下面代码:</p>
<p>这里我们使用identical(对象1, 对象2)函数来判断两个对象是否是同一个对象:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 如果将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的</p>
<p>这样的构造方法就称之为常量构造方法。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">const</span> Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">const</span> Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量构造方法有一些注意点:</p>
<ul>
<li>注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的.</li>
<li>注意二: 为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字</li>
</ul>
<p>如果是将结果赋值给const修饰的标识符时，const可以省略.</p>
<h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><p>Dart提供了factory关键字, 用于通过工厂去获取对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Person&gt; _cache = &lt;<span class="built_in">String</span>, Person&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Person(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> p = Person._internal(name);</span><br><span class="line">      _cache[name] = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person._internal(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h2><p>默认情况下，Dart中类定义的属性是可以直接被外界访问的。<br>但是某些情况下，我们希望监控这个类的属性被访问的过程，这个时候就可以使用setter和getter了</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> d = Dog(<span class="string">"黄色"</span>);</span><br><span class="line">  d.setColor = <span class="string">"黑色"</span>;</span><br><span class="line">  <span class="built_in">print</span>(d.getColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog &#123;</span><br><span class="line">  <span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">String</span> <span class="built_in">get</span> getColor &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span> setColor(<span class="keyword">String</span> <span class="built_in">color</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">color</span> = <span class="built_in">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Dog(<span class="keyword">this</span>.<span class="built_in">color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。<br>Dart中的继承使用extends关键字，子类中使用super来访问父类。<br>父类中的所有成员变量和方法都会被继承,，但是构造方法除外。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">main(<span class="type">List</span>&lt;<span class="type">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="type">Person</span>();</span><br><span class="line">  p.age = <span class="number">18</span>;</span><br><span class="line">  p.run();</span><br><span class="line">  print(p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print('在奔跑ing');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类可以拥有自己的成员变量, 并且可以对父类的方法进行重写：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    print('$name在奔跑ing');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类中可以调用父类的构造方法，对某些属性进行初始化：</p>
<p>子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。<br>如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Animal(<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'在奔跑ing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) : name=name, <span class="keyword">super</span>(age);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在奔跑ing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span>, age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们知道，继承是多态使用的前提。<br>所以在定义很多通用的<strong>调用接口</strong>时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。<br>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。<br>什么是 抽象方法? 在Dart中没有具体实现的方法(没有方法体)，就是抽象方法。</p>
<p>抽象方法，必须存在于抽象类中。<br>抽象类是使用abstract声明的类。</p>
<p>下面的代码中, Shape类就是一个抽象类, 其中包含一个抽象方法.</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  getArea();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  double r;</span><br><span class="line"></span><br><span class="line">  <span class="type">Circle</span>(<span class="keyword">this</span>.r);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> r * r * <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  double w;</span><br><span class="line">  double h;</span><br><span class="line"></span><br><span class="line">  <span class="type">Reactangle</span>(<span class="keyword">this</span>.w, <span class="keyword">this</span>.h);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项:</p>
<p><strong>注意一：</strong>抽象类不能实例化.<br><strong>注意二：</strong>抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写.</p>
<h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p>Dart中的接口比较特殊, 没有一个专门的关键字来声明接口.<br>默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现(因为Dart不支持多继承)<br>在开发中，我们通常将用于给别人实现的类声明为抽象类:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Runner</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'超人在奔跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'超人在飞'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h2><p>在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。<br>但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢?</p>
<p>使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。</p>
<p>Dart提供了另外一种方案: Mixin混入的方式</p>
<p>除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。<br>只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  var superMan = SuperMain();</span><br><span class="line">  superMan.run();</span><br><span class="line">  superMan.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Runner &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(<span class="string">'在奔跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Flyer &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    print(<span class="string">'在飞翔'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implements的方式要求必须对其中的方法进行重新实现</span></span><br><span class="line"><span class="comment">// class SuperMan implements Runner, Flyer &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">SuperMain</span> <span class="symbol">with</span> <span class="symbol">Runner, <span class="symbol">Flyer</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类成员和方法"><a href="#类成员和方法" class="headerlink" title="类成员和方法"></a>类成员和方法</h2><p>前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法<br>在Dart中我们使用static关键字来定义:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> stu = Student();</span><br><span class="line">  stu.name = <span class="string">'eagle'</span>;</span><br><span class="line">  stu.sno = <span class="number">110</span>;</span><br><span class="line">  stu.study();</span><br><span class="line"></span><br><span class="line">  Student.time = <span class="string">'早上8点'</span>;</span><br><span class="line">  <span class="comment">// stu.time = '早上9点'; 错误做法, 实例对象不能访问类成员</span></span><br><span class="line">  Student.attendClass();</span><br><span class="line">  <span class="comment">// stu.attendClass(); 错误做法, 实现对象补鞥呢访问类方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> sno;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> time;</span><br><span class="line"></span><br><span class="line">  study() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在学习'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> attendClass() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'去上课'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举在开发中也非常常见, 枚举也是一种特殊的类, 通常用于表示固定数量的常量值。</p>
<h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举使用enum关键字来进行定义:</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(Colors.red);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colors</span> &#123;</span></span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举的属性"><a href="#枚举的属性" class="headerlink" title="枚举的属性"></a>枚举的属性</h3><p>枚举类型中有两个比较常见的属性:</p>
<p>index: 用于表示每个枚举常量的索引, 从0开始.<br>values: 包含每个枚举值的List.</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">red</span>.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">green</span>.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">blue</span>.index);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(Colors.values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  <span class="built_in">red</span>,</span><br><span class="line">  <span class="built_in">green</span>,</span><br><span class="line">  <span class="built_in">blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型的注意事项:</p>
<ul>
<li>注意一: 您不能子类化、混合或实现枚举。</li>
<li>注意二: 不能显式实例化一个枚举</li>
</ul>
<p>参考 <a href="https://ke.qq.com/course/469774" target="_blank" rel="noopener">https://ke.qq.com/course/469774</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter学习之Dart语法(二)</title>
    <url>/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%BA%8C).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(二).html/">个人博客</a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基本定义"><a href="#函数的基本定义" class="headerlink" title="函数的基本定义"></a>函数的基本定义</h3><ul>
<li>Dart是一种真正的面向对象语言，所以即使函数也是对象，所有也有类型, 类型就是Function。</li>
<li>这也就意味着函数可以作为变量定义或者作为其他函数的参数或者返回值.</li>
</ul>
<p>函数的定义方式:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">返回值 函数的名称(参数列表) &#123;</span><br><span class="line">  函数体</span><br><span class="line">  <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的定义方式, 我们定义一个完整的函数:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> sum(<span class="built_in">num</span> num1, <span class="built_in">num</span> num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Effective Dart建议对公共的API, 使用类型注解, 但是如果我们省略掉了类型, 依然是可以正常工作的</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sum</span>(num1, num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外, 如果函数中只有一个表达式, 那么可以使用箭头语法(arrow syntax)</p>
<ul>
<li>注意, 这里面只能是一个表达式, 不能是一个语句</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">sum<span class="comment">(num1, num2)</span> =&gt; <span class="symbol">num1</span> + <span class="symbol">num2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数的参数问题"><a href="#函数的参数问题" class="headerlink" title="函数的参数问题"></a>函数的参数问题</h3><blockquote>
<p>函数的参数可以分成两类: 必须参数和可选参数<br>前面使用的参数都是必须参数.</p>
</blockquote>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>可选参数可以分为 命名可选参数 和 位置可选参数<br>定义方式:</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">命名可选参数: &#123;para<span class="name">m1</span>, para<span class="name">m2</span>, ...&#125;</span><br><span class="line">位置可选参数: [para<span class="name">m1</span>, para<span class="name">m2</span>, ...]</span><br></pre></td></tr></table></figure>

<p>命名可选参数的演示:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数</span></span><br><span class="line">print<span class="constructor">Info1(String <span class="params">name</span>, &#123;<span class="params">int</span> <span class="params">age</span>, <span class="params">double</span> <span class="params">height</span>&#125;)</span> &#123;</span><br><span class="line">  print('name=$name age=$age height=$height');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printInfo1函数</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>')</span>; <span class="comment">// name=eagle age=null height=null</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">age</span>: 18)</span>; <span class="comment">// name=eagle age=18 height=null</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">age</span>: 18, <span class="params">height</span>: 1.88)</span>; <span class="comment">// name=eagle age=18 height=1.88</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">height</span>: 1.88)</span>; <span class="comment">// name=eagle age=null height=1.88</span></span><br></pre></td></tr></table></figure>

<p>位置可选参数的演示:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义位置可选参数</span></span><br><span class="line">print<span class="constructor">Info2(String <span class="params">name</span>, [<span class="params">int</span> <span class="params">age</span>, <span class="params">double</span> <span class="params">height</span>])</span> &#123;</span><br><span class="line">  print('name=$name age=$age height=$height');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printInfo2函数</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>')</span>; <span class="comment">// name=eagle age=null height=null</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>', 18)</span>; <span class="comment">// name=eagle age=18 height=null</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>', 18, 1.88)</span>; <span class="comment">// name=eagle age=18 height=1.88</span></span><br></pre></td></tr></table></figure>

<p>命名可选参数, 可以指定某个参数是必传的(使用@required, 有问题)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数的必须</span></span><br><span class="line">printInfo3(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age, <span class="built_in">double</span> height, <span class="meta">@required</span> <span class="built_in">String</span> address&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span> address=<span class="subst">$address</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>参数可以有默认值, 在不传入的情况下, 使用默认值</p>
<p>注意, 只有可选参数才可以有默认值, 必须参数不能有默认值</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数的默认值</span></span><br><span class="line">printInfo4(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age = <span class="number">18</span>, <span class="built_in">double</span> height=<span class="number">1.88</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dart中的main函数就是一个接受可选的列表参数作为参数的, 所以在使用main函数时, 我们可以传入参数, 也可以不传入</p>
<h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>在很多语言中, 函数并不能作为一等公民来使用, 比如Java/OC. 这种限制让编程不够灵活, 所以现代的编程语言基本都支持函数作为一等公民来使用, Dart也支持.<br>这就意味着你可以将函数赋值给一个变量, 也可以将函数作为另外一个函数的参数或者返回值来使用.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.将函数赋值给一个变量</span></span><br><span class="line">  <span class="keyword">var</span> bar = foo;</span><br><span class="line">  <span class="built_in">print</span>(bar);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.将函数作为另一个函数的参数</span></span><br><span class="line">  test(foo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">  <span class="keyword">var</span> func =getFunc();</span><br><span class="line">  func(<span class="string">'kobe'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个函数</span></span><br><span class="line">foo(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'传入的name:<span class="subst">$name</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将函数作为另外一个函数的参数</span></span><br><span class="line">test(<span class="built_in">Function</span> func) &#123;</span><br><span class="line">  func(<span class="string">'eagle'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">getFunc() &#123;</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数的使用"><a href="#匿名函数的使用" class="headerlink" title="匿名函数的使用"></a>匿名函数的使用</h3><p>大部分我们定义的函数都会有自己的名字， 比如前面定义的foo、test函数等等。<br>但是某些情况下，给函数命名太麻烦了，我们可以使用没有名字的函数，这种函数可以被称之为匿名函数( anonymous function)，也可以叫lambda或者closure。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">main(<span class="keyword">List</span>&lt;String&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.定义数组</span></span><br><span class="line">  <span class="keyword">var</span> movies = [<span class="string">'盗梦空间'</span>, <span class="string">'星际穿越'</span>, <span class="string">'少年派'</span>, <span class="string">'大话西游'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.使用forEach遍历: 有名字的函数</span></span><br><span class="line">  printElement(item) &#123;</span><br><span class="line">    <span class="keyword">print</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  movies.<span class="keyword">forEach</span>(printElement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.使用forEach遍历: 匿名函数</span></span><br><span class="line">  movies.<span class="keyword">forEach</span>((item) &#123;</span><br><span class="line">    <span class="keyword">print</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  movies.<span class="keyword">forEach</span>((item) =&gt; <span class="keyword">print</span>(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>dart中的词法有自己明确的作用域范围，它是根据代码的结构({})来决定作用域范围的<br>优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// var name = 'main';</span></span><br><span class="line">  <span class="keyword">void</span> foo() &#123;</span><br><span class="line">    <span class="comment">// var name = 'foo';</span></span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h3><p>闭包可以访问其词法范围内的变量，即使函数在其他地方被使用，也可以正常的访问。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">num</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i + addBy;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adder2 = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">10</span>)); <span class="comment">// 12</span></span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">6</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adder5 = makeAdder(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder5(<span class="number">10</span>)); <span class="comment">// 15</span></span><br><span class="line">  <span class="built_in">print</span>(adder5(<span class="number">6</span>)); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值问题"><a href="#返回值问题" class="headerlink" title="返回值问题"></a>返回值问题</h3><p>所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo()); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'foo function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="除法、整除、取模运算"><a href="#除法、整除、取模运算" class="headerlink" title="除法、整除、取模运算"></a>除法、整除、取模运算</h3><p>我们来看一下除法、整除、取模运算</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> / <span class="number">3</span>); <span class="comment">// 除法操作, 结果2.3333..</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> ~/ <span class="number">3</span>); <span class="comment">// 整除操作, 结果2;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> % <span class="number">3</span>); <span class="comment">// 取模操作, 结果1;</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="??=赋值操作"></a>??=赋值操作</h3><p>dart有一个很多语言都不具备的赋值运算符：</p>
<ul>
<li>当变量为null时，使用后面的内容进行赋值。</li>
<li>当变量有值时，使用自己原来的值。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> name1 = <span class="string">'eagle'</span>;</span><br><span class="line">  <span class="built_in">print</span>(name1);</span><br><span class="line">  <span class="comment">// var name2 = 'kobe';</span></span><br><span class="line">  <span class="keyword">var</span> name2 = <span class="keyword">null</span>;</span><br><span class="line">  name2 ??= <span class="string">'james'</span>; </span><br><span class="line">  <span class="built_in">print</span>(name2); <span class="comment">// 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件运算符："><a href="#条件运算符：" class="headerlink" title="条件运算符："></a>条件运算符：</h3><p>Dart中包含一直比较特殊的条件运算符：expr1 ?? expr2</p>
<ul>
<li>如果expr1是null，则返回expr2的结果;</li>
<li>如果expr1不是null，直接使用expr1的结果。</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">temp</span> = <span class="string">'eagle'</span>;</span><br><span class="line">var <span class="keyword">temp</span> = <span class="keyword">null</span>;</span><br><span class="line">var <span class="type">name</span> = <span class="keyword">temp</span> ?? <span class="string">'kobe'</span>;</span><br><span class="line">print(<span class="type">name</span>);</span><br></pre></td></tr></table></figure>

<h3 id="级联语法："><a href="#级联语法：" class="headerlink" title="级联语法：.."></a>级联语法：..</h3><ul>
<li>某些时候，我们希望对一个对象进行连续的操作，这个时候可以使用级联语法</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  void <span class="builtin-name">run</span>() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is running"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void eat() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is eating"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swim() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is swimming"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p1 = Person();</span><br><span class="line">  p1.name = <span class="string">'eagle'</span>;</span><br><span class="line">  p1.<span class="builtin-name">run</span>();</span><br><span class="line">  p1.eat();</span><br><span class="line">  p1.swim();</span><br><span class="line"></span><br><span class="line">  final p2 = Person()</span><br><span class="line">              <span class="built_in">..</span>name = <span class="string">"eagle"</span></span><br><span class="line">              <span class="built_in">..</span><span class="builtin-name">run</span>()</span><br><span class="line">              <span class="built_in">..</span>eat()</span><br><span class="line">              <span class="built_in">..</span>swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>和大部分语言的特性比较相似，这里就不再详细赘述，看一下即可。</p>
<h3 id="if和else"><a href="#if和else" class="headerlink" title="if和else"></a>if和else</h3><p>和其他语言用法一样<br>这里有一个注意点：不支持非空即真或者非0即真，必须有明确的bool类型</p>
<ul>
<li>我们来看下面name为null的判断</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">var age = <span class="built_in">null</span>;</span><br><span class="line"><span class="keyword">if</span>(age)&#123; <span class="comment">//错误的用法</span></span><br><span class="line">   <span class="keyword">print</span>(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h3><p>基本的for循环</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  print(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for in遍历List和Set类型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'eagle'</span>, <span class="string">'kobe'</span>, <span class="string">'curry'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names) &#123;</span><br><span class="line">  <span class="built_in">print</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while和do-while和其他语言一致<br>break和continue用法也是一致</p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>普通的switch使用</p>
<p>注意：每一个case语句，默认情况下必须以一个break结尾</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> direction = <span class="string">'east'</span>;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'east'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'东面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'south'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'南面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'west'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'西面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'north'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'北面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'其他方向'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考 <a href="https://juejin.im/post/5d76340c6fb9a06adb800961" target="_blank" rel="noopener">Flutter(三)之搞定Dart（一）</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter学习之Dart语法(一)</title>
    <url>/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(一).html/">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准 。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</li>
<li>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system</li>
</ul>
<p><strong>Google为Flutter选择了Dart作为开发语言</strong></p>
<p>关于Dart的环境安装和配置这里就不赘述了。</p>
<h2 id="新建程序"><a href="#新建程序" class="headerlink" title="新建程序"></a>新建程序</h2><p>用VSCode新建一个Dart文件，默认是如下代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这也和Java,C等等其他语言一样，main函数作为入口。</p>
<ul>
<li>Dart语言的入口也是main函数，并且必须显示的进行定义；</li>
<li>Dart的入口函数main是没有返回值的；</li>
<li>传递给main的命令行参数，是通过List<String>完成的。<ul>
<li>从字面值就可以理解List是Dart中的集合类型。</li>
<li>其中的每一个String都表示传递给main的一个参数；</li>
</ul>
</li>
<li>定义字符串的时候，可以使用单引号或双引号；</li>
<li>每行语句必须使用分号结尾，很多语言并不需要分号，比如Swift、JavaScript；</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="明确声明-Explicit"><a href="#明确声明-Explicit" class="headerlink" title="明确声明(Explicit)"></a>明确声明(Explicit)</h3><p>明确声明变量的方式, 格式如下:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">变量类型 变量名称 = 赋值<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>


<p>注意: 定义的变量可以修改值, 但是不能赋值其他类型</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">String <span class="attribute">content</span> = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="attribute">content</span> = <span class="string">'Hello China'</span>; <span class="comment">// 正确的</span></span><br><span class="line"><span class="attribute">content</span> = <span class="number">111</span>; <span class="comment">// 错误的, 将一个int值赋值给一个String变量</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推导-Type-Inference"><a href="#类型推导-Type-Inference" class="headerlink" title="类型推导(Type Inference)"></a>类型推导(Type Inference)</h3><p>和swift等语言类似，Dart也是支持类型推导的，类型推导声明变量的方式, 格式如下:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="keyword">dynamic</span>/<span class="keyword">const</span>/<span class="keyword">final</span> 变量名称 = 赋值;</span><br></pre></td></tr></table></figure>

<h4 id="var的使用"><a href="#var的使用" class="headerlink" title="var的使用"></a>var的使用</h4><p>var的使用示例:</p>
<ul>
<li>runtimeType用于获取变量当前的类型</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">name</span> = <span class="string">'ITYongzhen'</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// String</span></span><br></pre></td></tr></table></figure>

<p>var的错误用法:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="string">'eagle'</span>; <span class="comment">// 不可以将String赋值给一个int类型</span></span><br></pre></td></tr></table></figure>

<h4 id="dynamic的使用"><a href="#dynamic的使用" class="headerlink" title="dynamic的使用"></a>dynamic的使用</h4><p>如果确实希望这样做,可以使用dynamic来声明变量:</p>
<ul>
<li>但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">name</span> = <span class="number">18</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<h4 id="final-amp-const的使用"><a href="#final-amp-const的使用" class="headerlink" title="final&amp;const的使用"></a>final&amp;const的使用</h4><p>final和const都是用于定义常量的, 也就是定义之后值都不可以修改</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">final <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">name</span> = <span class="string">'ITyongzhen'</span>; <span class="comment">// 错误做法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="number">20</span>; <span class="comment">// 错误做法</span></span><br></pre></td></tr></table></figure>

<h4 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h4><p>const在赋值时, 赋值的内容必须是在编译期间就确定下来的<br>final在赋值时, 可以动态获取, 比如赋值一个函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> getName() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'eagle'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = getName(); <span class="comment">// 错误的做法, 因为要执行函数才能获取到值</span></span><br><span class="line">  <span class="keyword">final</span> name = getName(); <span class="comment">// 正确的做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final和const小案例:</p>
<ul>
<li>首先, const是不可以赋值为DateTime.now()</li>
<li>其次, final一旦被赋值后就有确定的结果, 不会再次赋值</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const time = DateTime.now(); // 错误的赋值方式</span></span><br><span class="line">final time = DateTime.now();</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">time</span>); <span class="comment">// 2020-02-05 12:04:50.052626</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">time</span>); <span class="comment">// 2020-02-05 12:04:50.052626</span></span><br></pre></td></tr></table></figure>

<p>const放在赋值语句的右边，可以共享对象，提高性能:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">Person</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> a = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="keyword">final</span> b = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(a, b)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> m = Person();</span><br><span class="line">  <span class="keyword">final</span> n = Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(m, n)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><h4 id="int和double"><a href="#int和double" class="headerlink" title="int和double"></a><code>int</code>和<code>double</code></h4><p>对于数值来说，我们也不用关心它是否有符号，以及数据的宽度和精度等问题。只要记着整数用<code>int</code>，浮点数用<code>double</code>就行了。<br>不过，要注意的是<code>Dart</code>中的<code>int</code>和<code>double</code>可表示的范围并不是固定的，它取决于运行Dart的平台。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.整数类型int</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> hexAge = <span class="number">0x12</span>;</span><br><span class="line"><span class="built_in">print</span>(age);</span><br><span class="line"><span class="built_in">print</span>(hexAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.浮点类型double</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">height</span> = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">height</span>);</span><br></pre></td></tr></table></figure>

<h4 id="字符串和数字之间的转化"><a href="#字符串和数字之间的转化" class="headerlink" title="字符串和数字之间的转化"></a>字符串和数字之间的转化</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串和数字转化</span></span><br><span class="line"><span class="comment">// 1.字符串转数字</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">'111'</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="built_in">double</span>.parse(<span class="string">'12.22'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;one&#125;</span> <span class="subst">$&#123;one.runtimeType&#125;</span>'</span>); <span class="comment">// 111 int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;two&#125;</span> <span class="subst">$&#123;two.runtimeType&#125;</span>'</span>); <span class="comment">// 12.22 double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.数字转字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123.456</span>;</span><br><span class="line"><span class="keyword">var</span> num1Str = num1.toString();</span><br><span class="line"><span class="keyword">var</span> num2Str = num2.toString();</span><br><span class="line"><span class="keyword">var</span> num2StrD = num2.toStringAsFixed(<span class="number">2</span>); <span class="comment">// 保留两位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num1Str&#125;</span> <span class="subst">$&#123;num1Str.runtimeType&#125;</span>'</span>); <span class="comment">// 123 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num2Str&#125;</span> <span class="subst">$&#123;num2Str.runtimeType&#125;</span>'</span>); <span class="comment">// 123.456 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num2StrD&#125;</span> <span class="subst">$&#123;num2StrD.runtimeType&#125;</span>'</span>); <span class="comment">// 123.46 String</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型中,Dart提供了一个bool的类型, 取值为true和false</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="keyword">var</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$isFlag</span> <span class="subst">$&#123;isFlag.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意: Dart中不能判断非0即真, 或者非空即真</strong></p>
<p>Dart的类型安全性意味着您不能使用if(非booleanvalue)或assert(非booleanvalue)之类的代码。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">message</span> = <span class="string">'Hello Dart'</span>;</span><br><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">message</span>) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  print(message)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>Dart字符串是UTF-16编码单元的序列。您可以使用单引号或双引号创建一个字符串:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义字符串的方式</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="symbol">'Hello</span> <span class="type">World</span>';</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"Hello Dart"</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="symbol">'Hello</span>\<span class="symbol">'Fullte</span>r';</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">"Hello'Fullter"</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用三个单引号或者双引号表示多行字符串:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="number">2</span>.表示多行字符串的方式</span><br><span class="line">var message1 = <span class="string">'''</span></span><br><span class="line"><span class="string">哈哈哈</span></span><br><span class="line"><span class="string">呵呵呵</span></span><br><span class="line"><span class="string">嘿嘿嘿'''</span>;</span><br></pre></td></tr></table></figure>

<p>字符串和其他变量或表达式拼接: 使用<code>${expression}</code>, 如果表达式是一个标识符, 那么<code>{}</code>可以省略</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.拼接其他变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$age</span>, height is <span class="subst">$height</span>'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><ul>
<li>集合类型的定义</li>
</ul>
<p>对于集合类型，Dart则内置了最常用的三种：<code>List / Set / Map</code>。<br>其中，<code>List</code>可以这样来定义</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$letters</span> <span class="subst">$&#123;letters.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$&#123;numbers.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>

<p>其中，<code>set</code>可以这样来定义：</p>
<p>其实，也就是把[]换成{}就好了。<br>Set和List最大的两个不同就是：Set是无序的，并且元素是不重复的。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set的定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> lettersSet = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$lettersSet</span> <span class="subst">$&#123;lettersSet.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">int</span>&gt; numbersSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbersSet</span> <span class="subst">$&#123;numbersSet.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>

<p>最后，Map是我们常说的字典类型，它的定义是这样的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> infoMap1 = &#123;<span class="string">'name'</span>: <span class="string">'eagle'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$infoMap1</span> <span class="subst">$&#123;infoMap1.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; infoMap2 = &#123;<span class="string">'height'</span>: <span class="number">1.88</span>, <span class="string">'address'</span>: <span class="string">'北京市'</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$infoMap2</span> <span class="subst">$&#123;infoMap2.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="集合的常见操作"><a href="#集合的常见操作" class="headerlink" title="集合的常见操作"></a>集合的常见操作</h4><p>了解了这三个集合的定义方式之后，我们来看一些最基础的公共操作</p>
<p>第一类，是所有集合都支持的获取长度的属性length：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取集合的长度</span></span><br><span class="line"><span class="keyword">print</span>(letters.length);</span><br><span class="line"><span class="keyword">print</span>(lettersSet.length);</span><br><span class="line"><span class="keyword">print</span>(infoMap1.length);</span><br></pre></td></tr></table></figure>

<p>第二类, 是添加/删除/包含操作</p>
<p>并且，对List来说，由于元素是有序的，它还提供了一个删除指定索引位置上元素的方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加/删除/包含元素</span></span><br><span class="line">numbers.add(<span class="number">5</span>);</span><br><span class="line">numbersSet.add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$numbersSet</span>'</span>);</span><br><span class="line"></span><br><span class="line">numbers.remove(<span class="number">1</span>);</span><br><span class="line">numbersSet.remove(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$numbersSet</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers.contains(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">print</span>(numbersSet.contains(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// List根据index删除元素</span></span><br><span class="line">numbers.removeAt(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span>'</span>);</span><br></pre></td></tr></table></figure>

<p>第三类，是Map的操作</p>
<p>由于它有key和value，因此无论是读取值，还是操作，都要明确是基于key的，还是基于value的，或者是基于key/value对的。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的操作</span></span><br><span class="line"><span class="comment">// 1.根据key获取value</span></span><br><span class="line"><span class="built_in">print</span>(infoMap1[<span class="string">'name'</span>]); <span class="comment">// eagle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取所有的entries</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.entries&#125;</span> <span class="subst">$&#123;infoMap1.entries.runtimeType&#125;</span>'</span>); <span class="comment">// (MapEntry(name: eagle), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取所有的keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.keys&#125;</span> <span class="subst">$&#123;infoMap1.keys.runtimeType&#125;</span>'</span>); <span class="comment">// (name, age) _CompactIterable&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取所有的values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.values&#125;</span> <span class="subst">$&#123;infoMap1.values.runtimeType&#125;</span>'</span>); <span class="comment">// (eagle, 18) _CompactIterable&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.判断是否包含某个key或者value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.containsKey(<span class="string">'age'</span>)&#125;</span> <span class="subst">$&#123;infoMap1.containsValue(<span class="number">18</span>)&#125;</span>'</span>); <span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.根据key删除元素</span></span><br><span class="line">infoMap1.remove(<span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1&#125;</span>'</span>); <span class="comment">// &#123;name: eagle&#125;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之类型转换</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之类型转换.html/">个人博客</a></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>C语言风格的类型转换符<ul>
<li><code>(type)expression</code></li>
<li><code>type(expression)</code></li>
</ul>
</li>
<li>C++中有4个类型转换符<ul>
<li><code>static_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>const_cast</code></li>
<li>使用格式：<code>xx_cast&lt;type&gt;(expression)</code></li>
</ul>
</li>
</ul>
<p>我们有如下Person类和Student类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">     <span class="built_in">void</span> run() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span> : <span class="symbol">public</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接用子类指针指向父类对象，编译报错</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Student *p = <span class="keyword">new</span> <span class="type">Person</span>(); <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<p>C语言的做法一般是</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Student *p = (Student *)<span class="keyword">new</span> <span class="type">Person</span>(); <span class="comment">//编译正常</span></span><br></pre></td></tr></table></figure>

<p>强制转换只是欺骗编译器，有时候编译正常，执行会报错。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h2><ul>
<li>一般用于去除<code>const</code>属性，将<code>const</code>转换成非<code>const</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1-&gt;age = <span class="number">10</span>; <span class="comment">//编译报错</span></span><br><span class="line">    </span><br><span class="line">Person *p2 = <span class="keyword">const_cast</span>&lt;Person *&gt;(p1);</span><br><span class="line">p2-&gt;age = <span class="number">10</span>; <span class="comment">//编译正常</span></span><br></pre></td></tr></table></figure>

<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h2><ul>
<li>◼ 一般用于多态类型的转换，有运行时安全检测</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student *stu1 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(P1); <span class="comment">//null</span></span><br><span class="line">    Student *stu2 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line">    Car *car = <span class="keyword">dynamic_cast</span>&lt;Car *&gt;(P1); <span class="comment">//null</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; car&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x100660110</span></span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，随便编译都是正常的。但是运行的事，检测到P1不是Student类型，也不是Car类型，所以转换之后的stu1和car都是Null.</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h2><p>对比dynamic_cast，缺乏运行时安全检测</p>
<ul>
<li>不能交叉转换（不是同一继承体系的，无法转换）</li>
<li>常用于基本数据类型的转换、非const转成const</li>
</ul>
<p>上面的代码中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student *stu1 = <span class="keyword">static_cast</span>&lt;Student *&gt;(P1);</span><br><span class="line">    Student *stu2 = <span class="keyword">static_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line"><span class="comment">//    Car *car = static_cast&lt;Car *&gt;(P1); //编译报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x100555390</span></span><br><span class="line"><span class="number">0x10063e9b0</span></span><br></pre></td></tr></table></figure>
<p>可知<code>Person</code>类型的P1可以转换为 Person <code>类型或者</code>Student `类型</p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h2><ul>
<li>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝</li>
<li>可以交叉转换</li>
<li>可以将指针和整数互相转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line"> Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line"> Student *stu1 = <span class="keyword">reinterpret_cast</span>&lt;Student *&gt;(P1); <span class="comment">//null</span></span><br><span class="line"> Student *stu2 = <span class="keyword">reinterpret_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line"> Car *car = <span class="keyword">reinterpret_cast</span>&lt;Car *&gt;(P1);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; car&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>输出如下，可知都可以转换成功，因为只是拷贝二进制</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x10062e6e0</span></span><br><span class="line"><span class="number">0x10062b940</span></span><br><span class="line"><span class="number">0x10062e6e0</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之模板</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之模板.html/">个人博客</a></p>
<h2 id="模板（template）"><a href="#模板（template）" class="headerlink" title="模板（template）"></a>模板（template）</h2><ul>
<li><p>泛型，是一种将类型参数化以达到代码复用的技术，很多语言中都有，例如Java,Swift等，C++中使用模板来实现泛型</p>
</li>
<li><p>模板的使用格式如下</p>
<ul>
<li><code>template &lt;typename\class T&gt;</code></li>
<li><code>typename和class是等价的</code></li>
</ul>
</li>
<li><p>模板没有被使用时，是不会被实例化出来的</p>
</li>
<li><p>模板的声明和实现如果分离到.h和.cpp中，会导致链接错误</p>
</li>
<li><p>一般将模板的声明和实现统一放到一个.hpp文件中</p>
</li>
</ul>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>格式为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者和下面是一样的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 形参名，<span class="keyword">typename</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如我们有2个函数，分别计算int 类型和 double类型的加法运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的每个函数只能实现一种数据类型的运算，所以我们用模板就可以用一个函数来表示</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">template &lt;typename <span class="literal">T</span>&gt;</span><br><span class="line"><span class="literal">T</span> add(<span class="literal">T</span> a, <span class="literal">T</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">int</span> c = add&lt;<span class="built_in">int</span>&gt;(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以把类型去掉，这样调用函数的时候，会隐式转换</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">int</span> c = add(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多参数模板"><a href="#多参数模板" class="headerlink" title="多参数模板"></a>多参数模板</h2><ul>
<li>有时候我们的可以多参数，并且是不同类型的</li>
</ul>
<p>例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>,typename <span class="built_in">T2</span>&gt;</span><br><span class="line"><span class="built_in">T2</span> <span class="keyword">add(T1 </span>a, <span class="built_in">T2</span> <span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是一般来说，为了避免生成不必要的中间变量，以及为了代码安全性，上面代码可以改成如下</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>,typename <span class="built_in">T2</span>&gt;</span><br><span class="line"><span class="built_in">T2</span> <span class="keyword">add(const </span><span class="built_in">T1</span> &amp;a,const <span class="built_in">T2</span> &amp;<span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>不仅仅有函数模板，而且还有类模板<br>例如，我们自定义一个数组类，可以接收各种类型的数据</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;, <span class="keyword">const</span> Array&lt;Item&gt; &amp;);</span><br><span class="line">	<span class="comment">// 用于指向首元素</span></span><br><span class="line">	Item *m_data;</span><br><span class="line">	<span class="comment">// 元素个数</span></span><br><span class="line">	<span class="keyword">int</span> m_size;</span><br><span class="line">	<span class="comment">// 容量</span></span><br><span class="line">	<span class="keyword">int</span> m_capacity;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Array(<span class="keyword">int</span> capacity = <span class="number">0</span>);</span><br><span class="line">	~Array();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Item value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Item value)</span></span>;</span><br><span class="line">	<span class="function">Item <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	Item <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Array&lt;Item&gt;::Array(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">	m_capacity = (capacity &gt; <span class="number">0</span>) ? capacity : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请堆空间</span></span><br><span class="line">	m_data = <span class="keyword">new</span> Item[m_capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Array&lt;Item&gt;::~Array() &#123;</span><br><span class="line">	<span class="keyword">if</span> (m_data == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::checkIndex(<span class="keyword">int</span> index) &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= m_size) &#123;</span><br><span class="line">		<span class="comment">// 报错：抛异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"数组下标越界"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::add(Item value) &#123;</span><br><span class="line">	<span class="keyword">if</span> (m_size == m_capacity) &#123;</span><br><span class="line">		<span class="comment">// 扩容</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.申请一块更大的新空间</span></span><br><span class="line"><span class="comment">		2.将旧空间的数据拷贝到新空间</span></span><br><span class="line"><span class="comment">		3.释放旧空间</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里只做简单的打印</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"空间不够"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_data[m_size++] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::<span class="built_in">remove</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">	checkIndex(index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::insert(<span class="keyword">int</span> index, Item value) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Item Array&lt;Item&gt;::<span class="built_in">get</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">	checkIndex(index);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">int</span> Array&lt;Item&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">	<span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Item Array&lt;Item&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;<span class="built_in">cout</span>, <span class="keyword">const</span> Array&lt;Item&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.m_size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.m_data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候</p>
<p>定义坐标类Point</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">	friend ostream &amp;operator&lt;&lt;(ostream &amp;, const Point &amp;);</span><br><span class="line">	<span class="built_in">int</span> m_x;</span><br><span class="line">	<span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">Point(<span class="params">int</span> <span class="params">x</span> = 0, <span class="params">int</span> <span class="params">y</span> = 0)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个数组里面可以存放Point类型的</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">Point</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">get</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<p>也可以存放int类型数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">int</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>


<h2 id="类模板中的友元函数"><a href="#类模板中的友元函数" class="headerlink" title="类模板中的友元函数"></a>类模板中的友元函数</h2><p>上的代码中已经包含了友元函数，是运算符号<code>&lt;&gt;</code>重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;, <span class="keyword">const</span> Array&lt;Item&gt; &amp;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;<span class="built_in">cout</span>, <span class="keyword">const</span> Array&lt;Item&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.m_size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.m_data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下使用，就可以按照我们重载的方式来打印array的数值了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">	<span class="keyword">Array</span>&lt;<span class="type">Point</span>&gt; <span class="keyword">array</span>;</span><br><span class="line">	<span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">	<span class="keyword">array</span>.remove(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">array</span>.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="keyword">array</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之内部类和局部类</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之内部类和局部类.html/">个人博客</a></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>如果将类A定义在类C的内部，那么类A就是一个内部类（嵌套类）</li>
<li>内部类的特点<ul>
<li>支持public、protected、private权限</li>
<li>成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</li>
<li>成员函数可以直接不带类名、对象名访问其外部类的static成员</li>
<li>不会影响外部类的内存布局</li>
<li>可以在外部类内部声明，在外部类外面进行定义</li>
</ul>
</li>
</ul>
<p>如下的<code>Car</code>类就是<code>Person</code>类的内部类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="symbol">Car</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">int</span> m_price;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><ul>
<li>在一个函数内部定义的类，称为局部类</li>
<li>局部类的特点<ul>
<li>作用域仅限于所在的函数内部</li>
<li>其所有的成员必须定义在类内部，不允许定义static成员变量</li>
<li>成员函数不能直接访问函数的局部变量（static变量除外）</li>
</ul>
</li>
</ul>
<p>如下<code>Car</code>类就属于局部类</p>
<pre><code>void test() {
    static int age = 10;

    // 局部类
    class Car {
    public:
        void run() {
            age = 20;
        }
    };

    Car car;
    car.run();
}</code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之友元函数、友元类</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之友元函数、友元类.html/">个人博客</a></p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul>
<li>友元包括友元函数和友元类</li>
<li>如果将函数A（非成员函数）声明为类C的友元函数，那么函数A就能直接访问类C对象的所有成员</li>
<li>如果将类A声明为类C的友元类，那么类A的所有成员函数都能直接访问类C对象的所有成员</li>
<li>友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能</li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>如下代码：类Point。x和y坐标，成员变量是私有的，获取值通过get函数获取</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_x;</span><br><span class="line">    <span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">X()</span> &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Y()</span> &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="constructor">Point(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">    void display<span class="literal">()</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point add(Point p1, Point p2) &#123;</span><br><span class="line">    return <span class="constructor">Point(<span class="params">p1</span>.<span class="params">getX</span>()</span> + p2.get<span class="constructor">X()</span>, p1.get<span class="constructor">Y()</span> + p2.get<span class="constructor">Y()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义2个point，然后我们想把这两个point相加。就如下所示</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    Point p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    Point p2(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    Point p3 = add(p1, p2);</span><br><span class="line">    p3.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>能达到要求，但是问题是，调用add函数时候，每次获取x和y的值，都要通过<code>getX()</code>或者<code>getY()</code>来取值。因为<code>m_x</code>是私有成员，使用<code>p1. m_x</code>是会报错的。</li>
<li>有什么办法能直接<code>p1. m_x</code>就可以访问么。同时<code>m_x</code>依然是私有成员</li>
</ul>
<h3 id="那就通过友元函数来实现"><a href="#那就通过友元函数来实现" class="headerlink" title="那就通过友元函数来实现"></a>那就通过友元函数来实现</h3><p>上的代码改成</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">     friend Point add(Point, Point);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_x;</span><br><span class="line">    <span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">X()</span> &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Y()</span> &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="constructor">Point(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">    void display<span class="literal">()</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point add(Point p1, Point p2) &#123;</span><br><span class="line">    return <span class="constructor">Point(<span class="params">p1</span>.<span class="params">m_x</span> + <span class="params">p2</span>.<span class="params">m_x</span>, <span class="params">p1</span>.<span class="params">m_y</span> + <span class="params">p2</span>.<span class="params">m_y</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说把<code>friend Point add(Point, Point)</code>放在<code>class Point</code>中,这样说明这个函数是朋友了嘛，既然是朋友了，那可以直接访问私有成员变量。当然了其他函数想直接访问私有成员变量依然是不可以的。</p>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>既然和函数可以做朋友，那和类呢？答案是可以的。如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point <span class="title">add</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">        p1.m_x = <span class="number">10</span>;</span><br><span class="line">        p1.m_x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>class Point</code> 中声明了友元类<code>friend class Math;</code>那么在类<code>Math</code>中也是可以直接访问类<code>Point</code>中的私有成员变量。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之static、const</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8Bstatic%E3%80%81const.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之static、const.html/">个人博客</a></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li><p>静态成员的提出是为了解决数据共享的问题。实现共享有许多方法，如：设置全局性的变量或对象是一种方法。但是，全局变量或对象是有局限性的。</p>
</li>
<li><p>静态成员：被static修饰的成员变量\函数</p>
<ul>
<li>可以通过对象（对象.静态成员）、对象指针（对象指针-&gt;静态成员）、类访问（类名::静态成员）</li>
</ul>
</li>
<li><p>静态成员变量</p>
<ul>
<li>存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存</li>
<li>对比全局变量，它可以设定访问权限（public、protected、private），达到局部共享的目的</li>
<li>必须初始化，必须在类外面初始化，初始化时不能带static，如果类的声明和实现分离（在实现.cpp中初始化）</li>
</ul>
</li>
<li><p>静态成员函数</p>
<ul>
<li>内部不能使用this指针（this指针只能用在非静态成员函数内部）</li>
<li>不能是虚函数（虚函数只能是非静态成员函数）</li>
<li>内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数</li>
<li>非静态成员函数内部可以访问静态成员变量\函数</li>
<li>构造函数、析构函数不能是静态</li>
<li>当声明和实现分离时，实现部分不能带static</li>
</ul>
</li>
</ul>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>在C++中，可以利用static关键字在全局只有一份的特性，来写代理</p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rocket</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Rocket *ms_rocket;</span><br><span class="line">    Rocket() &#123;&#125;</span><br><span class="line">    Rocket(<span class="keyword">const</span> Rocket &amp;rocket) &#123;&#125;</span><br><span class="line">    ~Rocket() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Rocket &amp;rocket) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Rocket *sharedRocket() &#123;</span><br><span class="line">        <span class="comment">// 这里要考虑多线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (ms_rocket == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ms_rocket = <span class="keyword">new</span> Rocket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ms_rocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里要考虑多线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (ms_rocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ms_rocket;</span><br><span class="line">            ms_rocket = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><ul>
<li>const成员：被const修饰的成员变量、非静态成员函数</li>
<li>const成员变量<ul>
<li>必须初始化（类内部初始化），可以在声明的时候直接初始化赋值</li>
<li>非static的const成员变量还可以在初始化列表中初始化</li>
</ul>
</li>
<li>const成员函数（非静态）<ul>
<li>const关键字写在参数列表后面，函数的声明和实现都必须带const</li>
<li>内部不能修改非static成员变量</li>
<li>内部只能调用const成员函数、static成员函数</li>
<li>非const成员函数可以调用const成员函数</li>
<li>const成员函数和非const成员函数构成重载</li>
<li>非const对象（指针）优先调用非const成员函数</li>
<li>const对象（指针）只能调用const成员函数、static成员函数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之虚函数、虚表</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E8%A1%A8.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之虚函数、虚表.html/">个人博客</a></p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>C++中的多态通过虚函数（virtual function）来实现<ul>
<li>虚函数：被virtual修饰的成员函数</li>
<li>只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（也就是说子类中可以省略virtual关键字）</li>
</ul>
</li>
</ul>
<h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt; <span class="string">"Student::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们用<code>Person</code>指针指向<code>Student</code>对象，然后真正输出的是<code>Person::run()</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person *stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu-&gt;<span class="built_in">run</span>(); <span class="comment">//输出 Person::run()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 </p>
<blockquote>
<p>Person::run()</p>
</blockquote>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>那是因为对于编译器来说，编译代码的时候，发现<code>stu</code>指针是Person类型，那么调用的时候，直接调用了<code>Person::run()</code>。有没有办法调用<code>Student::run()</code>呢？答案是有的，就是用<code>virtual</code>修饰</li>
<li>用<code>virtual</code>修饰的函数，是虚函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改成如上代码之后，输出结果为</p>
<blockquote>
<p>Student::run()</p>
</blockquote>
<h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2><ul>
<li>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表</li>
</ul>
<p>对于上面的例子中，<code>Student</code>对象的前4个字节存放的是指向虚表的地址<br>当我们调用的时候，</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">Person *stu = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">stu-&gt;<span class="keyword">run</span>();</span><br></pre></td></tr></table></figure>

<p>会首先把虚表地址取出来，然后去虚表中调用<code>Student::run()</code></p>
<p><strong>所有的Student对象（不管在全局区、栈、堆）共用同一份虚表</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x1000010e5</span> &lt;+<span class="number">53</span>&gt;: movq   <span class="number">-0x18</span>(%rbp), %rax</span><br><span class="line"><span class="number">0x1000010e9</span> &lt;+<span class="number">57</span>&gt;: movq   %rax, <span class="number">-0x10</span>(%rbp)</span><br><span class="line"><span class="number">0x1000010ed</span> &lt;+<span class="number">61</span>&gt;: movq   <span class="number">-0x10</span>(%rbp), %rax</span><br><span class="line"><span class="number">0x1000010f1</span> &lt;+<span class="number">65</span>&gt;: movq   (%rax), %rdx</span><br><span class="line"><span class="number">0x1000010f4</span> &lt;+<span class="number">68</span>&gt;: movq   %rax, %rdi</span><br><span class="line"><span class="number">0x1000010f7</span> &lt;+<span class="number">71</span>&gt;: callq  *(%rdx) <span class="comment">//rdx里面存放虚表地址</span></span><br></pre></td></tr></table></figure>

<p> 跟踪汇编代码调用如下的<code>Student::run:</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"> C++test01`Student::<span class="built_in">run</span>:</span><br><span class="line">-&gt;  <span class="number">0x100001190</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001191</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001194</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001198</span> &lt;+<span class="number">8</span>&gt;:  movq   <span class="number">0xe61</span>(%rip), %rax         ; (<span class="keyword">void</span> *)<span class="number">0x00007fff97678760</span>: <span class="built_in">std</span>::__1::<span class="built_in">cout</span></span><br><span class="line">    <span class="number">0x10000119f</span> &lt;+<span class="number">15</span>&gt;: movq   %rdi, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x1000011a3</span> &lt;+<span class="number">19</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x1000011a6</span> &lt;+<span class="number">22</span>&gt;: leaq   <span class="number">0xda6</span>(%rip), %rsi         ; <span class="string">"Student::run()"</span></span><br><span class="line">    <span class="number">0x1000011ad</span> &lt;+<span class="number">29</span>&gt;: callq  <span class="number">0x100001de2</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;&amp; <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;(<span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*)</span><br></pre></td></tr></table></figure>


<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul>
<li>纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范</li>
<li>抽象类（Abstract Class） <ul>
<li>含有纯虚函数的类，不可以实例化（不可以创建对象）</li>
<li>抽象类也可以包含非纯虚函数、成员变量</li>
<li>如果父类是抽象类，子类没有完全重写纯虚函数，那么这个子类依然是抽象类</li>
</ul>
</li>
</ul>
<p>例如下面的<code>Person</code>类就是一个含有纯虚函数的类，可以用来定义接口规范</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line">    virtual <span class="built_in">void</span> run()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</li>
<li>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。</li>
<li>所以类纯虚函数的声明就是在告诉子类的设计者，”你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之继承</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%BB%A7%E6%89%BF.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之继承.html/">个人博客</a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>继承，可以让子类拥有父类的所有成员（变量\函数）</li>
</ul>
<h3 id="默认私有继承"><a href="#默认私有继承" class="headerlink" title="默认私有继承"></a>默认私有继承</h3><p>例如下面的代码中，类Cat继承类Animal</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Animal::eat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">"Cat::run()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如下调用的时候，发现设置父类的成员变量，访问父类的函数，会报错。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">Cat</span> <span class="keyword">cat</span>;</span><br><span class="line">    <span class="keyword">cat</span>.age =3; <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">cat</span>.height = 4;</span><br><span class="line">    <span class="keyword">cat</span>.<span class="keyword">run</span>();</span><br><span class="line">    <span class="keyword">cat</span>.eat(); <span class="comment">//编译报错</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改为public继承"><a href="#修改为public继承" class="headerlink" title="修改为public继承"></a>修改为<code>public</code>继承</h3><p>那是因为C++中默认是私有继承。如果子类想访问父类的函数等，需要public继承，改成如下就可以了。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">"Cat::run()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>c++中没有类似Java中的java.lang.Object 或者ObjectC中的NSObject的基类</strong></p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul>
<li>父类的成员变量在前，子类的成员变量在后</li>
</ul>
<p>上面的代码反汇编</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100001160</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001161</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001164</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001168</span> &lt;+<span class="number">8</span>&gt;:  movl   $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000116f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x3</span>, <span class="number">-0x10</span>(%rbp) <span class="comment">//cat.age =3</span></span><br><span class="line">    <span class="number">0x100001176</span> &lt;+<span class="number">22</span>&gt;: movl   $<span class="number">0x4</span>, <span class="number">-0xc</span>(%rbp)<span class="comment">//cat.height =4</span></span><br><span class="line">-&gt;  <span class="number">0x10000117d</span> &lt;+<span class="number">29</span>&gt;: leaq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x100001181</span> &lt;+<span class="number">33</span>&gt;: callq  <span class="number">0x1000011a0</span>               ; Cat::run at Main.cpp:<span class="number">42</span></span><br><span class="line">    <span class="number">0x100001186</span> &lt;+<span class="number">38</span>&gt;: leaq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x10000118a</span> &lt;+<span class="number">42</span>&gt;: callq  <span class="number">0x1000011e0</span>               ; Animal::eat at Main.cpp:<span class="number">33</span></span><br><span class="line">    <span class="number">0x10000118f</span> &lt;+<span class="number">47</span>&gt;: xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100001191</span> &lt;+<span class="number">49</span>&gt;: addq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001195</span> &lt;+<span class="number">53</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001196</span> &lt;+<span class="number">54</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p>从上面的汇编可以看到<code>age</code>在<code>height</code>的地址前面，而且是连续的内存。</p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ul>
<li>C++允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）</li>
</ul>
<p>如下所示：<code>GoodStudent</code>同时继承<code>Person</code>和<code>Student</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::play()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodStudent</span>:</span><span class="keyword">public</span> Person,<span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"GoodStudent::study()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GoodStudent stu;</span><br><span class="line">    stu.age = <span class="number">1</span>;</span><br><span class="line">    stu.<span class="built_in">height</span> = <span class="number">2</span>;</span><br><span class="line">    stu.score = <span class="number">3</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应汇编如下，可知是把父类的成员变量放在了子类中，并且内存是连续的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">0x100000f90</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f91</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f94</span> &lt;+<span class="number">4</span>&gt;:  xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100000f96</span> &lt;+<span class="number">6</span>&gt;:  movl   $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f9d</span> &lt;+<span class="number">13</span>&gt;: movl   $<span class="number">0x1</span>, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000fa4</span> &lt;+<span class="number">20</span>&gt;: movl   $<span class="number">0x2</span>, <span class="number">-0xc</span>(%rbp)</span><br><span class="line">-&gt;  <span class="number">0x100000fab</span> &lt;+<span class="number">27</span>&gt;: movl   $<span class="number">0x3</span>, <span class="number">-0x8</span>(%rbp)</span><br></pre></td></tr></table></figure>

<h2 id="多个父类同样的函数"><a href="#多个父类同样的函数" class="headerlink" title="多个父类同样的函数"></a>多个父类同样的函数</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::play()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子类调用的时候需要区分命名空间</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">stu.Person::<span class="built_in">run</span>(); <span class="comment">//调用Person的run()</span></span><br><span class="line">stu.Student::<span class="built_in">run</span>();<span class="comment">//调用Student的run()</span></span><br></pre></td></tr></table></figure>

<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><ul>
<li><p>如果存在类A，同时类B和类C都继承A，有类D继承B和C。则称为菱形继承</p>
</li>
<li><p>一般在开发中，不会使用菱形继承。</p>
<ul>
<li>最底下子类从基类继承的成员变量冗余、重复</li>
<li>最底下子类无法访问基类的成员，有二义性</li>
</ul>
</li>
</ul>
<p>例如如下的代码中，就是菱形继承的例子</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student:<span class="symbol">public</span></span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Work:<span class="symbol">public</span></span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">GoodStudent:<span class="symbol">public</span></span> <span class="symbol">Student,<span class="symbol">public</span></span> <span class="symbol">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在X86架构下，一个GoodStudent对象占用内存20字节，是因为，Student和Work都从Person继承了age，那么GoodStudent中就有2个age了。同时加上score,height, salary就是5个成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GoodStudent stu;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(stu) &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出20</span></span><br></pre></td></tr></table></figure>

<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>为了解决菱形继承的问题，我们可以使用虚继承。</p>
<p>如下代码 Person类被称为虚基类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student:<span class="symbol">virtual</span></span> <span class="symbol">public</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Work:<span class="symbol">virtual</span></span> <span class="symbol">public</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">GoodStudent:<span class="symbol">public</span></span> <span class="symbol">Student,<span class="symbol">public</span></span> <span class="symbol">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样一个GoodStudent对象里面只有一个age成员变量。当然这样做增加了虚函数表。这里不做展开。</p>
<h2 id="成员访问权限"><a href="#成员访问权限" class="headerlink" title="成员访问权限"></a>成员访问权限</h2><ul>
<li>成员访问权限、继承方式有3种 <ul>
<li>public：公共的，任何地方都可以访问（struct默认）</li>
<li>protected：子类内部、当前类内部可以访问</li>
<li>private：私有的，只有当前类内部可以访问（class默认）<ul>
<li>子类内部访问父类成员的权限，是以下2项中权限最小的那个</li>
</ul>
</li>
<li>成员本身的访问权限</li>
<li>上一级父类的继承方式<ul>
<li>开发中用的最多的继承方式是public，这样能保留父类原来的成员访问权限</li>
<li>访问权限不影响对象的内存布局</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><ul>
<li>一种便捷的初始化成员变量的方式</li>
<li>只能用在构造函数中</li>
<li>初始化顺序只跟成员变量的声明顺序有关</li>
</ul>
<p>下面两种写法是等价的</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">        this-&gt;m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>)</span>: m<span class="constructor">_age(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="初始化列表与默认参数配合使用"><a href="#初始化列表与默认参数配合使用" class="headerlink" title="初始化列表与默认参数配合使用"></a>初始化列表与默认参数配合使用</h2><p>例如下面的代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="built_in">int</span> m_height;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span> = 0, <span class="params">int</span> <span class="params">height</span> =0)</span>:m<span class="constructor">_age(<span class="params">age</span>)</span>,m<span class="constructor">_height(<span class="params">height</span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用的时候如下三种都可以</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">Person person2(<span class="number">18</span>);</span><br><span class="line">Person person3(<span class="number">18</span>,<span class="number">188</span>);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之封装、构造函数、析构函数</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之封装、构造函数、析构函数.html/">个人博客</a></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>成员变量私有化，提供公共的getter和setter给外界去访问成员变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.setAge(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><ul>
<li><p>在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存</p>
</li>
<li><p>堆空间的申请\释放</p>
<ul>
<li><code>malloc</code> \ <code>free</code></li>
<li><code>new</code> \ <code>delete</code></li>
<li><code>new</code> [] \ <code>delete []</code></li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>申请堆空间成功后，会返回那一段内存空间的地址</li>
<li>申请和释放必须是1对1的关系，不然可能会存在内存泄露</li>
</ul>
</li>
<li><p>现在的很多高级编程语言不需要开发人员去管理内存（比如Java），屏蔽了很多内存细节，利弊同时存在</p>
<ul>
<li>利：提高开发效率，避免内存使用不当或泄露</li>
<li>弊：不利于开发人员了解本质，永远停留在API调用和表层语法糖，对性能优化无从下手</li>
</ul>
</li>
</ul>
<p>例如开盘int类型的空间，使用完之后销毁</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> *p = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>));</span><br><span class="line">   *p = <span class="number">10</span>;</span><br><span class="line">   free(p);</span><br><span class="line">  </span><br><span class="line">   <span class="built_in">int</span> *p2 = new <span class="built_in">int</span>;</span><br><span class="line">   *p2 = <span class="number">20</span>;</span><br><span class="line">   delete p2;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> *p3 = new <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">   *p = <span class="number">10</span>;</span><br><span class="line">   *(p+<span class="number">1</span>) = <span class="number">20</span>;</span><br><span class="line">   *(p+<span class="number">2</span>) = <span class="number">30</span>;</span><br><span class="line">   delete [] (p3);</span><br></pre></td></tr></table></figure>

<h2 id="堆空间的初始化"><a href="#堆空间的初始化" class="headerlink" title="堆空间的初始化"></a>堆空间的初始化</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a><code>memset</code></h3><p><code>memset</code>函数是将较大的数据结构（比如对象、数组等）内存清零的比较快的方法</p>
<p>如下所示</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">Person</span> <span class="keyword">person</span>;</span><br><span class="line"> <span class="keyword">person</span>.age = 10;</span><br><span class="line"> <span class="keyword">person</span>.height = 199;</span><br><span class="line"> //从<span class="keyword">person</span>的地址开始,每个字节都赋值为0</span><br><span class="line">memset(&amp;<span class="keyword">person</span>, 0, sizeof(<span class="keyword">person</span>));</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//*p1 未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//将 *p2 的每一个字节都初始化为0</span></span><br></pre></td></tr></table></figure>

<p>如下几种方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;           <span class="comment">//未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();         <span class="comment">//被初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);        <span class="comment">//被初始化为5</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];        <span class="comment">//数组元素未被初始化</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]();      <span class="comment">//3个数组元素都被初始化0</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;&#125;;      <span class="comment">//3个数组元素都被初始化0</span></span><br><span class="line"><span class="keyword">int</span> *p7 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">5</span>&#125;;     <span class="comment">//数组首元素被初始化为5,其他元素被初始化为0</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h2><ul>
<li>构造函数（也叫构造器），在对象创建的时候自动调用，一般用于完成对象的初始化工作</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>函数名与类同名，无返回值（void都不能写），可以有参数，可以重载，可以有多个构造函数</li>
<li>一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>通过malloc分配的对象不会调用构造函数</li>
<li>一个广为流传的、很多教程\书籍都推崇的错误结论： <ul>
<li>默认情况下，编译器会为每一个类生成空的无参的构造函数</li>
<li>正确理解：在某些特定的情况下，编译器才会为类生成空的无参的构造函数</li>
</ul>
</li>
</ul>
<p>比如我们自己写2个构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person(int age))"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在不同的空间调用的时候，如下区别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局区</span></span><br><span class="line">Person p1;      <span class="comment">//调用Person()</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">()</span></span>;    <span class="comment">//这是一个函数，函数名是p2,返回值类型是Person，无参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">18</span>)</span></span>;  <span class="comment">//调用 Person(int)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//栈空间</span></span><br><span class="line">    Person p4;      <span class="comment">//调用Person()</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">()</span></span>;    <span class="comment">//这是一个函数，函数名是p5,返回值类型是Person，无参</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(<span class="number">18</span>)</span></span>;  <span class="comment">//调用 Person(int)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//堆空间</span></span><br><span class="line">    Person *p7  = <span class="keyword">new</span> Person;      <span class="comment">//调用Person()</span></span><br><span class="line">    Person *p8  = <span class="keyword">new</span> Person();    <span class="comment">//调用Person()</span></span><br><span class="line">    Person *p9  = <span class="keyword">new</span> Person(<span class="number">20</span>);  <span class="comment">//调用 Person(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数的互相调用"><a href="#构造函数的互相调用" class="headerlink" title="构造函数的互相调用"></a>构造函数的互相调用</h2><p>下面代码中有2个构造函数，<code>Person()</code>是可以调用<code>Person(int age, int height):m_age(age),m_height(height)</code>的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="built_in">int</span> m_height;</span><br><span class="line">    <span class="constructor">Person()</span>:<span class="constructor">Person(10,20)</span>&#123;&#125;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>, <span class="params">int</span> <span class="params">height</span>)</span>:m<span class="constructor">_age(<span class="params">age</span>)</span>,m<span class="constructor">_height(<span class="params">height</span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h2><ul>
<li>子类的构造函数默认会调用父类的无参构造函数</li>
<li>如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</li>
<li>如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数</li>
</ul>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul>
<li>析构函数（也叫析构器），在对象销毁的时候自动调用，一般用于完成对象的清理工作</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>函数名以~开头，与类同名，无返回值（void都不能写），无参，不可以重载，有且只有一个析构函数</li>
</ul>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul>
<li>通过malloc分配的对象free的时候不会调用析构函数</li>
<li>构造函数、析构函数要声明为public，才能被外界正常使用</li>
</ul>
<h3 id="例如下面的代码"><a href="#例如下面的代码" class="headerlink" title="例如下面的代码"></a>例如下面的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Cat()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Cat()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Cat()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Cat *cat;</span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Person person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">()</span></span></span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure>

<p>当person销毁的时候，其持有的cat并没有销毁。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>当person销毁的时候，其指向cat对象的指针销毁了，但是堆空间的cat对象依然存在，就会有内存泄露。所以需要在析构函数里面来释放掉。类似的析构函数在许多其他语言底层也是应用广泛，例如Objective-C的源码中，大量使用析构函数。</li>
</ul>
<p>代码改成如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~Person()&#123;</span><br><span class="line">       <span class="keyword">delete</span> cat;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">()</span></span></span><br><span class="line">~Cat()</span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure>

<p>可知，cat对象才真正销毁。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之类(class,struct)</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB(class,struct).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之类(class,struct).html/">个人博客</a></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p> C++中可以使用struct、class来定义一个类</p>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><ul>
<li>struct的默认成员权限是public</li>
<li>class的默认成员权限是private</li>
<li>实际开发中，用class表示类比较多</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="操作类"><a href="#操作类" class="headerlink" title="操作类"></a>操作类</h3><ul>
<li>对类进行操作。我们有两种方式</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> <span class="keyword">person</span>;</span><br><span class="line">//使用对象的点语法</span><br><span class="line"><span class="keyword">person</span>.age = 10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *p = &amp;<span class="keyword">person</span>;</span><br><span class="line">//操作指针访问</span><br><span class="line">p-&gt;age = 20;</span><br></pre></td></tr></table></figure>

<h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.age = <span class="number">10</span>; <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反汇编结果如下</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"> pushq  <span class="symbol">%rbp</span></span><br><span class="line"> movq   <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line"> xorl   <span class="symbol">%eax</span>, <span class="symbol">%eax</span></span><br><span class="line">-&gt;   movl   $<span class="number">0xa</span>, <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>) <span class="comment">; person.age = 10</span></span><br><span class="line"><span class="comment"> popq   %rbp</span></span><br><span class="line"><span class="comment"> retq</span></span><br></pre></td></tr></table></figure>

<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.age = <span class="number">10</span>; <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反汇编结果如下</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"> pushq  <span class="symbol">%rbp</span></span><br><span class="line"> movq   <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line"> xorl   <span class="symbol">%eax</span>, <span class="symbol">%eax</span></span><br><span class="line">-&gt;   movl   $<span class="number">0xa</span>, <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>) <span class="comment">; person.age = 10</span></span><br><span class="line"><span class="comment"> popq   %rbp</span></span><br><span class="line"><span class="comment"> retq</span></span><br></pre></td></tr></table></figure>

<p>可以看到无论是<code>struct</code>还是<code>class</code>。汇编代码完全一样</p>
<ul>
<li>实际开发中，用class表示类比较多</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this是指向当前对象的指针"><a href="#this是指向当前对象的指针" class="headerlink" title="this是指向当前对象的指针"></a>this是指向当前对象的指针</h3><ul>
<li>对象在调用成员函数的时候，会自动传入当前对象的内存地址</li>
</ul>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age is "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：不能用this.age来访问成员变量。因为this是指针。</strong></p>
<h3 id="指针访问对象成员的本质"><a href="#指针访问对象成员的本质" class="headerlink" title="指针访问对象成员的本质"></a>指针访问对象成员的本质</h3><p>下面代码最后打印出来的每个成员变量值是多少？</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" id = "</span> &lt;&lt; id &lt;&lt; <span class="string">" age = "</span> &lt;&lt; age &lt;&lt; <span class="string">" height = "</span> &lt;&lt; <span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person person;</span><br><span class="line">    person.id = <span class="number">10</span>;</span><br><span class="line">    person.age = <span class="number">20</span>;</span><br><span class="line">    person.<span class="built_in">height</span> = <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Person *p = (Person *)&amp;person.age;</span><br><span class="line">    <span class="comment">//操作指针访问</span></span><br><span class="line">    p-&gt;id = <span class="number">40</span>;</span><br><span class="line">    p-&gt;age= <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    person.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一感觉是</p>
<blockquote>
<p>id = 40 age = 50 height = 30</p>
</blockquote>
<p>然后用编译器运行起来的结果是</p>
<blockquote>
<p>id = 10 age = 40 height = 50</p>
</blockquote>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>因为指针<code>p</code>实际指向的是<code>person.age</code>的地址，但是<code>(Person *)&amp;person.age;</code> 欺骗编译器是指向person。</li>
<li>64位下<code>person</code>中每个成员变量都是Int类型，占用4个字节。</li>
<li>当我们修改<code>p-&gt;id = 40;</code>的时候，实际上修改的是<code>age</code>指向的内存空间。</li>
</ul>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>打印的时候不用点语法，使用指针呢？如下</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>display();</span><br></pre></td></tr></table></figure>

<p>其结果为：其中height 的值是不确定的</p>
<blockquote>
<p>id = 40 age = 50 height = 1 </p>
</blockquote>
<ul>
<li>是因为，使用指针访问的时候，传入的this就是偏移了4个字节的内存空间，打印的id实际上是age,打印的age实际上是height,打印的height实际上是其他空间的数据。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之引用</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%BC%95%E7%94%A8.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之引用.html/">个人博客</a></p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><ul>
<li>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>引用相当于是变量的别名（基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用）</li>
<li>对引用做计算，就是对引用所指向的变量做计算</li>
<li>在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”</li>
<li>可以利用引用初始化另一个引用，相当于某个变量的多个别名</li>
<li>不存在【引用的引用、指向引用的指针、引用数组】</li>
</ul>
<p>例如</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">	 <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line"> 	 <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = age;</span><br><span class="line">	 <span class="built_in">ref</span> = <span class="number">20</span>;</span><br><span class="line">	 cout &lt;&lt; age &lt;&lt; endl; <span class="comment">//打印结果为 20</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中修改ref也就相当于修改了age。</p>
<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><ul>
<li>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针<ul>
<li>一个引用占用一个指针的大小</li>
</ul>
</li>
</ul>
<h3 id="间接证明"><a href="#间接证明" class="headerlink" title="间接证明"></a>间接证明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person size is "</span> &lt;&lt; <span class="keyword">sizeof</span>(person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在X86位架构下，上面的代码输入为 <code>person size is 4</code><br>如果代码改成如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> &amp;ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person size is "</span> &lt;&lt; <span class="keyword">sizeof</span>(person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在X86架构下，上面的代码输入为 <code>person size is 8</code><br>而我们知道在X86架构下，指针类型占用字节为8。int 类型为占用4个字节。所以引用和指针占用字节数一样。</p>
<h3 id="汇编证明"><a href="#汇编证明" class="headerlink" title="汇编证明"></a>汇编证明</h3><ul>
<li>如下使用指针的代码</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">   <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">int</span> *p = &amp;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>汇编代码如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">_main:</span></span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0x3</span></span><br><span class="line"><span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"><span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把指针改成引用的代码</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">   <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol"> _main:</span></span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0x3</span></span><br><span class="line"><span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"><span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>可发现，引用和指针的汇编代码完全一致。就说明最终转成机器码也是一样的。所以引用的本质就是指针。</p>
<h2 id="常引用（Const-Reference）"><a href="#常引用（Const-Reference）" class="headerlink" title="常引用（Const Reference）"></a>常引用（Const Reference）</h2><ul>
<li>引用可以被const修饰，这样就无法通过引用修改数据了，可以称为常引用</li>
<li>const必须写在&amp;符号的左边，才能算是常引用</li>
</ul>
<h3 id="const引用的特点"><a href="#const引用的特点" class="headerlink" title="const引用的特点"></a>const引用的特点</h3><ul>
<li>可以指向临时数据（常量、表达式、函数返回值等）</li>
<li>可以指向不同类型的数据</li>
<li>作为函数参数时（此规则也适用于const指针） <ul>
<li>可以接受const和非const实参（非const引用，只能接受非const实参）</li>
<li>可以跟非const引用构成重载</li>
</ul>
</li>
</ul>
<p><strong>当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量</strong></p>
<h3 id="常引用指向相同类型的数据"><a href="#常引用指向相同类型的数据" class="headerlink" title="常引用指向相同类型的数据"></a>常引用指向相同类型的数据</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ref is "</span> &lt;&lt; <span class="built_in">ref</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>上面代码输出为12。其对应的汇编如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"> <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"> //<span class="number">10</span>赋值给[<span class="built_in">rbp</span>+var_8] 这个内存空间 也就是 变量a的地址</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">// a的地址赋值给引用ref</span><br><span class="line"> <span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span>//</span><br><span class="line"></span><br><span class="line">//把a的值改为<span class="number">12</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xc</span></span><br><span class="line"> <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h3 id="常引用指向不同类型的数据"><a href="#常引用指向不同类型的数据" class="headerlink" title="常引用指向不同类型的数据"></a>常引用指向不同类型的数据</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> long &amp;<span class="built_in">ref</span> = a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ref is "</span> &lt;&lt; <span class="built_in">ref</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>上面代码输出为10。其对应的汇编如下，改变了a的值，并不能改变ref的值</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">             _main:</span></span><br><span class="line"> <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"> <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">//<span class="number">10</span>赋值给[<span class="built_in">rbp</span>+var_8] 这个内存空间 也就是 变量a的地址</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">//增加一个中间变量地址为[<span class="built_in">rbp</span>+var_18] 作为引用ref的地址</span><br><span class="line"> <span class="keyword">movsxd</span>     <span class="built_in">rcx</span>, <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_18], <span class="built_in">rcx</span></span><br><span class="line"> <span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_18]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"></span><br><span class="line">//把a的值改为<span class="number">12</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xc</span></span><br><span class="line"> <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之内联函数</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之内联函数.html/">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p>
</blockquote>
<blockquote>
<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>使用inline修饰函数的声明或者实现，可以使其变成内联函数</li>
<li>建议声明和实现都增加inline修饰</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码经过内敛之后就相当于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>编译器会将函数调用直接展开为函数体代码</li>
<li>可以减少函数调用的开销</li>
<li>会增大代码体积</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>尽量不要内联超过10行代码的函数</li>
<li>有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数</li>
</ul>
<p>例如下面的代码就算加了inline 也不会被编译器内敛的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    test3(a--);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test3(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="inline只是建议"><a href="#inline只是建议" class="headerlink" title="inline只是建议"></a><code>inline</code>只是建议</h2><p>inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
<h2 id="慎用-inline"><a href="#慎用-inline" class="headerlink" title="慎用 inline"></a>慎用 inline</h2><ul>
<li>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？ </li>
<li>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 </li>
<li>如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
</ul>
<p>以下情况不宜使用内联： </p>
<ul>
<li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 </li>
<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如”偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</li>
</ul>
<h2 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h2><ul>
<li>内联函数和宏，都可以减少函数调用的开销</li>
<li>对比宏，内联函数多了语法检测和函数特性</li>
<li>宏使用不当，会导致和我们想法不一致的情况</li>
</ul>
<p>例如下面的代码,如果是宏定义，就相当于b = (a++ + a++);结果和预期不符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) (x + x)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">	<span class="keyword">int</span> b = sum(a++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。 </li>
<li>最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强性能，就避免使用它！</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之C和C++混编</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8BC%E5%92%8CC++%E6%B7%B7%E7%BC%96.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之C和C++混编.html/">个人博客</a></p>
<h2 id="extern-quot-C-quot"><a href="#extern-quot-C-quot" class="headerlink" title="extern &quot;C&quot;"></a><code>extern &quot;C&quot;</code></h2><blockquote>
<p><code>extern &quot;C&quot;</code>的主要作用就是为了能够正确实现<code>C++</code>代码调用其他C语言代码。加上<code>extern &quot;C&quot;</code>后，会指示编译器这部分代码按<code>C</code>语言（而不是<code>C++</code>）的方式进行编译。由于<code>C++</code>支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>
</blockquote>
<blockquote>
<p>这个功能十分有用处，因为在<code>C++</code>出现以前，很多代码都是<code>C</code>语言写的，而且很底层的库也是<code>C</code>语言写的，为了更好的支持原来的<code>C</code>代码和已经写好的<code>C</code>语言库，需要在<code>C++</code>中尽可能的支持<code>C</code>，而<code>extern &quot;C&quot;</code>就是其中的一个策略。</p>
</blockquote>
<h3 id="extern-quot-C-quot-可以修饰单个函数，也可以修饰多个函数。"><a href="#extern-quot-C-quot-可以修饰单个函数，也可以修饰多个函数。" class="headerlink" title="extern &quot;C&quot; 可以修饰单个函数，也可以修饰多个函数。"></a><code>extern &quot;C&quot;</code> 可以修饰单个函数，也可以修饰多个函数。</h3><p>例如下面的三个函数都会用 C语音的方式编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明必须修饰，实现可修饰可不修饰"><a href="#声明必须修饰，实现可修饰可不修饰" class="headerlink" title="声明必须修饰，实现可修饰可不修饰"></a>声明必须修饰，实现可修饰可不修饰</h3><ul>
<li><p>如果函数同时有声明和实现，要让函数声明被extern “C”修饰，函数实现可以不修饰</p>
</li>
<li><p>函数的声明都被extern “C”修饰是可以编译通过的</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以编译通过</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的声明被extern “C”修饰，实现没有被extern “C”修饰，是可以编译通过的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以编译通过</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>函数的声明没有被extern “C”修饰，实现被extern “C”修饰，不能编译通过</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不能编译通过</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cplusplus"><a href="#cplusplus" class="headerlink" title="__cplusplus"></a><code>__cplusplus</code></h2><p>有时候我们的函数，不仅要在C语言中调用，还要再C++中调用。怎么做呢？</p>
<p>如果我们加了<code>extern &quot;C&quot;</code> 那么只能是C语言的环境编译，C++环境编译就会有问题了。</p>
<p>如果我们不加<code>extern &quot;C&quot;</code> 那么只能是C++语言的环境编译，C环境编译就会有问题了。</p>
<p>如果能够判断是C语言环境还是C++环境，这样在C++语言的环境下按照C++编译方式，在C语言的环境下按照C编译方式，岂不是都可以了。</p>
<p> <code>__cplusplus</code>就可以达成这样的效果。</p>
<p> 例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这样就能做到C++语言的环境下按照C++编译方式，在C语言的环境下按照C编译方式。</p>
<h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a><code>ifndef</code></h2><p>我们知道，当引用其他文件的时候，我们要用到 <code>#include</code> 例如</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br></pre></td></tr></table></figure>

<p>如果我们不小心写了很多次</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br></pre></td></tr></table></figure>

<p>那就相当于把引用的文件的内容拷贝过来很多次，编译器编译的时候，要执行多次，浪费性能。这时候我们只需要在被引用文件里面加上如下代码即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_IOSTREAM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIBCPP_IOSTREAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。很多代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这样就算引用多次，也没关系。因为第二次引用的时候，判断引用过了，直接跳过。其中<code>_LIBCPP_IOSTREAM</code>这个为了避免重复，一般采用和文件同名的大写字母来命名。</p>
<h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><ul>
<li>我们经常使用#ifndef、#define、#endif来防止头文件的内容被重复包含</li>
<li>#pragma once可以防止整个文件的内容被重复包含</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>受<code>C\C++</code>标准的支持，不受编译器的任何限制</li>
<li>有些编译器不支持<code>#pragma once</code>（较老编译器不支持，如<code>GCC 3.4</code>版本之前），兼容性不够好</li>
<li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>可以针对一个文件中的部分代码，而<code>#pragma once</code>只能针对整个文件</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之函数重载和默认参数</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之函数重载.html/">个人博客</a></p>
<h2 id="函数重载（Overload）"><a href="#函数重载（Overload）" class="headerlink" title="函数重载（Overload）"></a>函数重载（Overload）</h2><p><strong>C语言中没有函数重载</strong></p>
<p><strong>C++语言中有函数重载</strong></p>
<h3 id="函数名相同，参数个数不同、参数类型不同、参数顺序不同"><a href="#函数名相同，参数个数不同、参数类型不同、参数顺序不同" class="headerlink" title="函数名相同，参数个数不同、参数类型不同、参数顺序不同"></a>函数名相同，参数个数不同、参数类型不同、参数顺序不同</h3><p>例如下面就是函数重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="返回值类型与函数重载无关"><a href="#返回值类型与函数重载无关" class="headerlink" title="返回值类型与函数重载无关"></a>返回值类型与函数重载无关</h3><p>返回值类型与函数重载无关，下面代码不构成重载，编译会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值类型与函数重载无关</span></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实参的隐式类型转换可能会产生二义性"><a href="#实参的隐式类型转换可能会产生二义性" class="headerlink" title="实参的隐式类型转换可能会产生二义性"></a>实参的隐式类型转换可能会产生二义性</h3><p><strong>不同编译器有不同处理</strong></p>
<p>下面代码在vs上编译不过，但是在Xcode中可以编译通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="函数重载的本质"><a href="#函数重载的本质" class="headerlink" title="函数重载的本质"></a>函数重载的本质</h2><ul>
<li>采用了name mangling或者叫name decoration技术<ul>
<li>C++编译器默认会对符号名（比如函数名）进行改编、修饰，有些地方翻译为“命名倾轧”</li>
<li>重载时会生成多个不同的函数名，不同编译器（MSVC、g++）有不同的生成规则</li>
<li>通过IDA打开【VS_Release_禁止优化】可以看到 或者通过hopper查看</li>
</ul>
</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，<code>void sum(double a){}</code> 和 <code>void sum(int a){}</code> 是如何重载，调用函数的时候是如何能正确找到对应的函数呢？</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>我是用xcode的编译出可执行文件，放在hopper中查看</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">		   __Z3sumd:</span>        // sum(double)</span><br><span class="line">0000000100000ce0         <span class="keyword">push</span>       <span class="built_in">rbp</span>         <span class="comment">; CODE XREF=_main+23</span></span><br><span class="line">0000000100000ce1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000ce4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000ce8         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">qword</span> [__ZNSt3__14coutE_100001000]</span><br><span class="line">0000000100000cef         <span class="keyword">movsd</span>      <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8], <span class="built_in">xmm0</span></span><br><span class="line">0000000100000cf4         <span class="keyword">movsd</span>      <span class="built_in">xmm0</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line">0000000100000cf9         <span class="keyword">call</span>       imp___stubs___ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEd <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(double)</span></span><br><span class="line">0000000100000cfe         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span></span><br><span class="line">0000000100000d01         <span class="keyword">lea</span>        <span class="built_in">rsi</span>, <span class="built_in">qword</span> [__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_]</span><br><span class="line">0000000100000d08         <span class="keyword">call</span>       __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; (*)(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;))</span></span><br><span class="line">0000000100000d0d         <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rax</span></span><br><span class="line">0000000100000d11         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000d15         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000d16         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000d17         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br></pre></td></tr></table></figure>

<p>可知 <code>void sum(double a){}</code> 被编译器修改为函数<code>__Z3sumd</code></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">                     __Z3sumi:</span>        // sum(<span class="keyword">int</span>)</span><br><span class="line">0000000100000da0         <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line">0000000100000da1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000da4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000da8         <span class="keyword">mov</span>        <span class="built_in">rax</span>, <span class="built_in">qword</span> [__ZNSt3__14coutE_100001000]</span><br><span class="line">0000000100000daf         <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="built_in">edi</span></span><br><span class="line">0000000100000db2         <span class="keyword">mov</span>        <span class="built_in">esi</span>, <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4]</span><br><span class="line">0000000100000db5         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span></span><br><span class="line">0000000100000db8         <span class="keyword">call</span>       imp___stubs___ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)</span></span><br><span class="line">0000000100000dbd         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span>                                    <span class="comment">; argument #1 for method __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E</span></span><br><span class="line">0000000100000dc0         <span class="keyword">lea</span>        <span class="built_in">rsi</span>, <span class="built_in">qword</span> [__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_]</span><br><span class="line">0000000100000dc7         <span class="keyword">call</span>       __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; (*)(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;))</span></span><br><span class="line">0000000100000dcc         <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rax</span></span><br><span class="line">0000000100000dd0         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000dd4         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000dd5         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000dd6         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">cs</span>:<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br></pre></td></tr></table></figure>


<p>可知 <code>void sum(int a){}</code> 被编译器修改为函数<code>__Z3sumi</code></p>
<p>这样当我们调用的时候</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    sum(<span class="number">10.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编如下，可知：因为 10.5是double类型，调用函数的时候是调用 <code>__Z3sumd</code></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">0000000100000de0         <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line">0000000100000de1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000de4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000de8         <span class="keyword">movsd</span>      <span class="built_in">xmm0</span>, <span class="built_in">qword</span> [<span class="number">0x100000f80</span>]</span><br><span class="line">0000000100000df0         <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line">0000000100000df7         <span class="keyword">call</span>       __Z3sumd        <span class="comment">; sum(double)</span></span><br><span class="line">0000000100000dfc         <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">0000000100000dfe         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000e02         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000e03         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000e04         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">cs</span>:<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br><span class="line">0000000100000e0e         <span class="keyword">nop</span></span><br></pre></td></tr></table></figure>

<h3 id="函数重载结论"><a href="#函数重载结论" class="headerlink" title="函数重载结论"></a>函数重载结论</h3><p>由上面的汇编代码可知，当参数类型不同的时候，编译器会生成不同的函数名作为区别，这样就能实现函数重载。</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>C++允许函数设置默认参数，在调用时可以根据情况省略实参。规则如下：</p>
<ul>
<li>默认参数只能按照右到左的顺序</li>
<li>如果函数同时有声明、实现，默认参数只能放在函数声明中</li>
<li>默认参数的值可以是常量、全局符号（全局变量、函数名）</li>
</ul>
<p>用法：如果函数的实参经常是同一个值，可以考虑使用默认参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2函数</span></span><br><span class="line"><span class="comment">// a没有默认值</span></span><br><span class="line"><span class="comment">// b 默认值是 10</span></span><br><span class="line"><span class="comment">// 最后一个参数默认值是个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">void</span> (*func)() = test)</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"a is "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test2(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可能有冲突，二义性"><a href="#可能有冲突，二义性" class="headerlink" title="可能有冲突，二义性"></a>可能有冲突，二义性</h3><ul>
<li>函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）</li>
</ul>
<p>例如下面的代码中， 调用<code>test(3);</code> 会报错，因为不知道要执行哪个函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test(<span class="number">3</span>); <span class="comment">// 这里报错，因为不知道要执行哪个函数</span></span><br><span class="line">    test(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//这一句可以正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果函数的实参经常是同一个值，可以考虑使用默认参数</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语法之输入输出</title>
    <url>/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>C++ 标准库提供了一组丰富的输入/输出功能，本文讨论 C++ 编程中最基本和最常见的 I/O 操作。</p>
</blockquote>
<blockquote>
<p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</p>
</blockquote>
<h2 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I/O 库头文件"></a>I/O 库头文件</h2><table>
<thead>
<tr>
<th align="center">头文件</th>
<th align="center">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;iostream&gt;</code></td>
<td align="center">该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td align="center"><code>&lt;iomanip&gt;</code></td>
<td align="center">该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。</td>
</tr>
<tr>
<td align="center"><code>&lt;fstream&gt;</code></td>
<td align="center">该文件为用户控制的文件处理声明服务。</td>
</tr>
</tbody></table>
<h2 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h2><p>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello eagle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<blockquote>
<p>hello eagle</p>
</blockquote>
<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello eagle "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h2><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"age is "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输入18<br>然后打印</p>
<blockquote>
<p>age is 18</p>
</blockquote>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<blockquote>
<p>cin &gt;&gt; name &gt;&gt; age;</p>
</blockquote>
<p>等价</p>
<blockquote>
<p>cin &gt;&gt; name;</p>
<p>cin &gt;&gt; age;</p>
</blockquote>
<h2 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h2><p>预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是<strong>缓冲</strong>的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p>clog 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] = <span class="string">"Unable to read...."</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">clog</span> &lt;&lt; <span class="string">"Error message : "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<blockquote>
<p>Error message : Unable to read….</p>
</blockquote>
<h2 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h2><p>预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是<strong>非缓冲</strong>的，且每个流插入到 cerr 都会立即输出。</p>
<p>cerr 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] = <span class="string">"Unable to read...."</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error message : "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<blockquote>
<p>Error message : Unable to read….</p>
</blockquote>
<p>在编写和执行程序时，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之下标</title>
    <url>/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift中对枚举、结构体、类使用下标(subscript），就可以像使用数组一样来使用了</p>
<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ul>
<li>使用subscript可以给任意类型（枚举、结构体、类）增加下标功能，有些地方也翻译为：下标脚本</li>
<li>subscript的语法类似于实例方法、计算属性，本质就是方法（函数）</li>
</ul>
<p>例如下面的代码中，类<code>Point</code>中，的属性 x 和 y,可以用下标访问</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="type">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(<span class="keyword">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">                x = newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">1</span> &#123;</span><br><span class="line">                y = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问的时候</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = Point()</span><br><span class="line"><span class="selector-tag">p</span>[<span class="number">0</span>] = <span class="number">11.1</span></span><br><span class="line"><span class="selector-tag">p</span>[<span class="number">1</span>] = <span class="number">22.2</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p.x)</span></span> <span class="comment">// 11.1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p.y)</span></span> <span class="comment">// 22.2</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p[<span class="number">0</span>])</span></span> <span class="comment">// 11.1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p[<span class="number">1</span>])</span></span> <span class="comment">// 22.2</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>subscript中定义的返回值类型决定了<ul>
<li>get方法的返回值类型</li>
<li>set方法中newValue的类型</li>
</ul>
</li>
<li>subscript可以接受多个参数，并且类型任意</li>
</ul>
<h3 id="subscript可以没有set方法"><a href="#subscript可以没有set方法" class="headerlink" title="subscript可以没有set方法"></a>subscript可以没有set方法</h3><p>例如下面的代码中，只提供了get，没有set</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(index: <span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只有get方法，可以省略get</li>
</ul>
<p>上面的代码可以写成</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可以设置参数标签"><a href="#可以设置参数标签" class="headerlink" title="可以设置参数标签"></a>可以设置参数标签</h3><p>例如下面的代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(index i: Int) -&gt; Double &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的时候</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = Point()</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.y</span> = <span class="number">22.2</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p[index: <span class="number">1</span>])</span></span> <span class="comment">// 22.2</span></span><br></pre></td></tr></table></figure>

<h3 id="下标可以是类型方法"><a href="#下标可以是类型方法" class="headerlink" title="下标可以是类型方法"></a>下标可以是类型方法</h3><p>如下</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> subscript(v1: <span class="keyword">Int</span>, v2: <span class="keyword">Int</span>) -&gt; <span class="keyword">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(Sum[<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体、类作为返回值对比"><a href="#结构体、类作为返回值对比" class="headerlink" title="结构体、类作为返回值对比"></a>结构体、类作为返回值对比</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>eg,如下代码,结构体Point，用了下标<code>subscript</code>只有get方法</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">struct <span class="type">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PointManager &#123;</span><br><span class="line">    var <span class="type">point</span> = <span class="type">Point</span>()</span><br><span class="line">    subscript(<span class="keyword">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">point</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候报错</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">var </span><span class="string">pm </span>= <span class="string">PointManager(</span>)</span><br><span class="line"><span class="string">pm[</span>0].x = <span class="string">11 </span>//<span class="string">Cannot </span><span class="string">assign </span><span class="string">to </span><span class="string">property:</span> <span class="string">subscript </span><span class="string">is </span><span class="built_in">get-only</span></span><br><span class="line"><span class="built_in">//</span> 等价于 <span class="string">pm[</span>0] = <span class="string">Point(</span>x: <span class="string">11,</span> y: <span class="string">pm[</span>0].y)</span><br><span class="line"><span class="string">pm[</span>0].y = <span class="string">22/</span>/<span class="string">Cannot </span><span class="string">assign </span><span class="string">to </span><span class="string">property:</span> <span class="string">subscript </span><span class="string">is </span><span class="built_in">get-only</span></span><br></pre></td></tr></table></figure>

<h3 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h3><ul>
<li>加上set方法</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">struct <span class="type">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PointManager &#123;</span><br><span class="line">    var <span class="type">point</span> = <span class="type">Point</span>()</span><br><span class="line">    subscript(<span class="keyword">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">       <span class="keyword">set</span> &#123; <span class="type">point</span> = newValue &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">point</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面使用正常</span><br><span class="line">var pm = PointManager()</span><br><span class="line">pm[<span class="number">0</span>].x = <span class="number">11</span></span><br><span class="line">// 等价于 pm[<span class="number">0</span>] = <span class="type">Point</span>(x: <span class="number">11</span>, y: pm[<span class="number">0</span>].y)</span><br><span class="line">pm[<span class="number">0</span>].y = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h3 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h3><p>结构体改成类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">PointManager</span> &#123;</span><br><span class="line">    var point = Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; point &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面使用正常</span></span><br><span class="line">var pm = PointManager()</span><br><span class="line">pm[<span class="number">0</span>].x = <span class="number">11</span></span><br><span class="line"><span class="comment">// 等价于 pm[0] = Point(x: 11, y: pm[0].y)</span></span><br><span class="line">pm[<span class="number">0</span>].y = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>类是引用类型的，传递的是地址<br>结构体是值类型，传递的是具体的值</p>
<h2 id="接受多个参数的下标"><a href="#接受多个参数的下标" class="headerlink" title="接受多个参数的下标"></a>接受多个参数的下标</h2><p>eg,如下代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Grid</span> &#123;</span><br><span class="line">    var data = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    ]</span><br><span class="line">    subscript(row: Int, column: Int) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            guard row &gt;= <span class="number">0</span> &amp;&amp; row &lt; <span class="number">3</span> &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; <span class="number">3</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            data[row][column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            guard row &gt;= <span class="number">0</span> &amp;&amp; row &lt; <span class="number">3</span> &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; <span class="number">3</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data[row][column]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下使用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var grid = Grid()</span><br><span class="line">grid[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">77</span></span><br><span class="line">grid[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">88</span></span><br><span class="line">grid[<span class="number">2</span>, <span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">print(grid.data)</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<blockquote>
<p>[[0, 77, 2], [3, 4, 88], [99, 7, 8]]</p>
</blockquote>
<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之协议</title>
    <url>/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>协议，有关开发经验的应该都不陌生，很多语言中都有协议，但是相对来说，Swift中的协议更加强大，灵活。</p>
<ul>
<li>Swift中协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">//可读可写属性</span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//只读属性</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 下标</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类<code>TestClass</code>准守多个协议</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">protocol Test1 &#123; &#125;</span><br><span class="line">protocol Test2 &#123; &#125;</span><br><span class="line">protocol Test3 &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">TestClass</span> : <span class="symbol">Test1, <span class="symbol">Test2</span>, <span class="symbol">Test3</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>


<h3 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h3><ul>
<li>协议中定义方法时不能有默认参数值</li>
<li>默认情况下，协议中定义的内容必须全部都实现</li>
<li>也有办法办到只实现部分内容，后面会说</li>
</ul>
<h2 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h2><ul>
<li>协议中定义属性时必须用var关键字</li>
<li>实现协议时的属性权限要不小于协议中定义的属性权限</li>
<li>协议定义get、set，用var存储属性或get、set计算属性去实现</li>
<li>协议定义get，用任何属性都可以实现</li>
</ul>
<p>eg：有协议<code>Drawable</code>,里面有方法<code>draw</code>，以及可读可写属性<code>x</code>，只读属性<code>y</code>，下标。其中属性必须用<code>var</code>关键字</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">//可读可写 属性用var</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">//只读  属性用var</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">//下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当实现的时候，有如下的方式，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span> <span class="comment">//用var的存储属性</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">0</span> <span class="comment">//let实现只读属性</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person draw"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当然了。也可以写成如下这种</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="type">Drawable &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Int</span> &#123; <span class="comment">//用计算属性</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> &#123; <span class="number">0</span> &#125; <span class="comment">//var实现只读属性</span></span><br><span class="line">    func draw() &#123; print(<span class="string">"Person draw"</span>) &#125;</span><br><span class="line">    subscript(index: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="static、class"><a href="#static、class" class="headerlink" title="static、class"></a>static、class</h2><ul>
<li>为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标<ul>
<li>因为class只能用在类中，不能用于结构体等。所以为了通用，用static</li>
<li>但是实现的时候，可以用class，也可以用static，具体看自己的情况<br>eg:</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里必须用static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里可以用class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">draw</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person1 draw"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里也可以用static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person2 draw"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h2><p>关于<code>mutating</code>可以参考<a href="https://juejin.im/post/5d2ba7265188252d1d5f9218" target="_blank" rel="noopener">Swift之方法</a></p>
<ul>
<li>只有将协议中的实例方法标记为mutating<ul>
<li>才允许结构体、枚举的具体实现修改自身内存</li>
<li>类在实现方法时不用加mutating，枚举、结构体才需要加mutating</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        width = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><ul>
<li>协议中还可以定义初始化器init<ul>
<li>非final类实现时必须加上required</li>
</ul>
</li>
</ul>
<p>可以这么理解，如果定义的类，有子类，那么子类必须准守初始化器init，所以加上关键字<code>required</code>,但是，如果一个被<code>final</code>修饰的类。就不用加上<code>required</code>.因为被<code>final</code>修饰的类不能被其他类继承。</p>
<p>关于<code>final</code>可参考<a href="https://juejin.im/post/5d2d9ebbe51d4510634318bf" target="_blank" rel="noopener">Swift之继承</a></p>
<p>eg: 有协议<code>Drawable</code>,里面定义了初始化器<code>init</code>，类Point遵守这个协议，所以在init 前面加了关键字 <code>required</code>,这样，继承类Point的子类都要实现这个方法，但是类Size没子类。因为加了关键字<code>final</code>，这个类不能被继承。所以<code>init</code>前面不用加<code>required</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    <span class="keyword">init</span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> : <span class="type">Drawable &#123;</span></span></span><br><span class="line">    required <span class="keyword">init</span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Size</span> : <span class="type">Drawable &#123;</span></span></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果从协议实现的初始化器，刚好是重写了父类的指定初始化器<ul>
<li>那么这个初始化必须同时加required、override</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">protocol Livable &#123;</span><br><span class="line">    <span class="keyword">init</span>(age: <span class="built_in">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(age: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span>, <span class="type">Livable &#123;</span></span></span><br><span class="line">    required <span class="keyword">override</span> <span class="keyword">init</span>(age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="init、init-、init"><a href="#init、init-、init" class="headerlink" title="init、init?、init!"></a>init、init?、init!</h2><ul>
<li>协议中定义的init?、init!，可以用init、init?、init!去实现</li>
<li>协议中定义的init，可以用init、init!去实现</li>
</ul>
<p>eg:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line">protocol Livable &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">init</span>?(age: <span class="built_in">Int</span>)</span><br><span class="line">    <span class="keyword">init</span>!(no: <span class="built_in">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="type">Livable &#123;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//下面两种都可以实现init()</span></span><br><span class="line">    required <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    <span class="comment">// required init!() &#123; &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面3种都可以实现init?(age: Int)</span></span><br><span class="line">    required <span class="keyword">init</span>?(age: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// required init!(age: Int) &#123; &#125;</span></span><br><span class="line">    <span class="comment">// required init(age: Int) &#123; &#125;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//下面3种都可以实现 init!(no: Int)</span></span><br><span class="line">    required <span class="keyword">init</span>!(no: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// required init?(no: Int) &#123; &#125;</span></span><br><span class="line">    <span class="comment">// required init(no: Int) &#123; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h2><ul>
<li>一个协议可以继承其他协议</li>
</ul>
<p>eg</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 协议Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议Livable 继承协议 Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Livable</span> : <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">breath</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Livable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">breath</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h2><ul>
<li>协议组合，多个协议组合在一起，而且可以包含1个类类型（最多1个）</li>
</ul>
<p>eg: 两个协议<code>Livable</code>和<code>Runnable</code>,类<code>Person</code></p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">protocol <span class="keyword">Livable</span> &#123; &#125; <span class="keyword">n</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="keyword">Runnable</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Person</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>下面定义了fn0,接收参数必须是Person或者其子类的实例。fn1接收参数必须遵守Livable协议的实例，其他的可以自行看代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收Person或者其子类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn0</span><span class="params">(obj: Person)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收遵守Livable协议的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(obj: Livable)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收同时遵守Livable、Runnable协议的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">(obj: Livable &amp; Runnable)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn3</span><span class="params">(obj: Person &amp; Livable &amp; Runnable)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RealPerson</span> = <span class="type">Person</span> &amp; <span class="type">Livable</span> &amp; <span class="type">Runnable</span></span><br><span class="line"><span class="comment">// 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn4</span><span class="params">(obj: RealPerson)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="CaseIterable"><a href="#CaseIterable" class="headerlink" title="CaseIterable"></a>CaseIterable</h2><ul>
<li>让枚举遵守CaseIterable协议，可以实现遍历枚举值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举Season遵守协议CaseIterable</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> : <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出所有的case</span></span><br><span class="line"><span class="keyword">let</span> seasons = <span class="type">Season</span>.allCases</span><br><span class="line"><span class="built_in">print</span>(seasons.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以遍历</span></span><br><span class="line"><span class="keyword">for</span> season <span class="keyword">in</span> seasons &#123;</span><br><span class="line">    <span class="built_in">print</span>(season)</span><br><span class="line">&#125; <span class="comment">// spring summer autumn winter</span></span><br></pre></td></tr></table></figure>

<h2 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h2><ul>
<li>遵守CustomStringConvertible协议，可以自定义实例的打印字符串</li>
</ul>
<p>eg: <code>Person</code>类遵守了<code>CustomStringConvertible</code>协议,可以再内部自定义打印<code>description</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: Int</span><br><span class="line">    <span class="keyword">var</span> name: <span class="built_in">String</span></span><br><span class="line">    init(age: Int, name: <span class="built_in">String</span>) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="string">"age=\(age), name=\(name)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person(age: <span class="number">10</span>, name: <span class="string">"Jack"</span>)</span><br><span class="line"><span class="built_in">print</span>(p) <span class="comment">// age=10, name=Jack</span></span><br></pre></td></tr></table></figure>

<h2 id="Any、AnyObject"><a href="#Any、AnyObject" class="headerlink" title="Any、AnyObject"></a>Any、AnyObject</h2><ul>
<li>Swift提供了2种特殊的类型：Any、AnyObject<ul>
<li>Any：可以代表任意类型（枚举、结构体、类，也包括函数类型）</li>
<li>AnyObject：可以代表任意类类型（在协议后面写上: AnyObject代表只有类能遵守这个协议）</li>
</ul>
</li>
</ul>
<p>eg: stu属于Any类型,可以赋值为字符串或者对象等</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var stu: <span class="attr">Any</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">stu</span> = <span class="string">"Jack"</span></span><br><span class="line"><span class="attr">stu</span> = Student()</span><br></pre></td></tr></table></figure>

<p>eg: 创建1个能存放任意类型的数组</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建1个能存放任意类型的数组</span></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="comment">// var data = Array&lt;Any&gt;()</span></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = [Any]()</span><br><span class="line"><span class="keyword">data</span>.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">data</span>.append(<span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">data</span>.append(Student())</span><br><span class="line"><span class="keyword">data</span>.append(<span class="string">"Jack"</span>)</span><br><span class="line"><span class="keyword">data</span>.append(&#123; <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure>


<h2 id="is、as-、as-、as"><a href="#is、as-、as-、as" class="headerlink" title="is、as?、as!、as"></a>is、as?、as!、as</h2><ul>
<li>is用来判断是否为某种类型，as用来做强制类型转换</li>
</ul>
<p>eg: 定义协议<code>Runnable</code>,类<code>Person</code>和类<code>Student</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Student run"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Student study"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用is 的时候</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> stu: Any = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Int)</span></span> <span class="comment">// true</span></span><br><span class="line">stu = <span class="string">"Jack"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is String)</span></span> <span class="comment">// true</span></span><br><span class="line">stu = Student()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Person)</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Student)</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Runnable)</span></span> <span class="comment">// t</span></span><br></pre></td></tr></table></figure>

<p>使用as 的时候,如果转换失败，后面都不执行。转换成功，后面才继续执行</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stu: Any = 10</span><br><span class="line">(stu <span class="keyword">as</span>? Student)?.study() <span class="comment">// 没有调用study</span></span><br><span class="line">stu = Student()</span><br><span class="line">(stu <span class="keyword">as</span>? Student)?.study() <span class="comment">// Student study</span></span><br><span class="line">(stu <span class="keyword">as</span>! Student).study() <span class="comment">// Student study</span></span><br><span class="line">(stu <span class="keyword">as</span>? Runnable)?.<span class="keyword">run</span>() <span class="comment">// Student run</span></span><br></pre></td></tr></table></figure>


<h2 id="X-self、X-Type、AnyClass"><a href="#X-self、X-Type、AnyClass" class="headerlink" title="X.self、X.Type、AnyClass"></a>X.self、X.Type、AnyClass</h2><ul>
<li>X.self是一个元类型（metadata）的指针，metadata存放着类型相关信息</li>
<li>X.self属于X.Type类型</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义类Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">// 定义类Student 继承 Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//perType类型是 Person.Type</span></span><br><span class="line"><span class="keyword">var</span> perType: <span class="type">Person</span>.<span class="type">Type</span> = <span class="type">Person</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">//stuType类型是 Student.Type</span></span><br><span class="line"><span class="keyword">var</span> stuType: <span class="type">Student</span>.<span class="type">Type</span> = <span class="type">Student</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// Student.self可以赋值给perType</span></span><br><span class="line">perType = <span class="type">Student</span>.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// anyType可以是任何类型</span></span><br><span class="line"><span class="keyword">var</span> anyType: <span class="type">AnyObject</span>.<span class="type">Type</span> = <span class="type">Person</span>.<span class="keyword">self</span></span><br><span class="line">anyType = <span class="type">Student</span>.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnyClass</span> = <span class="type">AnyObject</span>.<span class="type">Type</span></span><br><span class="line"><span class="comment">//anyType2可以是任何类型</span></span><br><span class="line"><span class="keyword">var</span> anyType2: <span class="type">AnyClass</span> = <span class="type">Person</span>.<span class="keyword">self</span></span><br><span class="line">anyType2 = <span class="type">Student</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure>

<h2 id="元类型的应用"><a href="#元类型的应用" class="headerlink" title="元类型的应用"></a>元类型的应用</h2><p>eg:<code>Cat</code>类，<code>Dog</code>类，<code>Pig</code>类，都继承自<code>Animal</code>类，我们想同时去初始化，可使用下面的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; <span class="keyword">required</span> <span class="keyword">init</span>() &#123; &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> : <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> clses: [Animal.<span class="keyword">Type</span>])</span></span> -&gt; [<span class="type">Animal</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="type">Animal</span>]()</span><br><span class="line">    <span class="keyword">for</span> cls <span class="keyword">in</span> clses &#123;</span><br><span class="line">        <span class="comment">// 根据元类型初始化</span></span><br><span class="line">        arr.append(cls.<span class="keyword">init</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里传入Cat,Dog,Pig进行初始化</span></span><br><span class="line"><span class="built_in">print</span>(create([<span class="type">Cat</span>.<span class="keyword">self</span>, <span class="type">Dog</span>.<span class="keyword">self</span>, <span class="type">Pig</span>.<span class="keyword">self</span>]))</span><br></pre></td></tr></table></figure>

<p><strong>注意上面的required不能省略</strong></p>
<ul>
<li>在OC、Java等语言中，任何一个类最终都要继承自某个基类，</li>
<li>在Swift中没有这个规定，如果一个类不继承任何一个类，那这个类就是基类</li>
</ul>
<p>实际上，真的如此么，真的不继承任何类么？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(class_getInstanceSize(<span class="type">Student</span>.<span class="keyword">self</span>)) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">print</span>(class_getSuperclass(<span class="type">Student</span>.<span class="keyword">self</span>)!) <span class="comment">// Person</span></span><br><span class="line"><span class="built_in">print</span>(class_getSuperclass(<span class="type">Person</span>.<span class="keyword">self</span>)!) <span class="comment">// Swift._SwiftObject</span></span><br></pre></td></tr></table></figure>


<ul>
<li>从结果可以看得出来，Swift还有个隐藏的基类：Swift._SwiftObject</li>
<li>可以参考<a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObjec.h" target="_blank" rel="noopener">Swift源码</a></li>
</ul>
<h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><ul>
<li>Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型（也可以作为参数类型）</li>
</ul>
<p>有点类似OC中的instanType的感觉。eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123; type(of: <span class="keyword">self</span>).<span class="keyword">init</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>调用时候</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = Person()</span><br><span class="line"><span class="comment">// 输出Person</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p.test()</span></span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> stu = Student()</span><br><span class="line"><span class="comment">// 输出Student</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu.test()</span></span>)</span><br></pre></td></tr></table></figure>


<p>参考资料：</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>汇编深入分析inout本质</title>
    <url>/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于<code>输入输出参数inout</code> 在<a href="https://juejin.im/post/5d1eec54f265da1bb27750ba" target="_blank" rel="noopener">Swift之函数</a>一文中，我们已经有了初步的认识。现在我们再继续深入了解一下</p>
<h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><ul>
<li>说了形参只能是let，但是如果我们想再内部修改外部实参的值，可以用 inout 定义输入输出参数</li>
</ul>
<p>例如</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">func swapValues(_ v1: <span class="keyword">inout</span> Int, _ v2: <span class="keyword">inout</span> Int) &#123;</span><br><span class="line">     let tmp = v1</span><br><span class="line">     v1 = v2</span><br><span class="line">     v2 = tmp</span><br><span class="line">     <span class="comment">//前面三行也可以换成  (v1, v2) = (v2, v1) 效果一样</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  var num1 = <span class="number">10</span></span><br><span class="line">  var num2 = <span class="number">20</span></span><br><span class="line">  swapValues(&amp;num1, &amp;num2)</span><br><span class="line"> print(<span class="string">"num1 = \(num1), num2 = \(num2)"</span>)</span><br><span class="line">    </span><br><span class="line">  输出： num1 = <span class="number">20</span>, num2 = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>注意点:</p>
<ul>
<li>可变参数不能标记为inout</li>
<li>inout参数不能有默认值</li>
<li>inout参数的本质是地址传递(引用传递)</li>
<li>inout参数只能传入可以被多次赋值的</li>
</ul>
<h2 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h2><p><code>inout</code> 是地址传递，对于不同的情况具体怎么传递呢？汇编拨开云雾</p>
<p>如下代码，表示等边的多边形，其中<code>width</code>表示边长，<code>side</code>表示多边形边长数量 <code>girth</code>表示周长，我们知道 <code>周长 = 边长 * 边数</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line"> 	<span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="inout-修改存储属性"><a href="#inout-修改存储属性" class="headerlink" title="inout 修改存储属性"></a>inout 修改存储属性</h2><h3 id="先看打印结果"><a href="#先看打印结果" class="headerlink" title="先看打印结果"></a>先看打印结果</h3><p> 如下代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line"> 	<span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(&amp;s.width) <span class="comment">//这里打断点</span></span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">getGirth</span><br><span class="line">width=8, side=4, girth=32</span><br></pre></td></tr></table></figure>

<p>其中<code>getGirth</code>这句打印是因为后面的<code>show</code>方法需要获取<code>girth</code>的值，如果我们去掉最后一句,只有如下代码</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s = Shape(<span class="attribute">width</span>: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(&amp;s.width)</span></span></span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>在上面代码中的 <code>test(&amp;s.width)</code>这一句打断点</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef672deebf0?w=1172&h=650&f=png&s=295179" alt=""></p>
<p>关键代码为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量0x44be(%rip)的地址给寄存器rdi，rdi是全局变量s的地址</span></span><br><span class="line"> <span class="number">0x100000fbb</span> &lt;+<span class="number">107</span>&gt;: leaq   <span class="number">0x44be</span>(%rip), %rdi        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用test函数，其中rdi作为参数传入</span></span><br><span class="line"><span class="number">0x100000fc2</span> &lt;+<span class="number">114</span>&gt;: callq  <span class="number">0x100001930</span>               ; testSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">44</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> <strong>把属性<code>s.width</code>的地址值传递过去，进行修改</strong></p>
<ul>
<li>全局变量0x44be(%rip)的地址给寄存器rdi，rdi是全局变量s的地址</li>
<li>调用test函数，其中rdi作为参数传入</li>
</ul>
<ul>
<li><p>为什么我们代码中写的是 s.width ，但汇编传入的是s的地址呢？</p>
<ul>
<li>因为，width作为结构体的第一个属性变量，它的地址就是结构体s的地址</li>
</ul>
</li>
<li><p>为什么rdi是作为参数呢？</p>
<ul>
<li><a href="https://juejin.im/post/5d19f9816fb9a07f0a2df848" target="_blank" rel="noopener">汇编总结</a>中我们知道 rdi、rsi、rdx、rcx、r8、r9等寄存器常用于存放函数参数。</li>
</ul>
</li>
</ul>
<h2 id="inout-修改带有属性观察器的存储属性"><a href="#inout-修改带有属性观察器的存储属性" class="headerlink" title="inout 修改带有属性观察器的存储属性"></a>inout 修改带有属性观察器的存储属性</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先分析一下，应该和前面存储属性不一样的，因为如果直接修改存储属性<code>side</code>的值，那怎么调动属性观察器的方法<code>willSet</code>和<code>didSet</code>呢？，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">test(&amp;s.side) <span class="comment">//这里打断点</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">willSetSide 8</span><br><span class="line">didSetSide 4 8</span><br></pre></td></tr></table></figure>



<h3 id="查看汇编"><a href="#查看汇编" class="headerlink" title="查看汇编"></a>查看汇编</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef673dc1585?w=2092&h=1244&f=png&s=814277" alt=""></p>
<p>关键汇编代码分析</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量0x44e4(%rip)的地址给寄存器rdi，地址是testSwift.Shape + 8也就是size的地址</span></span><br><span class="line"><span class="number">0x100000f9d</span> &lt;+<span class="number">109</span>&gt;: movq   <span class="number">0x44e4</span>(%rip), %rax        ; testSwift.s : testSwift.Shape + <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//size的地址给局部变量-0x28(%rbp)</span></span><br><span class="line"><span class="number">0x100000fa4</span> &lt;+<span class="number">116</span>&gt;: movq   %rax, <span class="number">-0x28</span>(%rbp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量-0x28(%rbp)的值给寄存器 %rdi</span></span><br><span class="line"><span class="number">0x100000fa8</span> &lt;+<span class="number">120</span>&gt;: leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test函数，寄存器 %rdi作为参数传入</span></span><br><span class="line"><span class="number">0x100000fac</span> &lt;+<span class="number">124</span>&gt;: callq  <span class="number">0x100001930</span>               ; testSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时已经修改完了局部变量 -0x28(%rbp)对应的值 并把局部变量 -0x28(%rbp)的值传给rdi,</span></span><br><span class="line"><span class="number">0x100000fb1</span> &lt;+<span class="number">129</span>&gt;: movq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"><span class="number">0x100000fb5</span> &lt;+<span class="number">133</span>&gt;: leaq   <span class="number">0x44c4</span>(%rip), %r13        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从截图中也可以看到此时%rdi里面是8，也就是 test函数中的  num = 8</span></span><br><span class="line"><span class="number">0x100000fbc</span> &lt;+<span class="number">140</span>&gt;: callq  <span class="number">0x100001240</span>               ; testSwift.Shape.side.setter : Swift.Int at &lt;compiler-generated&gt;</span><br></pre></td></tr></table></figure>

<h3 id="testSwift-Shape-side-setter函数中，调用side-willset-和-side-didset"><a href="#testSwift-Shape-side-setter函数中，调用side-willset-和-side-didset" class="headerlink" title="testSwift.Shape.side.setter函数中，调用side.willset 和 side.didset"></a><code>testSwift.Shape.side.setter</code>函数中，调用<code>side.willset</code> 和 <code>side.didset</code></h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef675ec0101?w=1988&h=1154&f=png&s=538327" alt=""></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>对于带有属性观察器的存储属性<code>size</code></p>
<ul>
<li>首先把<code>size</code>的地址放在一个局部变量中</li>
<li>然后调用<code>test</code>方法，把局部变量的值修改</li>
<li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>size</code></li>
</ul>
<h2 id="inout-修改计算属性girth"><a href="#inout-修改计算属性girth" class="headerlink" title="inout 修改计算属性girth"></a>inout 修改计算属性<code>girth</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先分析一下，应该和前面存储属性不一样的，因为计算属性<code>girth</code>没有自己的内存地址，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">test(&amp;s.girth) <span class="comment">//这里打断点</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">getGirth</span><br><span class="line">test</span><br><span class="line">setGirth 8</span><br></pre></td></tr></table></figure>



<h3 id="查看汇编-1"><a href="#查看汇编-1" class="headerlink" title="查看汇编"></a>查看汇编</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef676ac3806?w=2008&h=1198&f=png&s=568740" alt=""></p>
<h3 id="汇编分析-1"><a href="#汇编分析-1" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>关键汇编代码分析</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用testSwift.Shape.girth.getter 方法，返回值放在rax中</span></span><br><span class="line"><span class="number">0x100000fab</span> &lt;+<span class="number">123</span>&gt;: callq  <span class="number">0x100001580</span>               ; testSwift.Shape.girth.getter : Swift.Int at main.swift:<span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把getter的返回值放在 局部变量-0x28(%rbp)中</span></span><br><span class="line"><span class="number">0x100000fb0</span> &lt;+<span class="number">128</span>&gt;: movq   %rax, <span class="number">-0x28</span>(%rbp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量-0x28(%rbp)的地址值 放在寄存器rdi</span></span><br><span class="line"><span class="number">0x100000fb4</span> &lt;+<span class="number">132</span>&gt;: leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"><span class="comment">//寄存器rdi的地址值传到testSwift.test函数中，进行修改</span></span><br><span class="line"><span class="number">0x100000fb8</span> &lt;+<span class="number">136</span>&gt;: callq  <span class="number">0x100001930</span>               ; testSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量-0x28(%rbp)的值，传到寄存器rdi中</span></span><br><span class="line"><span class="number">0x100000fbd</span> &lt;+<span class="number">141</span>&gt;: movq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0x100000fc1</span> &lt;+<span class="number">145</span>&gt;: leaq   <span class="number">0x44b8</span>(%rip), %r13        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器rdi里面放的是局部变量-0x28(%rbp)的值 传入到Shape.girth.setter中</span></span><br><span class="line"><span class="number">0x100000fc8</span> &lt;+<span class="number">152</span>&gt;: callq  <span class="number">0x1000012f0</span>               ;  testSwift.Shape.girth.setter : Swift.Int at main.swift:<span class="number">28</span></span><br></pre></td></tr></table></figure>


<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>因为计算属性本身没有地址值，所以过程略显复杂</p>
<p>对于<code>inout</code>修改计算属性<code>girth</code></p>
<ul>
<li>首先调用<code>getter</code>方法，把返回值放在一个局部变量中</li>
<li>然后调用<code>test</code>方法，把局部变量的值修改</li>
<li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>girth</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="针对本文代码的总结"><a href="#针对本文代码的总结" class="headerlink" title="针对本文代码的总结"></a>针对本文代码的总结</h3><p>输入输出参数inout 本质就是引用传递，也就是地址传递，根据传过来的地址，修改对应的值。针对不同的情况，其他处理不同，</p>
<ul>
<li>普通存储属性，直接把地址值传过来修改就可以了。</li>
<li>对于<code>inout</code>带有属性观察器的存储属性<code>size</code><ul>
<li>首先把<code>size</code>的地址放在一个局部变量中</li>
<li>然后调用<code>test</code>方法，把局部变量的值修改</li>
<li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>size</code></li>
</ul>
</li>
<li>对于<code>inout</code>修改计算属性<code>girth</code><ul>
<li>首先调用<code>getter</code>方法，把返回值放在一个局部变量中</li>
<li>然后调用<code>test</code>方法，把局部变量的值修改</li>
<li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>girth</code></li>
</ul>
</li>
</ul>
<h3 id="针对inout的总结"><a href="#针对inout的总结" class="headerlink" title="针对inout的总结"></a>针对inout的总结</h3><ul>
<li>如果实参有物理内存地址，且没有设置属性观察器    <ul>
<li>直接将实参的内存地址传入函数（实参进行引用传递）</li>
<li>如果实参是计算属性 或者 设置了属性观察器</li>
</ul>
</li>
<li>采取了Copy In Copy Out的做法<ul>
<li>调用该函数时，先复制实参的值，产生副本【get】</li>
<li>将副本的内存地址传入函数（副本进行引用传递），在函数内部可以修改副本的值</li>
<li>函数返回后，再将副本的值覆盖实参的值【set】</li>
</ul>
</li>
<li>总结：inout的本质就是引用传递（地址传递）</li>
</ul>
<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之继承</title>
    <url>/Swift%E4%B9%8B%E7%BB%A7%E6%89%BF.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%A7%E6%89%BF.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同其他语言一样，Swift中也是有继承的</p>
<ul>
<li>值类型（枚举、结构体）不支持继承，只有类支持继承</li>
<li>没有父类的类，称为：基类<ul>
<li>Swift并没有像OC、Java那样的规定：任何类最终都要继承自某个基类</li>
</ul>
</li>
<li>子类可以重写父类的下标、方法、属性，重写必须加上<code>override</code>关键字</li>
</ul>
<h2 id="类继承的内存结构"><a href="#类继承的内存结构" class="headerlink" title="类继承的内存结构"></a>类继承的内存结构</h2><ul>
<li>有如下<code>Animal类</code>,其中<code>Dog 类</code>继承<code>Animal类</code> ，其中<code>ErHa 类</code>继承<code>Dog类</code></li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Animal</span> &#123;</span><br><span class="line">    var age = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Dog</span> : <span class="symbol">Animal</span> &#123;</span><br><span class="line">    var weight = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ErHa</span> : <span class="symbol">Dog</span> &#123;</span><br><span class="line">    var iq = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Animal类的内存"><a href="#Animal类的内存" class="headerlink" title="Animal类的内存"></a><code>Animal类</code>的内存</h3><p>如下代码查看类的内存大小和相应内存的值，需要用到工具<a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">Mems</a><br>关于的使用可以看<a href="https://juejin.im/post/5d1eeca3f265da1ba6480cc7" target="_blank" rel="noopener">Swift之枚举</a>一文，或者直接看github上<a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">Mems</a>的说明</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="constructor">Animal()</span></span><br><span class="line">a.age = <span class="number">5</span></span><br><span class="line">print(<span class="module-access"><span class="module"><span class="identifier">Mems</span>.</span></span>size(ofRef: a))</span><br><span class="line">print(<span class="module-access"><span class="module"><span class="identifier">Mems</span>.</span></span>mem<span class="constructor">Str(<span class="params">ofRef</span>: <span class="params">a</span>)</span>)</span><br></pre></td></tr></table></figure>

<p><code>Animal类</code>的内存大小和内容，分别为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">0x00000001000084d8</span> <span class="comment">//存放类的相关信息</span></span><br><span class="line"><span class="number">0x0000000000000002</span> <span class="comment">//引用技术</span></span><br><span class="line"><span class="number">0x0000000000000005</span>  <span class="comment">// age数值5</span></span><br><span class="line"><span class="number">0x0000000000000000</span>	<span class="comment">//没用到</span></span><br></pre></td></tr></table></figure>

<h3 id="Animal类的内存分析"><a href="#Animal类的内存分析" class="headerlink" title="Animal类的内存分析"></a><code>Animal类</code>的内存分析</h3><ul>
<li>首先类本身就要占用16个字节，其中8个存放类的信息，8个存放引用技术，具体分析见<a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a></li>
<li>然后是 age的值5 占用8个字节，总共24个字节，</li>
<li>因为内存对齐的原因，必须是16的倍数，所以需要32个字节，其中最后8个字节用不到，全是0</li>
</ul>
<h3 id="Dog类的内存"><a href="#Dog类的内存" class="headerlink" title="Dog类的内存"></a><code>Dog类</code>的内存</h3><p>如下代码查看类的内存大小和相应内存的值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="constructor">Dog()</span></span><br><span class="line">d.age = <span class="number">6</span></span><br><span class="line">d.weight = <span class="number">7</span></span><br><span class="line">print(<span class="module-access"><span class="module"><span class="identifier">Mems</span>.</span></span>size(ofRef: d))</span><br><span class="line">print(<span class="module-access"><span class="module"><span class="identifier">Mems</span>.</span></span>mem<span class="constructor">Str(<span class="params">ofRef</span>: <span class="params">d</span>)</span>)</span><br></pre></td></tr></table></figure>

<p><code>Dog类</code>的内存大小和内容，分别为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">0x0000000100008588</span> <span class="comment">//存放类的相关信息</span></span><br><span class="line"><span class="number">0x0000000000000002</span> <span class="comment">//引用技术</span></span><br><span class="line"><span class="number">0x0000000000000006</span>  <span class="comment">// age数值6</span></span><br><span class="line"><span class="number">0x0000000000000007</span>	<span class="comment">//weight的值7</span></span><br></pre></td></tr></table></figure>

<h3 id="Dog类的内存分析"><a href="#Dog类的内存分析" class="headerlink" title="Dog类的内存分析"></a><code>Dog类</code>的内存分析</h3><ul>
<li>首先类本身就要占用16个字节，其中8个存放类的信息，8个存放引用技术，具体分析见<a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a></li>
<li>然后是 age的值6 占用8个字节，weight的值7 占用8个字节， 总共32个字节，</li>
<li>因为内存对齐的原因，必须是16的倍数，但是32正好是16的倍数，所以总共需要32个字</li>
</ul>
<h3 id="ErHa类的内存"><a href="#ErHa类的内存" class="headerlink" title="ErHa类的内存"></a><code>ErHa类</code>的内存</h3><p>如下代码查看类的内存大小和相应内存的值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="constructor">ErHa()</span></span><br><span class="line">e.age = <span class="number">8</span></span><br><span class="line">e.weight = <span class="number">9</span></span><br><span class="line">e.iq = <span class="number">10</span></span><br><span class="line">print(<span class="module-access"><span class="module"><span class="identifier">Mems</span>.</span></span>size(ofRef: e))</span><br><span class="line">print(<span class="module-access"><span class="module"><span class="identifier">Mems</span>.</span></span>mem<span class="constructor">Str(<span class="params">ofRef</span>: <span class="params">e</span>)</span>)</span><br></pre></td></tr></table></figure>

<p><code>ErHa类</code>的内存大小和内容，分别为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">0x0000000100008658</span> <span class="comment">//存放类的相关信息</span></span><br><span class="line"><span class="number">0x0000000000000002</span> <span class="comment">//引用技术</span></span><br><span class="line"><span class="number">0x0000000000000008</span>  <span class="comment">// age数值8</span></span><br><span class="line"><span class="number">0x0000000000000009</span>	<span class="comment">//weight的值9</span></span><br><span class="line"><span class="number">0x000000000000000a</span>	<span class="comment">//iq的值10</span></span><br><span class="line"><span class="number">0x0000000000000000</span>	<span class="comment">//内存对齐增加的，没用到</span></span><br></pre></td></tr></table></figure>

<h3 id="ErHa类的内存分析"><a href="#ErHa类的内存分析" class="headerlink" title="ErHa类的内存分析"></a><code>ErHa类</code>的内存分析</h3><ul>
<li>首先类本身就要占用16个字节，其中8个存放类的信息，8个存放引用技术，具体分析见<a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a></li>
<li>然后是 age,weight,iq分别占用8个字节，16+24 = 40个字节了</li>
<li>因为内存对齐的原因，必须是16的倍数，所以需要48个字节</li>
</ul>
<h2 id="重写实例方法、下标"><a href="#重写实例方法、下标" class="headerlink" title="重写实例方法、下标"></a>重写实例方法、下标</h2><p>子类可以重写父类的实例方法、下标</p>
<p>有个<code>Animal</code> 类</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Animal speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类<code>Cat</code>继承<code>Animal</code>,如果重写示例方法，下标，必须用关键字<code>override</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Animal speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.speak()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Cat speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>[index] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写类型方法、下标"><a href="#重写类型方法、下标" class="headerlink" title="重写类型方法、下标"></a>重写类型方法、下标</h2><p>上面的实例方法、下标。如果是类型方法、下标的话，有些许不同，</p>
<ul>
<li>被class修饰的类型方法、下标，允许被子类重写</li>
<li>被static修饰的类型方法、下标，不允许被子类重写</li>
</ul>
<p>eg</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//static修饰</span></span><br><span class="line">    static func speak() &#123;</span><br><span class="line">        print(<span class="string">"Animal speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// class修饰</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">subscript</span></span>(index: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(Animal[<span class="number">6</span>])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="type">Animal &#123;</span></span></span><br><span class="line">	<span class="comment">//编译报错 Cannot override static method</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">speak</span></span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.speak()</span><br><span class="line">        print(<span class="string">"Cat speak"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译成功</span></span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">subscript</span></span>(index: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>[index] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示<code>static</code>修饰的时候，子类重写，直接报错<code>Cannot override static method</code>。而<code>class</code>修饰时候，编译正常</p>
<h2 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h2><ul>
<li>子类可以将父类的属性（存储、计算）重写为计算属性</li>
<li>子类不可以将父类属性重写为存储属性</li>
<li>只能重写var属性，不能重写let属性</li>
<li>重写时，属性名、类型要一致</li>
<li>子类重写后的属性权限 不能小于 父类属性的权限<ul>
<li>如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的</li>
<li>如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的</li>
</ul>
</li>
</ul>
<h3 id="重写类型属性"><a href="#重写类型属性" class="headerlink" title="重写类型属性"></a>重写类型属性</h3><p> 重写类型属性，比较简单，不做赘述</p>
<h3 id="重写类型属性-1"><a href="#重写类型属性-1" class="headerlink" title="重写类型属性"></a>重写类型属性</h3><p><strong>注意的是：如果子类把父类的存储属性int 重写为计算属性，子类中依然有8个字节存储该int属性</strong></p>
<p><strong>再次需要注意的是，和重写类型方法、下标类似 如果重写类型属性</strong></p>
<ul>
<li>被class修饰的类型方法、下标，允许被子类重写</li>
<li>被static修饰的类型方法、下标，不允许被子类重写</li>
</ul>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><h3 id="可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性"><a href="#可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性" class="headerlink" title="可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性"></a>可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性</h3><p>eg，子类<code>SubCircle</code>给父类<code>Circle</code>的存储属性<code>radius</code>增加属性观察器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCircle</span> : <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> radius: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"SubCircle willSetRadius"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"SubCircle didSetRadius"</span>, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点：子类增加属性观察器之后，依然是存储属性</strong></p>
<h3 id="如果父类本身就有属性观察器"><a href="#如果父类本身就有属性观察器" class="headerlink" title="如果父类本身就有属性观察器"></a>如果父类本身就有属性观察器</h3><p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Int</span> = <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Circle willSetRadius"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Circle didSetRadius"</span>, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCircle</span> : <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> radius: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"SubCircle willSetRadius"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"SubCircle didSetRadius"</span>, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> circle = <span class="type">SubCircle</span>()</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SubCircle willSetRadius <span class="number">10</span></span><br><span class="line">Circle willSetRadius <span class="number">10</span></span><br><span class="line">Circle didSetRadius <span class="number">1</span> <span class="number">10</span></span><br><span class="line">SubCircle didSetRadius <span class="number">1</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="重写父类的计算属性"><a href="#重写父类的计算属性" class="headerlink" title="重写父类的计算属性"></a>重写父类的计算属性</h3><p>如下代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Circle setRadius"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Circle getRadius"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCircle</span> : <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> radius: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"SubCircle willSetRadius"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"SubCircle didSetRadius"</span>, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">var <span class="built_in">circle</span> = SubCircle()</span><br><span class="line"><span class="built_in">circle</span>.radius = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Circle</span> <span class="string">getRadius</span></span><br><span class="line"><span class="attr">SubCircle</span> <span class="string">willSetRadius 10</span></span><br><span class="line"><span class="attr">Circle</span> <span class="string">setRadius 10</span></span><br><span class="line"><span class="attr">Circle</span> <span class="string">getRadius</span></span><br><span class="line"><span class="attr">SubCircle</span> <span class="string">didSetRadius 20 20</span></span><br></pre></td></tr></table></figure>

<p>输出结果分析</p>
<ul>
<li>调用<code>circle.radius = 10</code>的时候，先获取了<code>oldValue</code>，调用父类的<code>get</code>输出<code>Circle getRadius</code></li>
<li>然后调用子类<code>willSetRadius</code>准备赋值</li>
<li>调用父类<code>setRadius</code></li>
<li>准备调用子类的<code>print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</code>之前，要先获取<code>radius</code>的值，所以，需要先执行父类的<code>getRadius</code></li>
<li>执行子类的<code>didSet</code>方法</li>
</ul>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul>
<li>被final修饰的方法、下标、属性，禁止被重写</li>
<li>被final修饰的类，禁止被继承</li>
</ul>
<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之方法</title>
    <url>/Swift%E4%B9%8B%E6%96%B9%E6%B3%95.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E6%96%B9%E6%B3%95.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>方法，也就是函数。同其他语言一样，在Swift中，也是分为实例方法和类型方法</p>
<h2 id="枚举、结构体、类都可以定义实例方法、类型方法"><a href="#枚举、结构体、类都可以定义实例方法、类型方法" class="headerlink" title="枚举、结构体、类都可以定义实例方法、类型方法"></a>枚举、结构体、类都可以定义实例方法、类型方法</h2><h3 id="实例方法（Instance-Method）：通过实例对象调用"><a href="#实例方法（Instance-Method）：通过实例对象调用" class="headerlink" title="实例方法（Instance Method）：通过实例对象调用"></a>实例方法（Instance Method）：通过实例对象调用</h3><h3 id="类型方法（Type-Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法"><a href="#类型方法（Type-Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法" class="headerlink" title="类型方法（Type Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法"></a>类型方法（Type Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法</h3><p>例如有个类Car,有实例方法<code>getnNum</code>和类型方法<code>getCount</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> cout = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">Car</span>.cout += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类型方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getCount</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; cout &#125;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getnNum</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c0 = <span class="type">Car</span>()</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="type">Car</span>()</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="type">Car</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="type">Car</span>.getCount()) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">c0.num = <span class="number">10</span></span><br><span class="line">c1.num = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1.num) <span class="comment">//11</span></span><br><span class="line"><span class="built_in">print</span>(c2.num) <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>不管是实例方法，还是类型方法，里面都可以调用 <code>self</code></p>
<ul>
<li>在实例方法中代表实例对象</li>
<li>在类型方法中代表类型<ul>
<li>在类型方法static func getCount中</li>
<li>cout等价于self.cout、Car.self.cout、Car.cout</li>
</ul>
</li>
</ul>
<p>例如上面的代码可以写成</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> cout = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">Car</span>.cout += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类型方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getCount</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.cout <span class="comment">//self代表类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getnNum</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.num <span class="comment">//self代表实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字mutating"><a href="#关键字mutating" class="headerlink" title="关键字mutating"></a>关键字<code>mutating</code></h2><ul>
<li>结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改</li>
<li>在func关键字前加mutating可以允许这种修改行为</li>
</ul>
<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span><span class="params">(deltaX: Double, deltaY: Double)</span></span> &#123;</span><br><span class="line">        x += deltaX <span class="comment">//编译报错 Left side of mutating operator isn't mutable: 'self' is immutable</span></span><br><span class="line">        y += deltaY <span class="comment">//编译报错 Left side of mutating operator isn't mutable: 'self' is immutable</span></span><br><span class="line">         <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY) <span class="comment">//编译报错 Cannot assign to value: 'self' is immutable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> low, middle, high</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> = .middle<span class="comment">//编译报错 Cannot assign to value: 'self' is immutable</span></span><br><span class="line">        <span class="keyword">case</span> .middle:</span><br><span class="line">            <span class="keyword">self</span> = .high<span class="comment">//编译报错 Cannot assign to value: 'self' is immutable</span></span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> = .low<span class="comment">//编译报错 Cannot assign to value: 'self' is immutable</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加上关键字<code>mutating</code>之后就可以了</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span><span class="params">(deltaX: Double, deltaY: Double)</span></span> &#123;</span><br><span class="line">        x += deltaX </span><br><span class="line">        y += deltaY </span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY) </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> low, middle, high</span><br><span class="line">   <span class="keyword">mutating</span>  <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> = .middle</span><br><span class="line">        <span class="keyword">case</span> .middle:</span><br><span class="line">            <span class="keyword">self</span> = .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> = .low        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字-discardableResult"><a href="#关键字-discardableResult" class="headerlink" title="关键字@discardableResult"></a>关键字<code>@discardableResult</code></h2><ul>
<li>在func前面加个@discardableResult，可以消除：函数调用后返回值未被使用的警告⚠</li>
</ul>
<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">     <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveX</span><span class="params">(deltaX: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Point</span>()</span><br><span class="line">p.moveX(deltaX: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>因为方法<code>moveX</code>的返回值没有使用，编译器会报警告</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/15/16bf284e958adef2?w=871&h=216&f=png&s=50207" alt=""></p>
<ul>
<li>如果加了关键字<code>@discardableResult</code>就不会警告了</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="meta">@discardableResult</span> <span class="keyword">mutating</span> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveX</span><span class="params">(deltaX: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Point</span>()</span><br><span class="line">p.moveX(deltaX: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之属性</title>
    <url>/Swift%E4%B9%8B%E5%B1%9E%E6%80%A7.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift之属性.html">我的个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面了解了 <a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a>  和 <a href="https://juejin.im/post/5d216e1ff265da1bb27752aa" target="_blank" rel="noopener">Swift之结构体</a>  </p>
<p>这篇文章分享一下Swift中的属性</p>
<h2 id="Swift中跟实例相关的属性可以分为2大类"><a href="#Swift中跟实例相关的属性可以分为2大类" class="headerlink" title="Swift中跟实例相关的属性可以分为2大类"></a>Swift中跟实例相关的属性可以分为2大类</h2><h3 id="存储属性（Stored-Property）"><a href="#存储属性（Stored-Property）" class="headerlink" title="存储属性（Stored Property）"></a>存储属性（Stored Property）</h3><ul>
<li>类似于成员变量这个概念</li>
<li>存储在实例的内存中</li>
<li>结构体、类可以定义存储属性</li>
<li>枚举不可以定义存储属性<ul>
<li>关于枚举不可以定义存储属性，根据之前的<a href="https://juejin.im/post/5d1eeca3f265da1ba6480cc7" target="_blank" rel="noopener">Swift枚举</a>一文可知，<br>枚举中存储关联值或者keys，不存储属性的。</li>
</ul>
</li>
</ul>
<h4 id="关于存储属性，Swift有个明确的规定"><a href="#关于存储属性，Swift有个明确的规定" class="headerlink" title="关于存储属性，Swift有个明确的规定"></a>关于存储属性，Swift有个明确的规定</h4><ul>
<li>在创建类 或 结构体的实例时，必须为所有的存储属性设置一个合适的初始值<ul>
<li>可以在初始化器里为存储属性设置一个初始值</li>
<li>可以分配一个默认的属性值作为属性定义的一部分</li>
</ul>
</li>
</ul>
<p>关于这个规定，我们在<a href="https://juejin.im/post/5d216e1ff265da1bb27752aa" target="_blank" rel="noopener">Swift之结构体</a>   一文中已经说过了，这里稍微提一下，比如下面代码，x和y都是存储属性，当初始化的时候，如果没值，编译器会直接报错。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Point(x: 10, y: <span class="number">20</span>)</span><br><span class="line">var p2 = Point(y: <span class="number">20</span>) //报错 <span class="literal">Missing</span> argument <span class="keyword">for</span> parameter <span class="string">'x'</span> <span class="keyword">in</span> <span class="keyword">call</span></span><br><span class="line">var p3 = Point(x: <span class="number">10</span>) //报错 <span class="literal">Missing</span> argument <span class="keyword">for</span> parameter <span class="string">'y'</span> <span class="keyword">in</span> <span class="keyword">call</span></span><br><span class="line">var p4 = Point()    //报错 <span class="literal">Missing</span> argument <span class="keyword">for</span> parameter <span class="string">'x'</span> <span class="keyword">in</span> <span class="keyword">call</span></span><br></pre></td></tr></table></figure>

<h3 id="计算属性（Computed-Property）"><a href="#计算属性（Computed-Property）" class="headerlink" title="计算属性（Computed Property）"></a>计算属性（Computed Property）</h3><ul>
<li>本质就是方法（函数）</li>
<li>不占用实例的内存</li>
<li>枚举、结构体、类都可以定义计算属性</li>
<li>set传入的新值默认叫做newValue，也可以自定义</li>
</ul>
<p>如下面结构体<code>Circle</code>包括了存储属性<code>radius</code>和计算属性<code>diameter</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">truct Circle &#123;</span><br><span class="line">    <span class="comment">// 存储属性</span></span><br><span class="line">    var radius: Double</span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        <span class="built_in">set</span> &#123;</span><br><span class="line">            radius = newValue / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">get</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> radius * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="built_in">circle</span> = Circle(radius: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">circle</span>.radius) <span class="comment">// 5.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">circle</span>.diameter) <span class="comment">// 10.0</span></span><br><span class="line"><span class="built_in">circle</span>.diameter = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">circle</span>.radius) <span class="comment">// 6.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">circle</span>.diameter) <span class="comment">// 12.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只读计算属性：只有get，没有set<br>如下</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    var radius: Double</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        <span class="builtin-name">get</span> &#123;</span><br><span class="line">           <span class="built_in"> radius </span>* 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读计算属性可以简写，例如上面的代码可以如下表示</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    var radius: Double</span><br><span class="line">    var diameter: Double &#123;<span class="built_in"> radius </span>* 2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="计算属性不占用实例的内存"><a href="#计算属性不占用实例的内存" class="headerlink" title="计算属性不占用实例的内存"></a>计算属性不占用实例的内存</h4><p>关于不占用实例的内存，可以如下代码证明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储属性</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">var</span> diameter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            radius = newValue / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> radius * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Double占用字节"</span>, <span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.<span class="built_in">stride</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Circle占用字节"</span>,<span class="type">MemoryLayout</span>&lt;<span class="type">Circle</span>&gt;.<span class="built_in">stride</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Double占用字节 <span class="number">8</span></span><br><span class="line">Circle占用字节 <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>也就是说<code>Circle</code>占用的仅仅是其存储属性<code>radius</code>所占用的内存。和计算属性无关的，读者也可以多写几个计算属性，自行验证。</p>
<h3 id="汇编分析存储属性和计算属性的区别"><a href="#汇编分析存储属性和计算属性的区别" class="headerlink" title="汇编分析存储属性和计算属性的区别"></a>汇编分析存储属性和计算属性的区别</h3><p>代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    <span class="comment">// 存储属性</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="built_in">Int</span></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">var</span> diameter: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            radius = newValue / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> radius * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> circle = Circle(radius: <span class="number">9</span>)</span><br><span class="line">circle.radius = <span class="number">5</span> </span><br><span class="line">circle.diameter = <span class="number">8</span> <span class="comment">//这里打断点</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad12510f0?w=1114&h=800&f=png&s=400156" alt=""></p>
<ul>
<li><p>5存储到了全局变量<code>0x3e96(%rip)</code>,全局变量只有<code>circle</code>，所以也就是说存储属性的值，被直接放在了结构体的内存中。</p>
</li>
<li><p>8赋值给寄存器<code>%r8d</code>，又给寄存器%edi，作为参数调用函数<code>0x100001ae0</code>的时候传入，而函数<code>0x100001ae0</code>就是<code>testSwift.Circle.diameter.setter</code>这就是存储属性和计算属性的区别</p>
</li>
</ul>
<h2 id="枚举rawValue的原理"><a href="#枚举rawValue的原理" class="headerlink" title="枚举rawValue的原理"></a>枚举rawValue的原理</h2><p>在<a href="https://juejin.im/post/5d1eeca3f265da1ba6480cc7" target="_blank" rel="noopener">Swift枚举</a>一文中，我们说过枚举原始值是不占用内存的。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span>: <span class="title">Int</span>&#123;</span></span><br><span class="line">    <span class="keyword">case</span> test1 = <span class="number">1</span>, test2, test3, test4</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = Season.test2</span><br><span class="line">print(s.rawValue) /<span class="regexp">/输出2</span></span><br></pre></td></tr></table></figure>

<p>上面代码输出为2。<br>这些原始值 test1 = 1, test2, test3, test4，系统内部完全可以写成只读计算属性</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span>: <span class="title">Int</span>&#123;</span></span><br><span class="line">    <span class="keyword">case</span> test1 = <span class="number">1</span>, test2, test3, test4</span><br><span class="line">    </span><br><span class="line">    var rawValue : Int &#123;</span><br><span class="line">        switch <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="symbol">test1:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="symbol">test2:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="symbol">test3:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="symbol">test4:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">14</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = Season.test2</span><br><span class="line">print(s.rawValue) /<span class="regexp">/输出12</span></span><br></pre></td></tr></table></figure>

<p>上面代码输出为12，这样就完成了获取枚举的原始值的时候，直接获取的是只读计算属性。光看结果是不够令人信服的，那就看汇编</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span>: <span class="title">Int</span>&#123;</span></span><br><span class="line">    <span class="keyword">case</span> test1 = <span class="number">1</span>, test2, test3, test4</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = Season.test2</span><br><span class="line">print(s.rawValue) /<span class="regexp">/这里打断点</span></span><br></pre></td></tr></table></figure>

<p>上述代码在最后一行打断点</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad1350252?w=1077&h=611&f=png&s=261495" alt=""></p>
<p>可以看到，确实调用了<code>rawValue.getter</code>。</p>
<p>所以汇编才是看出本质的神器。</p>
<h2 id="延迟存储属性（Lazy-Stored-Property）"><a href="#延迟存储属性（Lazy-Stored-Property）" class="headerlink" title="延迟存储属性（Lazy Stored Property）"></a>延迟存储属性（Lazy Stored Property）</h2><h3 id="使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化"><a href="#使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化" class="headerlink" title="使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化"></a>使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化</h3><ul>
<li>lazy属性必须是var，不能是let<ul>
<li>let必须在实例的初始化方法完成之前就拥有值</li>
</ul>
</li>
<li>如果多条线程同时第一次访问lazy属性<ul>
<li>无法保证属性只被初始化1次</li>
</ul>
</li>
</ul>
<p>eg:有类 Car和类Person ，car作为Person的延迟存储属性，那么当使用car的是，才会调用car的初始化方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Car init!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Car is running!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> car = <span class="type">Car</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person init!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">goOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">        car.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="type">Person</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------"</span>)</span><br><span class="line">p.goOut()</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Person init!</span><br><span class="line">--------</span><br><span class="line">Car init!</span><br><span class="line">Car is running!</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h3><ul>
<li>当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性<ul>
<li>因为延迟属性初始化时需要改变结构体的内存</li>
</ul>
</li>
</ul>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><ul>
<li>可以为非lazy的var存储属性设置属性观察器</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSet"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSet"</span>, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = <span class="number">1.0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Circle init!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> circle = <span class="type">Circle</span>()<span class="comment">// 输出 Circle init!</span></span><br><span class="line"></span><br><span class="line">circle.radius = <span class="number">10.5</span> </span><br><span class="line"><span class="comment">// 输出 willSet 10.5 </span></span><br><span class="line"><span class="comment">// didSet 1.0 10.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(circle.radius) <span class="comment">//输出 10.5</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>willSet会传递新值，默认叫newValue</li>
<li>didSet会传递旧值，默认叫oldValue</li>
<li>在初始化器中设置属性值不会触发willSet和didSet</li>
<li>在属性定义时设置初始值也不会触发willSet和didSet</li>
</ul>
<h2 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h2><ul>
<li>属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量身上</li>
</ul>
<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"setNum"</span>, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num = <span class="number">11</span> <span class="comment">// setNum 11</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSet"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSet"</span>, oldValue, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    age = <span class="number">11</span></span><br><span class="line">    <span class="comment">// willSet 11</span></span><br><span class="line">    <span class="comment">// didSet 10 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<h2 id="类型属性（Type-Property）"><a href="#类型属性（Type-Property）" class="headerlink" title="类型属性（Type Property）"></a>类型属性（Type Property）</h2><h3 id="类型属性分类"><a href="#类型属性分类" class="headerlink" title="类型属性分类"></a>类型属性分类</h3><ol>
<li>实例属性（Instance Property）：只能通过实例去访问<ul>
<li>存储实例属性（Stored Instance Property）：存储在实例的内存中，每个实例都有1份</li>
<li>计算实例属性（Computed Instance Property）</li>
</ul>
</li>
<li>类型属性（Type Property）：只能通过类型去访问<ul>
<li>存储类型属性（Stored Type Property）：整个程序运行过程中，就只有1份内存（类似于全局变量）</li>
<li>计算类型属性（Computed Type Property）</li>
</ul>
</li>
<li>可以通过static定义类型属性<ul>
<li>如果是类，也可以用关键字class</li>
</ul>
</li>
</ol>
<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">Car</span>.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="type">Car</span>()</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="type">Car</span>()</span><br><span class="line"><span class="keyword">let</span> c3 = <span class="type">Car</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="type">Car</span>.<span class="built_in">count</span>) <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>


<h3 id="类型属性细节"><a href="#类型属性细节" class="headerlink" title="类型属性细节"></a>类型属性细节</h3><ol>
<li>不同于存储实例属性，你必须给存储类型属性设定初始值<ul>
<li>因为类型没有像实例那样的init初始化器来初始化存储属性</li>
</ul>
</li>
<li>存储类型属性默认就是lazy，会在第一次使用的时候才初始化<ul>
<li>就算被多个线程同时访问，保证只会初始化一次</li>
<li>存储类型属性可以是let</li>
</ul>
</li>
<li>枚举类型也可以定义类型属性（存储类型属性、计算类型属性）</li>
</ol>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>关于单例模式，可以参考我的另一篇文章<a href="https://juejin.im/post/5d295106e51d45105d63a5b2" target="_blank" rel="noopener">你真的懂单例模式么</a></p>
<p>不同语言的单例模式，都是类似的，这里给出Swift版本单例的实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">FileManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果单例里面代码过多，可以写成如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汇编分析-static"><a href="#汇编分析-static" class="headerlink" title="汇编分析 static"></a>汇编分析 static</h2><p>下面的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">3</span> <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">YZPerson</span>.<span class="built_in">count</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如下图所示，可以看出，会调用 <code>swift_once</code>函数，来到这个调用位置，si汇编调试指令，一直跟进去</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad15fe540?w=1950&h=678&f=png&s=272688" alt=""></p>
<p>最终会来到这里，调用<code>dispatch_once_f</code><br><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad1e7961e?w=1932&h=790&f=png&s=288329" alt=""></p>
<p>也就是说<code>static</code>内部封装了<code>dispatch_once_</code> 而<code>dispatch_once_</code>能保证线程安全的，只能被初始化一次，所以单例的时候可以用<code>static</code> 关于 <code>dispatch_once</code>的分析，可以看这篇文章<a href="https://juejin.im/post/5d295106e51d45105d63a5b2" target="_blank" rel="noopener">你真的懂单例模式么</a></p>
<ul>
<li>同样的，我们可以从代码角度，汇编角度分别证明 <code>static</code> 修饰的变量，属于全局变量。读者有兴趣自己证明。这里不再赘述。</li>
</ul>
<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
<p><a href="https://juejin.im/post/5d295106e51d45105d63a5b2" target="_blank" rel="noopener">你真的懂单例模式么</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之通过汇编探究闭包本质</title>
    <url>/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8E%A2%E7%A9%B6%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8E%A2%E7%A9%B6%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8.html">我的个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先回顾一下，上一篇  <a href="https://juejin.im/post/5d229738f265da1b715317b7" target="_blank" rel="noopener">Swift之闭包(Closure)</a>中对闭包的解释</p>
<ul>
<li>一个函数和它所捕获的变量\常量环境组合起来，称为闭包<ul>
<li>一般指定义在函数内部的函数</li>
<li>一般它捕获的是外层函数的局部变量\常量</li>
</ul>
</li>
<li>可以把闭包想象成是一个类的实例对象<ul>
<li>内存在堆空间</li>
<li>捕获的局部变量\常量就是对象的成员(存储属性) </li>
<li>组成闭包的函数就是类内部定义的方法</li>
</ul>
</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先看下面一段代码，猜猜会输出什么</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">typealias <span class="function"><span class="keyword">Fn</span> </span>= (Int) -&gt; Int</span><br><span class="line">func <span class="built_in">getFn</span>() -&gt; <span class="function"><span class="keyword">Fn</span>&#123;</span></span><br><span class="line"><span class="function">    // 局部变量</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">num</span> </span>= <span class="number">0</span></span><br><span class="line">    func <span class="built_in">plus</span>(_ i: Int) -&gt; Int&#123;</span><br><span class="line">        num += i</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">plus</span>(_:)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="function"><span class="keyword">fn</span> </span>= <span class="built_in">getFn</span>()</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">1</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">2</span>))	<span class="comment">// 3</span></span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">3</span>))	<span class="comment">// 6</span></span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">4</span>))	<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>结果是输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>那么，问题来了，为什么输出的是10呢？因为按照常识，var num = 0 是局部变量，执行完就销毁了，怎么能再后面继续使用呢？</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们先从简单的说起<br>首先是下面一端代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Fn</span> = (<span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFn</span><span class="params">()</span></span> -&gt; <span class="type">Fn</span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(<span class="number">_</span> i: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plus(<span class="number">_</span>:) <span class="comment">// 这里打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = getFn()</span><br><span class="line"><span class="built_in">print</span>(fn(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>先不适用num ,直接 return i 并在这里打断点，结果如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">testSwift`getFn():</span><br><span class="line">    <span class="number">0x100001f70</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001f71</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001f74</span> &lt;+<span class="number">4</span>&gt;:  movq   $<span class="number">0x0</span>, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">-&gt;  <span class="number">0x100001f7c</span> &lt;+<span class="number">12</span>&gt;: leaq   <span class="number">0xd</span>(%rip), %rax           ; plus #<span class="number">1</span> (Swift.Int) -&gt; Swift.Int <span class="keyword">in</span> testSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at main.swift:<span class="number">23</span></span><br><span class="line">    <span class="number">0x100001f83</span> &lt;+<span class="number">19</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0x100001f85</span> &lt;+<span class="number">21</span>&gt;: movl   %ecx, %edx</span><br><span class="line">    <span class="number">0x100001f87</span> &lt;+<span class="number">23</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001f88</span> &lt;+<span class="number">24</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/7/8/16bcf1fb505d92c2?w=1243&h=825&f=png&s=356842" alt=""></p>
<p>可知，0xd(%rip), %rax  这段代码，把地址值，也就是getFn() 函数的地址值给了rax,<br>根本没有alloc malloc等代码，也就是说，没有开辟堆空间。那么接下来我们看下面的代码</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">typealias <span class="function"><span class="keyword">Fn</span> </span>= (Int) -&gt; Int</span><br><span class="line">func <span class="built_in">getFn</span>() -&gt; <span class="function"><span class="keyword">Fn</span>&#123;</span></span><br><span class="line"><span class="function">    // 局部变量</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">num</span> </span>= <span class="number">0</span></span><br><span class="line">    func <span class="built_in">plus</span>(_ i: Int) -&gt; Int&#123;</span><br><span class="line">		 num += i</span><br><span class="line">		 <span class="keyword">return</span> num </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">plus</span>(_:) <span class="comment">// 这里打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="function"><span class="keyword">fn</span> </span>= <span class="built_in">getFn</span>()</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>断点如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">testSwift`getFn():</span><br><span class="line">    <span class="number">0x100001de0</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001de1</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001de4</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100001de8</span> &lt;+<span class="number">8</span>&gt;:  leaq   <span class="number">0x3301</span>(%rip), %rdi</span><br><span class="line">    <span class="number">0x100001def</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x18</span>, %esi</span><br><span class="line">    <span class="number">0x100001df4</span> &lt;+<span class="number">20</span>&gt;: movl   $<span class="number">0x7</span>, %edx</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里swift_allocObject 说明产生了堆空间</span></span><br><span class="line">    <span class="number">0x100001df9</span> &lt;+<span class="number">25</span>&gt;: callq  <span class="number">0x1000046f8</span>        ; symbol stub <span class="keyword">for</span>: swift_allocObject</span><br><span class="line">    <span class="number">0x100001dfe</span> &lt;+<span class="number">30</span>&gt;: movq   %rax, %rdx</span><br><span class="line">    <span class="number">0x100001e01</span> &lt;+<span class="number">33</span>&gt;: addq   $<span class="number">0x10</span>, %rdx</span><br><span class="line">    <span class="number">0x100001e05</span> &lt;+<span class="number">37</span>&gt;: movq   %rdx, %rsi</span><br><span class="line">    <span class="number">0x100001e08</span> &lt;+<span class="number">40</span>&gt;: movq   $<span class="number">0x0</span>, <span class="number">0x10</span>(%rax)</span><br><span class="line">-&gt;  <span class="number">0x100001e10</span> &lt;+<span class="number">48</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x100001e13</span> &lt;+<span class="number">51</span>&gt;: movq   %rax, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001e17</span> &lt;+<span class="number">55</span>&gt;: movq   %rdx, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001e1b</span> &lt;+<span class="number">59</span>&gt;: callq  <span class="number">0x100004758</span>         ; symbol stub <span class="keyword">for</span>: swift_retain</span><br><span class="line">    <span class="number">0x100001e20</span> &lt;+<span class="number">64</span>&gt;: movq   <span class="number">-0x8</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x100001e24</span> &lt;+<span class="number">68</span>&gt;: movq   %rax, <span class="number">-0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001e28</span> &lt;+<span class="number">72</span>&gt;: callq  <span class="number">0x100004752</span>         ; symbol stub <span class="keyword">for</span>: swift_release</span><br><span class="line">    <span class="number">0x100001e2d</span> &lt;+<span class="number">77</span>&gt;: movq   <span class="number">-0x10</span>(%rbp), %rax</span><br><span class="line">    <span class="number">0x100001e31</span> &lt;+<span class="number">81</span>&gt;: leaq   <span class="number">0x178</span>(%rip), %rax   ; partial apply forwarder <span class="keyword">for</span> plus #<span class="number">1</span> (Swift.Int) -&gt; Swift.Int <span class="keyword">in</span> testSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at &lt;compiler-generated&gt;</span><br><span class="line">    <span class="number">0x100001e38</span> &lt;+<span class="number">88</span>&gt;: movq   <span class="number">-0x8</span>(%rbp), %rdx</span><br><span class="line">    <span class="number">0x100001e3c</span> &lt;+<span class="number">92</span>&gt;: addq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100001e40</span> &lt;+<span class="number">96</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001e41</span> &lt;+<span class="number">97</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p>进一步验证，下面的代码是因为，写文章的时候，重新跑了一遍，所以函数 getFn() 函数的抵制和截图不一致，是</p>
<blockquote>
<p>rax = 0x0000000101849fd0</p>
</blockquote>
<p>这次我们在 </p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">typealias <span class="function"><span class="keyword">Fn</span> </span>= (Int) -&gt; Int</span><br><span class="line">func <span class="built_in">getFn</span>() -&gt; <span class="function"><span class="keyword">Fn</span>&#123;</span></span><br><span class="line"><span class="function">    // 局部变量</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">num</span> </span>= <span class="number">0</span></span><br><span class="line">    func <span class="built_in">plus</span>(_ i: Int) -&gt; Int&#123;</span><br><span class="line">		 num += i</span><br><span class="line">		 <span class="keyword">return</span> num  <span class="comment">// 第二次这里打断点 查看getFn()地址的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">plus</span>(_:) <span class="comment">// 第一次这里打断点 获取getFn()地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="function"><span class="keyword">fn</span> </span>= <span class="built_in">getFn</span>()</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">1</span>)) </span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>因为调用了三次 fn分别为 fn(1) 、 fn(2)、fn(3)，所以在 return num 地方，会断三次<br>我们分别查看函数getFn() 函数地址的内容</p>
<p>结果如图<br><img src="https://user-gold-cdn.xitu.io/2019/7/8/16bcf1fb506737cb?w=1139&h=886&f=png&s=362546" alt=""></p>
<p>图中可知，确实是操作同一块堆空间，而且之前<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%B1%BB.html">Swift之类</a>中讲过，前面16个字节，分别存放 类的信息，引用技术，然后后面才是值，可知，</p>
<p>刚开始分配完，堆空间里面是垃圾数据<br>执行完 print(fn(1))  之后，堆空间里面放的是1<br>执行完 print(fn(2))  之后，堆空间里面放的是3<br>执行完 print(fn(3))  之后，堆空间里面放的是6</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这也解释了，文章开头的那个疑问，因为闭包捕获了局部变量，在堆中开辟空间，然后后面调用的时候，操作的是堆空间的内存，所以结果是</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>关于汇编的调试指令可以参考</p>
<p><a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93.html">汇编总结</a></p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
<p><a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93.html">汇编总结</a></p>
<p><a href="https://juejin.im/post/5d229738f265da1b715317b7" target="_blank" rel="noopener">Swift之闭包(Closure)</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之闭包(Closure)</title>
    <url>/Swift%E4%B9%8B%E9%97%AD%E5%8C%85(Closure).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E9%97%AD%E5%8C%85(Closure).html">我的个人博客</a></p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><ul>
<li>一个函数和它所捕获的变量\常量环境组合起来，称为闭包<ul>
<li>一般指定义在函数内部的函数</li>
<li>一般它捕获的是外层函数的局部变量\常量</li>
</ul>
</li>
<li>可以把闭包想象成是一个类的实例对象<ul>
<li>内存在堆空间</li>
<li>捕获的局部变量\常量就是对象的成员(存储属性) </li>
<li>组成闭包的函数就是类内部定义的方法</li>
</ul>
</li>
</ul>
<p>eg:<br>我们有一个函数 sum</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> v1: Int, <span class="number">_</span> v2: Int)</span></span> -&gt; <span class="type">Int</span> &#123; v1 + v2 &#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>如果用闭包表达式定义一个函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = &#123;</span><br><span class="line">    (v1: <span class="built_in">Int</span>, v2: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">fn(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>当然了，也可以</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (v1: <span class="built_in">Int</span>, v2: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>总结起来就是</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="params">(参数列表)</span> -&gt;</span> 返回值类型 <span class="keyword">in</span> 函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包表达式的简写"><a href="#闭包表达式的简写" class="headerlink" title="闭包表达式的简写"></a>闭包表达式的简写</h2><p>我们定义如下的函数 exec ，它接收三个参数，分别为两个Int 和一个函数，而且这个函数，接收两个Int 参数，返回一个Int结果，exec 的作用就是，把前两个参数传给第三个参数(也就是函数)去执行，然后结果打印出来</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 函数 我们定义如下的函数 exec ，它接收三个参数，分别为两个<span class="built_in">Int</span> 和一个函数，而且这个函数，接收两个<span class="built_in">Int</span> 参数，返回一个<span class="built_in">Int</span>结果，exec 的作用就是，把前两个参数传给第三个参数(也就是函数)去执行，然后结果打印出来</span><br><span class="line">func exec(v1: <span class="built_in">Int</span>, v2: <span class="built_in">Int</span>, fn: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(fn(v1, v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用闭包表达式来定义的话</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">	// 闭包表达式</span><br><span class="line"><span class="symbol">exec</span>(<span class="built_in">v1</span>: <span class="number">10</span>, <span class="built_in">v2</span>: <span class="number">20</span>, <span class="meta">fn</span>: &#123;</span><br><span class="line">    (<span class="built_in">v1</span>: Int, <span class="built_in">v2</span>: Int) -&gt; Int in</span><br><span class="line">    return <span class="built_in">v1</span> + <span class="built_in">v2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然了，我们可以省略很多，如下</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 省略参数类型 因为<span class="keyword">swift可以自己推断类型</span></span><br><span class="line"><span class="keyword">exec(v1: </span><span class="number">10</span>, <span class="built_in">v2</span>: <span class="number">20</span>, <span class="meta">fn</span>: &#123;</span><br><span class="line">    <span class="built_in">v1</span>, <span class="built_in">v2</span> in return <span class="built_in">v1</span> + <span class="built_in">v2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// return 也可以省略</span><br><span class="line"><span class="symbol">exec</span>(<span class="built_in">v1</span>: <span class="number">10</span>, <span class="built_in">v2</span>: <span class="number">20</span>, <span class="meta">fn</span>: &#123;</span><br><span class="line">    <span class="built_in">v1</span>, <span class="built_in">v2</span> in <span class="built_in">v1</span> + <span class="built_in">v2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 省略掉参数列表，用<span class="number">$0</span>代表第<span class="number">0</span>个参数，<span class="number">$1</span>代表第<span class="number">1</span>个参数</span><br><span class="line"><span class="symbol">exec</span>(<span class="built_in">v1</span>: <span class="number">10</span>, <span class="built_in">v2</span>: <span class="number">20</span>, <span class="meta">fn</span>: &#123;</span><br><span class="line">    <span class="number">$0</span> + <span class="number">$1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 终极省略</span><br><span class="line"><span class="symbol">exec</span>(<span class="built_in">v1</span>: <span class="number">10</span>, <span class="built_in">v2</span>: <span class="number">20</span>, <span class="meta">fn</span>: +)</span><br></pre></td></tr></table></figure>

<h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul>
<li>如果将一个很长的闭包表达式作为函数的最后一个实参，使用尾随闭包可以增强函数的可读性<ul>
<li>尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式</li>
</ul>
</li>
</ul>
<p>有如下的函数 闭包表达式作为函数的最后一个实参</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">(v1: Int, v2: Int, fn: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(fn(v1, v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用尾随闭包为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">exec(v1: <span class="number">10</span>, v2: <span class="number">20</span>) &#123;</span><br><span class="line">    $<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，那就不需要在函数名后边写圆括号</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这个闭包表达式表达式是函数的唯一实参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">(fn: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>) &#123; </span><br><span class="line">	<span class="built_in">print</span>(fn(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用尾随闭包如下</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用尾随闭包如下三种都可以</span></span><br><span class="line"><span class="keyword">exec</span>(fn: &#123; $0 + $1 &#125;)</span><br><span class="line"><span class="keyword">exec</span>() &#123; $0 + $1 &#125;</span><br><span class="line"><span class="keyword">exec</span> &#123; $0 + $1 &#125;</span><br></pre></td></tr></table></figure>


<h2 id="尾随闭包实战"><a href="#尾随闭包实战" class="headerlink" title="尾随闭包实战"></a>尾随闭包实战</h2><h3 id="系统自带的排序"><a href="#系统自带的排序" class="headerlink" title="系统自带的排序"></a>系统自带的排序</h3><p>假设我们有个包含Int元素的数组，想对立面的元素进行排序</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberSort</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line">    arr.<span class="built_in">sort</span>()</span><br><span class="line">    <span class="built_in">print</span>(arr) <span class="comment">//[1, 6, 8, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numberSort()</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<blockquote>
<p>[1, 6, 8, 10]</p>
</blockquote>
<p>查看官方对sort的源码为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 官方代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(by areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><p>假如我们想自定义排序</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/// 返回<span class="keyword">true</span>: <span class="keyword">i1</span>排在<span class="keyword">i2</span>前面</span><br><span class="line">/// 返回<span class="keyword">false</span>: <span class="keyword">i1</span>排在<span class="keyword">i2</span>后面</span><br><span class="line">func cmp(<span class="keyword">i1</span>: Int, <span class="keyword">i2</span>: Int) -&gt; Bool &#123;</span><br><span class="line">    // 大的排在前面</span><br><span class="line">    return <span class="keyword">i1</span> &gt; <span class="keyword">i2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var nums = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line">nums.sort(by: cmp)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<blockquote>
<p>[10, 8, 6, 1]</p>
</blockquote>
<h3 id="用尾随闭包书写"><a href="#用尾随闭包书写" class="headerlink" title="用尾随闭包书写"></a>用尾随闭包书写</h3><p>上面的代码 </p>
<p>可以写成</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nums.sort(<span class="keyword">by</span>: &#123;</span><br><span class="line">    (i1: <span class="built_in">Int</span>, i2: <span class="built_in">Int</span>) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> i1 &gt; i2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以等价于下面几种</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nums.<span class="keyword">sort</span>(<span class="keyword">by</span>: &#123; i1, i2 <span class="keyword">in</span> <span class="keyword">return</span> i1 &gt; i2 &#125;)</span><br><span class="line">nums.<span class="keyword">sort</span>(<span class="keyword">by</span>: &#123; i1, i2 <span class="keyword">in</span> i1 &gt; i2 &#125;)</span><br><span class="line">nums.<span class="keyword">sort</span>(<span class="keyword">by</span>: &#123; <span class="variable">$0</span> &gt; <span class="variable">$1</span> &#125;)</span><br><span class="line">nums.<span class="keyword">sort</span>(<span class="keyword">by</span>: &gt; )</span><br><span class="line">nums.<span class="keyword">sort</span>() &#123; <span class="variable">$0</span> &gt; <span class="variable">$1</span> &#125;</span><br><span class="line">nums.<span class="keyword">sort</span> &#123; <span class="variable">$0</span> &gt; <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="忽略参数"><a href="#忽略参数" class="headerlink" title="忽略参数"></a>忽略参数</h2><p>Swift中，很多时候，如果我们对于参数不做处理，可以用 下划线 _ 来代替</p>
<p>例如下面的闭包</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func <span class="built_in">exec</span>(fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    <span class="keyword">print</span>(<span class="keyword">fn</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">exec</span>&#123;_,_ in <span class="number">100</span> &#125;)  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>输出  </p>
<blockquote>
<p>100</p>
</blockquote>
<h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>假设我们定义一个这样的函数，要求 如果第1个数大于0，返回第一个数。否则返回第2个数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func getFirstPositive(_ v1: Int, _ v2:  Int) -&gt; Int? &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; <span class="number">0</span> ? v1 : v2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">getFirstPositive(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 10</span></span><br><span class="line">getFirstPositive(<span class="number">-2</span>, <span class="number">20</span>) <span class="comment">// 20</span></span><br><span class="line">getFirstPositive(<span class="number">0</span>, <span class="number">-4</span>) <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>

<p>现在假如说，我们这么传入的话</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="comment">// 这里每次都执行</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">200</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFirstPositive2</span><span class="params">(<span class="number">_</span> v1: Int, <span class="number">_</span> v2:  Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; <span class="number">0</span> ? v1 : v2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(<span class="number">10</span>, getNum())</span><br></pre></td></tr></table></figure>

<h3 id="改成函数类型的参数"><a href="#改成函数类型的参数" class="headerlink" title="改成函数类型的参数"></a>改成函数类型的参数</h3><p>因为第一个参数已经是10 大于0了，第二个参数，也就是getNum() 根本没必要去执行，浪费性能，所以，有没有什么办法能做到，当第一个参数不满足时候，才去执行getNum()呢？答案是有的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改成函数类型的参数，可以让v2延迟加载</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFirstPositive2</span><span class="params">(<span class="number">_</span> v1: Int, <span class="number">_</span> v2: <span class="params">()</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">	<span class="comment">// 这里判断 v1 &gt; 0 不会调用 v2()</span></span><br><span class="line">    <span class="keyword">return</span> v1 &gt; <span class="number">0</span> ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(<span class="number">10</span>, &#123;</span><br><span class="line">	<span class="comment">// 第一个参数大于0的时候，这里不会执行</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">200</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>如果改成这样写就报错了</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">/ 改成函数类型的参数，可以让v2延迟加载</span><br><span class="line">func getFirstPositive2(_ v1: <span class="type">Int</span>, _ v2: () -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">	// 这里判断 v1 &gt; <span class="number">0</span> 不会调用 v2()</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; <span class="number">0</span> ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(<span class="number">10</span>,  <span class="number">20</span>) //报错 Cannot convert <span class="keyword">value</span> <span class="keyword">of</span> <span class="keyword">type</span> <span class="string">'Int'</span> <span class="keyword">to</span> expected argument <span class="keyword">type</span> <span class="string">'() -&gt; Int'</span></span><br></pre></td></tr></table></figure>

<p>因为需要的是() -&gt; Int类型，给的是Int</p>
<p>我们可以写成下面两种都可以</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/ 改成函数类型的参数，可以让v2延迟加载</span><br><span class="line">func getFirstPositive2(_ v1: Int, _ v2: () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">	// 这里判断 v1 &gt; 0 不会调用 v2()</span><br><span class="line">   <span class="built_in"> return </span>v1 &gt; 0 ? v1<span class="keyword"> :</span> v2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10) &#123; 20&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10, &#123;20&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="autoclosure"><a href="#autoclosure" class="headerlink" title="@autoclosure"></a>@autoclosure</h3><p>上面的也可以用自动闭包技术</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">getFirstPositive3</span>(_ <span class="attribute">v1</span>: Int, _ <span class="attribute">v2</span>: <span class="variable">@autoclosure</span> () -&gt; Int) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Int</span>? &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">v1</span> &gt; <span class="selector-tag">0</span> ? <span class="selector-tag">v1</span> : <span class="selector-tag">v2</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">getFirstPositive3</span>(-<span class="number">4</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="需要的注意点："><a href="#需要的注意点：" class="headerlink" title="需要的注意点："></a>需要的注意点：</h3><ul>
<li>为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行</li>
<li>@autoclosure 会自动将 20 封装成闭包 { 20 }</li>
<li>@autoclosure 只支持 () -&gt; T 格式的参数 n@autoclosure 并非只支持最后1个参数</li>
<li>空合并运算符 ?? 使用了 @autoclosure 技术</li>
<li>有@autoclosure、无@autoclosure，构成了函数重载</li>
</ul>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之结构体</title>
    <url>/Swift%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift之结构体.html">我的个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分 <ul>
<li>比如Bool、Int、Double、 String、Array、Dictionary等常见类型都是结构体</li>
</ul>
</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">struct <span class="built_in">Date</span> &#123;</span><br><span class="line">	var <span class="built_in">year</span>: <span class="built_in">Int</span>		</span><br><span class="line">	var <span class="built_in">month</span>: <span class="built_in">Int</span></span><br><span class="line">	var <span class="built_in">day</span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line">var <span class="built_in">date</span> = <span class="built_in">Date</span>(<span class="built_in">year</span>: <span class="number">2019</span>, <span class="built_in">month</span>: <span class="number">6</span>, <span class="built_in">day</span>: <span class="number">23</span>)</span><br></pre></td></tr></table></figure>


<ul>
<li>所有的结构体都有一个编译器自动生成的初始化器(initializer，初始化方法、构造器、构造方法) <ul>
<li>在最后一行调用的，可以传入所有成员值，用以初始化所有成员(存储属性，Stored Property)</li>
</ul>
</li>
</ul>
<h2 id="结构体的初始化器"><a href="#结构体的初始化器" class="headerlink" title="结构体的初始化器"></a>结构体的初始化器</h2><ul>
<li>编译器会根据情况，可能会为结构体生成多个初始化器，宗旨是:保证所有成员都有初始值</li>
</ul>
<p>eg:</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Point(x: 10, y: <span class="number">20</span>)</span><br><span class="line">var p2 = Point(y: <span class="number">20</span>) //报错 <span class="literal">Missing</span> argument <span class="keyword">for</span> parameter <span class="string">'x'</span> <span class="keyword">in</span> <span class="keyword">call</span></span><br><span class="line">var p3 = Point(x: <span class="number">10</span>) //报错 <span class="literal">Missing</span> argument <span class="keyword">for</span> parameter <span class="string">'y'</span> <span class="keyword">in</span> <span class="keyword">call</span></span><br><span class="line">var p4 = Point()    //报错 <span class="literal">Missing</span> argument <span class="keyword">for</span> parameter <span class="string">'x'</span> <span class="keyword">in</span> <span class="keyword">call</span></span><br></pre></td></tr></table></figure>

<p>如果给定一个初始值</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">y</span>: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Point(<span class="symbol">x</span>: <span class="number">10</span>, <span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = Point(<span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = Point(<span class="symbol">x</span>: <span class="number">10</span>) <span class="comment">//报错 Missing argument for parameter 'y' in call</span></span><br><span class="line"><span class="keyword">var</span> p4 = Point()    <span class="comment">//报错 Missing argument for parameter 'y' in call</span></span><br></pre></td></tr></table></figure>

<p>如果x 和 y都有初始值的话，就怎么都不会报错了，因为 所有成员都有初始值</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">y</span>: Int = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Point(<span class="symbol">x</span>: <span class="number">10</span>, <span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = Point(<span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = Point(<span class="symbol">x</span>: <span class="number">10</span>) </span><br><span class="line"><span class="keyword">var</span> p4 = Point()</span><br></pre></td></tr></table></figure>

<p>初始值为nil的话，也可以编译通过，比如下面这种</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int?</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">y</span>: Int?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Point(<span class="symbol">x</span>: <span class="number">10</span>, <span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = Point(<span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p3 = Point(<span class="symbol">x</span>: <span class="number">10</span>) </span><br><span class="line"><span class="keyword">var</span> p4 = Point()</span><br></pre></td></tr></table></figure>

<h2 id="自定义初始化器"><a href="#自定义初始化器" class="headerlink" title="自定义初始化器"></a>自定义初始化器</h2><ul>
<li>一旦在定义结构体时自定义了初始化器，编译器就不会再帮它自动生成其他初始化器</li>
</ul>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">y</span>: Int = <span class="number">20</span></span><br><span class="line">    init(<span class="symbol">x</span>: Int, <span class="symbol">y</span>: Int) &#123;</span><br><span class="line">        <span class="literal">self</span>.<span class="symbol">x</span> = <span class="symbol">x</span></span><br><span class="line">        <span class="literal">self</span>.<span class="symbol">y</span> = <span class="symbol">y</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Point(<span class="symbol">x</span>: <span class="number">10</span>, <span class="symbol">y</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = Point(<span class="symbol">y</span>: <span class="number">20</span>) <span class="comment">//报错 Missing argument for parameter 'x' in call</span></span><br><span class="line"><span class="keyword">var</span> p3 = Point(<span class="symbol">x</span>: <span class="number">10</span>) <span class="comment">//报错 Missing argument for parameter 'y' in call</span></span><br><span class="line"><span class="keyword">var</span> p4 = Point()    <span class="comment">//报错 Missing argument for parameter 'x' in call</span></span><br></pre></td></tr></table></figure>

<h2 id="窥探初始化器的本质"><a href="#窥探初始化器的本质" class="headerlink" title="窥探初始化器的本质"></a>窥探初始化器的本质</h2><h3 id="以下2段代码完全等效"><a href="#以下2段代码完全等效" class="headerlink" title="以下2段代码完全等效"></a>以下2段代码完全等效</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> <span class="symbol">y</span>: Int = <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">struct Point &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">y</span>: Int</span><br><span class="line">	init() &#123; </span><br><span class="line">		<span class="symbol">x</span>=<span class="number">0</span> </span><br><span class="line">		<span class="symbol">y</span>=<span class="number">0</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="type">Point</span>() <span class="comment">//这一行打断点</span></span><br><span class="line">    <span class="built_in">print</span>(p)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x: <span class="type">Int</span> </span><br><span class="line">        <span class="keyword">var</span> y: <span class="type">Int</span> </span><br><span class="line">     	 <span class="keyword">init</span>() &#123;</span><br><span class="line">           x=<span class="number">0</span></span><br><span class="line">            y=<span class="number">0</span></span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="type">Point</span>() <span class="comment">//这一行打断点</span></span><br><span class="line">    <span class="built_in">print</span>(p)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>查看汇编，两段代码都是</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">testSwift`init() <span class="keyword">in</span> Point #<span class="number">1</span> <span class="keyword">in</span> test():</span><br><span class="line">-&gt;  <span class="number">0x100001d50</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001d51</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001d54</span> &lt;+<span class="number">4</span>&gt;:  xorps  %xmm0, %xmm0</span><br><span class="line">    <span class="number">0x100001d57</span> &lt;+<span class="number">7</span>&gt;:  movaps %xmm0, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001d5b</span> &lt;+<span class="number">11</span>&gt;: movq   $<span class="number">0x0</span>, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001d63</span> &lt;+<span class="number">19</span>&gt;: movq   $<span class="number">0x0</span>, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001d6b</span> &lt;+<span class="number">27</span>&gt;: xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100001d6d</span> &lt;+<span class="number">29</span>&gt;: movl   %eax, %ecx</span><br><span class="line">    <span class="number">0x100001d6f</span> &lt;+<span class="number">31</span>&gt;: movq   %rcx, %rax</span><br><span class="line">    <span class="number">0x100001d72</span> &lt;+<span class="number">34</span>&gt;: movq   %rcx, %rdx</span><br><span class="line">    <span class="number">0x100001d75</span> &lt;+<span class="number">37</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001d76</span> &lt;+<span class="number">38</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p>这两段代码的汇编一样的，也就是说，这两段代码完全等效</p>
<h2 id="结构体的内存结构"><a href="#结构体的内存结构" class="headerlink" title="结构体的内存结构"></a>结构体的内存结构</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">       <span class="selector-tag">var</span> x: Int = <span class="number">0</span></span><br><span class="line">       <span class="selector-tag">var</span> y: Int = <span class="number">0</span></span><br><span class="line">       <span class="selector-tag">var</span> origin: Bool = true</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(MemoryLayout&lt;Point&gt;.size)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(MemoryLayout&lt;Point&gt;.stride)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(MemoryLayout&lt;Point&gt;.alignment)</span></span></span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<blockquote>
<p>17</p>
</blockquote>
<blockquote>
<p>24</p>
</blockquote>
<blockquote>
<p>8</p>
</blockquote>
<p>是因为内存对齐的缘故，17是因为 实际使用的是 8+8+1 = 17<br>24 是因为，要内存对齐，8*3 = 24</p>
<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
<p><a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之类</title>
    <url>/Swift%E4%B9%8B%E7%B1%BB.html/</url>
    <content><![CDATA[<p>文章首发于<a href="https://ityongzhen.github.io/Swift之类.html">我的个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器<br>eg 如下代码不会报错</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point &#123;</span><br><span class="line">    var x: Int = <span class="number">0</span></span><br><span class="line">	var y: Int = <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="constructor">Point()</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="constructor">Point(<span class="params">x</span>: 10, <span class="params">y</span>: 20)</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="constructor">Point(<span class="params">x</span>: 10)</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="constructor">Point(<span class="params">y</span>: 20)</span></span><br></pre></td></tr></table></figure>

<p>但是如果改成了类就不能编译通过</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="type">Point</span> &#123;</span><br><span class="line">    var x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    var y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">let p1 = <span class="type">Point</span>()</span><br><span class="line">let p2 = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">20</span>)//报错Argument passed <span class="keyword">to</span> <span class="keyword">call</span> that takes <span class="keyword">no</span> arguments</span><br><span class="line">let p3 = <span class="type">Point</span>(x: <span class="number">10</span>)//报错Argument passed <span class="keyword">to</span> <span class="keyword">call</span> that takes <span class="keyword">no</span> arguments</span><br><span class="line">let p4 = <span class="type">Point</span>(y: <span class="number">20</span>)//报错Argument passed <span class="keyword">to</span> <span class="keyword">call</span> that takes <span class="keyword">no</span> arguments</span><br></pre></td></tr></table></figure>


<h2 id="类的初始化器"><a href="#类的初始化器" class="headerlink" title="类的初始化器"></a>类的初始化器</h2><ul>
<li>如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器  </li>
<li>成员的初始化是在这个初始化器中完成的</li>
</ul>
<h3 id="以下2段代码完全等效"><a href="#以下2段代码完全等效" class="headerlink" title="以下2段代码完全等效"></a>以下2段代码完全等效</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> <span class="symbol">y</span>: Int = <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">struct Point &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">x</span>: Int</span><br><span class="line">    <span class="keyword">var</span> <span class="symbol">y</span>: Int</span><br><span class="line">	init() &#123; </span><br><span class="line">		<span class="symbol">x</span>=<span class="number">0</span> </span><br><span class="line">		<span class="symbol">y</span>=<span class="number">0</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体与类的本质区别"><a href="#结构体与类的本质区别" class="headerlink" title="结构体与类的本质区别"></a>结构体与类的本质区别</h2><h3 id="结构体是值类型-枚举也是值类型-，类是引用类型-指针类型"><a href="#结构体是值类型-枚举也是值类型-，类是引用类型-指针类型" class="headerlink" title="结构体是值类型(枚举也是值类型)，类是引用类型(指针类型)"></a>结构体是值类型(枚举也是值类型)，类是引用类型(指针类型)</h3><p>eg:我们有如下的结构体point 和类 size</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类size</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Point</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 size 接收类Size</span></span><br><span class="line"><span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line"><span class="comment">// 变量 point 接收结构体point</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure>

<p>我们假设 执行完test() 之后，point的内存地址为 0x10000 size的内存地址为 0x10010<br>可以用一幅图来表示</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bca935cf3172a9?w=923&h=410&f=png&s=139924" alt=""></p>
<p>上图表示，point是值拷贝，直接把  3 和 4 放在了point对应的内存中，而 指针变量size是引用拷贝，是放了 Size() 的指针 0x90000 ，而对应的 堆空间 0x90000中才真正的存放1和2，当然了，前面有16个字节，存放了类的信息，和引用计数，因为Swift和OC一样使用的引用计数来内存管理的，所以Size对象用了32个字节</p>
<h3 id="汇编验证"><a href="#汇编验证" class="headerlink" title="汇编验证"></a>汇编验证</h3><p>代码如下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">unc test1()&#123;</span><br><span class="line">    <span class="comment">// 类size</span></span><br><span class="line">    class Size &#123;</span><br><span class="line">        <span class="selector-tag">var</span> <span class="attribute">width</span> = <span class="number">1</span></span><br><span class="line">        <span class="selector-tag">var</span> <span class="attribute">height</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类 Point</span></span><br><span class="line">    struct Point &#123;</span><br><span class="line">        <span class="selector-tag">var</span> x = <span class="number">3</span></span><br><span class="line">        <span class="selector-tag">var</span> y = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 变量 point 接收结构体point</span></span><br><span class="line">    <span class="selector-tag">var</span> point = Point()</span><br><span class="line">     <span class="comment">// 变量 size 接收类Size</span></span><br><span class="line">    <span class="selector-tag">var</span> size = Size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">test1</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h4 id="汇编验证验证结构体"><a href="#汇编验证验证结构体" class="headerlink" title="汇编验证验证结构体"></a>汇编验证验证结构体</h4><p>上面的代码，先在 var point = Point() 处打断点</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">testSwift`__allocating_init() <span class="keyword">in</span> Size #<span class="number">1</span> <span class="keyword">in</span> test1():</span><br><span class="line">    <span class="number">0x100001030</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001031</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001034</span> &lt;+<span class="number">4</span>&gt;:  pushq  %r13</span><br><span class="line">    <span class="number">0x100001036</span> &lt;+<span class="number">6</span>&gt;:  subq   $<span class="number">0x18</span>, %rsp</span><br><span class="line">    <span class="number">0x10000103a</span> &lt;+<span class="number">10</span>&gt;: xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x10000103c</span> &lt;+<span class="number">12</span>&gt;: movl   %eax, %edi</span><br><span class="line">-&gt;  <span class="number">0x10000103e</span> &lt;+<span class="number">14</span>&gt;: callq  <span class="number">0x100001250</span>               ; type metadata accessor <span class="keyword">for</span> Size #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () at &lt;compiler-generated&gt;</span><br><span class="line">    <span class="number">0x100001043</span> &lt;+<span class="number">19</span>&gt;: movl   $<span class="number">0x20</span>, %ecx</span><br><span class="line">    <span class="number">0x100001048</span> &lt;+<span class="number">24</span>&gt;: movl   %ecx, %esi</span><br><span class="line">    <span class="number">0x10000104a</span> &lt;+<span class="number">26</span>&gt;: movl   $<span class="number">0x7</span>, %ecx</span><br><span class="line">    <span class="number">0x10000104f</span> &lt;+<span class="number">31</span>&gt;: movl   %ecx, %edi</span><br><span class="line">    <span class="number">0x100001051</span> &lt;+<span class="number">33</span>&gt;: movq   %rdi, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001055</span> &lt;+<span class="number">37</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x100001058</span> &lt;+<span class="number">40</span>&gt;: movq   <span class="number">-0x10</span>(%rbp), %rax</span><br><span class="line">    <span class="number">0x10000105c</span> &lt;+<span class="number">44</span>&gt;: movq   %rdx, <span class="number">-0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001060</span> &lt;+<span class="number">48</span>&gt;: movq   %rax, %rdx</span><br><span class="line">    <span class="number">0x100001063</span> &lt;+<span class="number">51</span>&gt;: callq  <span class="number">0x100005046</span>               ; symbol stub <span class="keyword">for</span>: swift_allocObject</span><br><span class="line">    <span class="number">0x100001068</span> &lt;+<span class="number">56</span>&gt;: movq   %rax, %r13</span><br><span class="line">    <span class="number">0x10000106b</span> &lt;+<span class="number">59</span>&gt;: callq  <span class="number">0x100001e30</span>               ; init() -&gt; Size #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () <span class="keyword">in</span> Size #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () at main.swift:<span class="number">15</span></span><br><span class="line">    <span class="number">0x100001070</span> &lt;+<span class="number">64</span>&gt;: addq   $<span class="number">0x18</span>, %rsp</span><br><span class="line">    <span class="number">0x100001074</span> &lt;+<span class="number">68</span>&gt;: popq   %r13</span><br><span class="line">    <span class="number">0x100001076</span> &lt;+<span class="number">70</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001077</span> &lt;+<span class="number">71</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p>从 </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">0x10000103e &lt;+14&gt;: callq  0x100001250 ;<span class="built_in"> type </span>metadata accessor <span class="keyword">for</span> Size #1 <span class="keyword">in</span> testSwift.test1() -&gt; () at &lt;compiler-generated&gt;</span><br></pre></td></tr></table></figure>

<p>处执行lldb命令 si 跟踪进去</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">testSwift`init() <span class="keyword">in</span> Point #<span class="number">1</span> <span class="keyword">in</span> test1():</span><br><span class="line">-&gt;  <span class="number">0x100001030</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001031</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001034</span> &lt;+<span class="number">4</span>&gt;:  xorps  %xmm0, %xmm0</span><br><span class="line">    <span class="number">0x100001037</span> &lt;+<span class="number">7</span>&gt;:  movaps %xmm0, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000103b</span> &lt;+<span class="number">11</span>&gt;: movq   $<span class="number">0x3</span>, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001043</span> &lt;+<span class="number">19</span>&gt;: movq   $<span class="number">0x4</span>, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000104b</span> &lt;+<span class="number">27</span>&gt;: movl   $<span class="number">0x3</span>, %eax</span><br><span class="line">    <span class="number">0x100001050</span> &lt;+<span class="number">32</span>&gt;: movl   $<span class="number">0x4</span>, %ecx</span><br><span class="line">    <span class="number">0x100001055</span> &lt;+<span class="number">37</span>&gt;: movl   %ecx, %edx</span><br><span class="line">    <span class="number">0x100001057</span> &lt;+<span class="number">39</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001058</span> &lt;+<span class="number">40</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p>可以看到赋值操作 直接是把 $0x3 和 $0x4 赋值给栈空间 (-0x10(%rbp) 和 -0x8(%rbp) )的，没有调用malloc alloc 等方法，也就是没有开辟堆空间</p>
<h4 id="汇编验证验证类"><a href="#汇编验证验证类" class="headerlink" title="汇编验证验证类"></a>汇编验证验证类</h4><p>上面的代码，先在 var size = Size() 处打断点</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">0x100000fe0</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000fe1</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000fe4</span> &lt;+<span class="number">4</span>&gt;:  pushq  %r13</span><br><span class="line">    <span class="number">0x100000fe6</span> &lt;+<span class="number">6</span>&gt;:  subq   $<span class="number">0x28</span>, %rsp</span><br><span class="line">    <span class="number">0x100000fea</span> &lt;+<span class="number">10</span>&gt;: movq   $<span class="number">0x0</span>, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000ff2</span> &lt;+<span class="number">18</span>&gt;: xorps  %xmm0, %xmm0</span><br><span class="line">    <span class="number">0x100000ff5</span> &lt;+<span class="number">21</span>&gt;: movaps %xmm0, <span class="number">-0x20</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000ff9</span> &lt;+<span class="number">25</span>&gt;: xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100000ffb</span> &lt;+<span class="number">27</span>&gt;: movl   %eax, %edi</span><br><span class="line">-&gt;  <span class="number">0x100000ffd</span> &lt;+<span class="number">29</span>&gt;: callq  <span class="number">0x100001250</span>               ; type metadata accessor <span class="keyword">for</span> Size #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () at &lt;compiler-generated&gt;</span><br><span class="line">    <span class="number">0x100001002</span> &lt;+<span class="number">34</span>&gt;: movq   %rax, %r13</span><br><span class="line">    <span class="number">0x100001005</span> &lt;+<span class="number">37</span>&gt;: movq   %rdx, <span class="number">-0x28</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001009</span> &lt;+<span class="number">41</span>&gt;: callq  <span class="number">0x100001030</span>               ; __allocating_init() -&gt; Size #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () <span class="keyword">in</span> Size #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () at main.swift:<span class="number">15</span></span><br><span class="line">    <span class="number">0x10000100e</span> &lt;+<span class="number">46</span>&gt;: movq   %rax, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100001012</span> &lt;+<span class="number">50</span>&gt;: callq  <span class="number">0x100001080</span>               ; init() -&gt; Point #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () <span class="keyword">in</span> Point #<span class="number">1</span> <span class="keyword">in</span> testSwift.test1() -&gt; () at main.swift:<span class="number">21</span></span><br><span class="line">    <span class="number">0x100001017</span> &lt;+<span class="number">55</span>&gt;: movq   %rax, <span class="number">-0x20</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000101b</span> &lt;+<span class="number">59</span>&gt;: movq   %rdx, <span class="number">-0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000101f</span> &lt;+<span class="number">63</span>&gt;: movq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x100001023</span> &lt;+<span class="number">67</span>&gt;: callq  <span class="number">0x1000050ac</span>               ; symbol stub <span class="keyword">for</span>: swift_release</span><br><span class="line">    <span class="number">0x100001028</span> &lt;+<span class="number">72</span>&gt;: addq   $<span class="number">0x28</span>, %rsp</span><br><span class="line">    <span class="number">0x10000102c</span> &lt;+<span class="number">76</span>&gt;: popq   %r13</span><br><span class="line">    <span class="number">0x10000102e</span> &lt;+<span class="number">78</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x10000102f</span> &lt;+<span class="number">79</span>&gt;: retq</span><br></pre></td></tr></table></figure>

<p>进入 </p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span><span class="function"><span class="title">x100001009</span> &lt;+41&gt;: callq  0x100001030               ; __allocating_init() -&gt;</span> S<span class="function"><span class="title">ize</span> #1 <span class="built_in">in</span> testSwift.test1() -&gt;</span> () <span class="function"><span class="title">in</span> Size #1 <span class="built_in">in</span> testSwift.test1() -&gt;</span> () <span class="built_in">at</span> main.swift:<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>一路跟踪进入，最终来到了如下图所示位置</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bca935cf4541ea?w=812&h=499&f=png&s=235950" alt=""></p>
<p>也就是确实分配了堆空间，验证了我们前面的结论</p>
<h2 id="对象的堆空间申请过程"><a href="#对象的堆空间申请过程" class="headerlink" title="对象的堆空间申请过程"></a>对象的堆空间申请过程</h2><ul>
<li>在Swift中，创建类的实例对象，要向堆空间申请内存，大概流程如下 </li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Class</span><span class="selector-class">.__allocating_init</span>() </span><br><span class="line"><span class="selector-tag">libswiftCore</span><span class="selector-class">.dylib</span><span class="selector-pseudo">:_swift_allocObject_</span> </span><br><span class="line"><span class="selector-tag">libswiftCore</span><span class="selector-class">.dylib</span><span class="selector-pseudo">:swift_slowAlloc</span> </span><br><span class="line"><span class="selector-tag">libsystem_malloc</span><span class="selector-class">.dylib</span><span class="selector-pseudo">:malloc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在Mac、iOS中的malloc函数分配的内存大小总是16的倍数</li>
<li>通过class_getInstanceSize可以得知:类的对象至少需要占用多少内存</li>
</ul>
<p>eg:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Point  &#123;</span><br><span class="line">    var x = <span class="number">11</span></span><br><span class="line">    var test = <span class="literal">true</span></span><br><span class="line">	var y = <span class="number">22</span> </span><br><span class="line">&#125;</span><br><span class="line">var p = <span class="constructor">Point()</span> </span><br><span class="line"><span class="keyword">class</span><span class="constructor">_getInstanceSize(<span class="params">type</span>(<span class="params">of</span>: <span class="params">p</span>)</span>) <span class="comment">// 40</span></span><br><span class="line"><span class="keyword">class</span><span class="constructor">_getInstanceSize(Point.<span class="params">self</span>)</span> <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><ul>
<li><p>值类型赋值给var、let或者给函数传参，是直接将所有内容拷贝一份 </p>
</li>
<li><p>类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝(deep copy)</p>
</li>
<li><p>在Swift标准库中，为了提升性能，String、Array、Dictionary、Set采取了Copy On Write的技术 </p>
<ul>
<li>比如仅当有“写”操作时，才会真正执行拷贝操作<ul>
<li>对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</li>
</ul>
</li>
</ul>
</li>
<li><p>建议:不需要修改的，尽量定义成let</p>
</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>引用赋值给var、let或者给函数传参，是将内存地址拷贝一份 </li>
<li>类似于制作一个文件的替身(快捷方式、链接)，指向的是同一个文件。属于浅拷贝(shallow copy)</li>
</ul>
<h2 id="枚举、结构体、类都可以定义方法"><a href="#枚举、结构体、类都可以定义方法" class="headerlink" title="枚举、结构体、类都可以定义方法"></a>枚举、结构体、类都可以定义方法</h2><h3 id="一般把定义在枚举、结构体、类内部的函数，叫做方法"><a href="#一般把定义在枚举、结构体、类内部的函数，叫做方法" class="headerlink" title="一般把定义在枚举、结构体、类内部的函数，叫做方法"></a>一般把定义在枚举、结构体、类内部的函数，叫做方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类中定义方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), height=\(height)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="type">Size</span>()</span><br><span class="line">s.show() <span class="comment">// width=10, height=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体中定义方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"x=\(x), y=\(y)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="type">Point</span>()</span><br><span class="line">p.show() <span class="comment">// x=10, y=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举中定义方法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">grade</span> : <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a = <span class="string">"a"</span></span><br><span class="line">    <span class="keyword">case</span> b = <span class="string">"b"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"res is \(rawValue)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = grade.a</span><br><span class="line">g.show() <span class="comment">// res is a</span></span><br></pre></td></tr></table></figure>

<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
<p><a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之可选项</title>
    <url>/Swift%E4%B9%8B%E5%8F%AF%E9%80%89%E9%A1%B9.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>可选项，一般也叫可选类型，它允许将值设置为nil </li>
<li>在类型名称后面加个问号? 来定义一个可选项</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span> = <span class="string">"Jack"</span></span><br><span class="line">name = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> <span class="comment">// 默认就是nil </span></span><br><span class="line">age = <span class="number">10</span></span><br><span class="line">age = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h2 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h2><ul>
<li>可选项是对其他类型的一层包装，可以将它理解为一个盒子 <ul>
<li>如果为nil，那么它是个空盒子 </li>
<li>如果不为nil，那么盒子里装的是:被包装类型的数据</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> <span class="comment">// 默认就是nil </span></span><br><span class="line">age = <span class="number">10</span></span><br><span class="line">age = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果要从可选项中取出被包装的数据(将盒子里装的东西取出来)，需要使用感叹号! 进行强制解包</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">var age:</span> <span class="string">Int?</span> <span class="string">=</span> <span class="number">10</span></span><br><span class="line"><span class="attr">let ageInt:</span> <span class="string">Int</span> <span class="string">=</span> <span class="string">age!</span></span><br><span class="line"><span class="string">ageInt</span> <span class="string">+=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果对值为nil的可选项(空盒子)进行强制解包，将会产生运行时错误</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="built_in">Int</span>?</span><br><span class="line">age!<span class="comment">// 报错：Fatal error: Unexpectedly found nil while unwrapping an Optional value</span></span><br></pre></td></tr></table></figure>

<h2 id="判断可选项是否包含值"><a href="#判断可选项是否包含值" class="headerlink" title="判断可选项是否包含值"></a>判断可选项是否包含值</h2><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">let</span> <span class="variable">number</span> = <span class="function"><span class="title">Int</span>(<span class="string">"123"</span>)</span></span><br><span class="line"><span class="variable"><span class="keyword">if</span></span> <span class="variable">number</span> <span class="variable">!</span>= <span class="variable"><span class="literal">nil</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="title">print</span>(<span class="string">"字符串转换整数成功:\(number!)"</span>) </span></span><br><span class="line"><span class="function">&#125; <span class="variable"><span class="keyword">else</span></span> &#123;</span></span><br><span class="line"><span class="function">	<span class="title">print</span>(<span class="string">"字符串转换整数失败"</span>) </span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 字符串转换整数成功:123</span></span></span><br></pre></td></tr></table></figure>


<h2 id="可选项绑定"><a href="#可选项绑定" class="headerlink" title="可选项绑定"></a>可选项绑定</h2><ul>
<li>可以使用可选项绑定来判断可选项是否包含值<ul>
<li>如果包含就自动解包，把值赋给一个临时的常量(let)或者变量(var)，并返回true，否则返回false</li>
</ul>
</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> number = <span class="keyword">Int</span>(<span class="string">"123"</span>) &#123;</span><br><span class="line">   <span class="keyword">print</span>(<span class="string">"字符串转换整数成功:\(number)"</span>) </span><br><span class="line">    <span class="comment">// number是强制解包之后的Int值</span></span><br><span class="line">	<span class="comment">// number作用域仅限于这个大括号</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="keyword">print</span>(<span class="string">"字符串转换整数失败"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转换整数成功:123</span></span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spring = <span class="number">1</span>, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> season = <span class="type">Season</span>(rawValue: <span class="number">6</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> season &#123; </span><br><span class="line">		<span class="keyword">case</span> .spring:</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">"the season is spring"</span>)</span><br><span class="line">    	<span class="keyword">default</span>:</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">"the season is other"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"no such season"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// no such season</span></span><br></pre></td></tr></table></figure>

<h2 id="等价写法"><a href="#等价写法" class="headerlink" title="等价写法"></a>等价写法</h2><p>可选项绑定中，如果多个条件比如下面</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">first</span> = Int(<span class="string">"4"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">second</span> = Int(<span class="string">"42"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">first</span> &lt; <span class="built_in">second</span> &amp;&amp; <span class="built_in">second</span> &lt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\(first) &lt; \(second) &lt; 100"</span>)</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">4</span> &lt; <span class="number">42</span> &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>可以用 , 分割开，看起来更简单</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">first</span> = Int(<span class="string">"4"</span>),</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">second</span> = Int(<span class="string">"42"</span>),</span><br><span class="line">    <span class="built_in">first</span> &lt; <span class="built_in">second</span> &amp;&amp; <span class="built_in">second</span> &lt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(second) &lt; \(second) &lt; 100"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">4</span> &lt; <span class="number">42</span> &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="while循环中使用可选项绑定"><a href="#while循环中使用可选项绑定" class="headerlink" title="while循环中使用可选项绑定"></a>while循环中使用可选项绑定</h2><ul>
<li>有如下需求<br>//遍历数组，将遇到的正数都加起来，如果遇到负数或者非数字，停止遍历</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">//遍历数组，将遇到的正数都加起来，如果遇到负数或者非数字，停止遍历</span><br><span class="line">// <span class="built_in">var</span> strs = [<span class="string">"10"</span>, <span class="string">"20"</span>, <span class="string">"abc"</span>, <span class="string">"-20"</span>, <span class="string">"30"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> index = <span class="number">0</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">let</span> <span class="built_in">num</span> = Int(strs[index]), <span class="built_in">num</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">sum</span> += <span class="built_in">num</span></span><br><span class="line">	index += <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>


<h2 id="空合并运算符-Nil-Coalescing-Operator"><a href="#空合并运算符-Nil-Coalescing-Operator" class="headerlink" title="空合并运算符 ??(Nil-Coalescing Operator)"></a>空合并运算符 ??(Nil-Coalescing Operator)</h2><p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> ?? &lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, defaultValue: @autoclosure <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T?</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T?</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> ?? &lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, defaultValue: @autoclosure <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>


<ul>
<li>a ?? b<ul>
<li>a 是可选项</li>
<li>b 是可选项 或者 不是可选项</li>
<li>b 跟 a 的存储类型必须相同</li>
<li>如果 a 不为nil，就返回 a</li>
<li>如果 a 为nil，就返回 b</li>
<li>如果 b 不是可选项，返回 a 时会自动解包</li>
</ul>
</li>
</ul>
<p><strong>规律： 返回的类型取决于b</strong></p>
<p>举例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b <span class="comment">// c是Int? , Optional(1)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">Int</span>? = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> c = a ?? b <span class="comment">// c是Int , 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b <span class="comment">// c是Int , 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b <span class="comment">// c是Int? , Optional(2)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span> </span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="comment">// 如果不使用??运算符 </span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span>: <span class="type">Int</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tmp = a &#123;</span><br><span class="line">    <span class="built_in">c</span> = tmp</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="built_in">c</span>=b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ？？ 运算符</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b <span class="comment">// c是Int? , nil</span></span><br></pre></td></tr></table></figure>

<h2 id="多个-一起使用"><a href="#多个-一起使用" class="headerlink" title="多个 ?? 一起使用"></a>多个 ?? 一起使用</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b ?? <span class="number">3</span> <span class="comment">// c是Int , 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b ?? <span class="number">3</span> <span class="comment">// c是Int , 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a ?? b ?? <span class="number">3</span> <span class="comment">// c是Int , 3</span></span><br></pre></td></tr></table></figure>

<h2 id="跟if-let配合使用"><a href="#跟if-let配合使用" class="headerlink" title="??跟if let配合使用"></a>??跟if let配合使用</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">c</span> = a ?? b &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">c</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类似于if a != nil || b != nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> c = a, <span class="keyword">let</span> d = b &#123;</span><br><span class="line">    <span class="keyword">print</span>(c)</span><br><span class="line">	<span class="keyword">print</span>(d) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类似于if a != nil &amp;&amp; b != nil</span></span><br></pre></td></tr></table></figure>

<h2 id="guard语句"><a href="#guard语句" class="headerlink" title="guard语句"></a>guard语句</h2><ul>
<li>当guard语句的条件为false时，就会执行大括号里面的代码 </li>
<li>当guard语句的条件为true时，就会跳过guard语句</li>
<li>guard语句特别适合用来“提前退出”</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">guard 条件 <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="regexp">//</span> <span class="keyword">do</span> something....</span><br><span class="line">退出当前作用域</span><br><span class="line"><span class="regexp">//</span> return、<span class="keyword">break</span>、<span class="keyword">continue</span>、throw error &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用guard语句进行可选项绑定时，绑定的常量(let)、变量(var)也能在外层作用域中使用</li>
</ul>
<p>假设我们有个登陆的需求，要求输入账号，密码。缺一不可。</p>
<h3 id="用if语句书写"><a href="#用if语句书写" class="headerlink" title="用if语句书写"></a>用if语句书写</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if语句实现登陆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(<span class="number">_</span> info: [String : String])</span></span> &#123; </span><br><span class="line">	<span class="keyword">let</span> username: <span class="type">String</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> tmp = info[<span class="string">"username"</span>] &#123;</span><br><span class="line">        username = tmp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"请输入用户名"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">let</span> password: <span class="type">String</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> tmp = info[<span class="string">"password"</span>] &#123;</span><br><span class="line">        password = tmp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"请输入密码"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 能来到这里，说明，username和password都是有值的</span></span><br><span class="line">	<span class="comment">// if username ....</span></span><br><span class="line">	<span class="comment">// if password ....</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"用户名:\(username)"</span>, <span class="string">"密码:\(password)"</span>, <span class="string">"登陆ing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">login([<span class="string">"username"</span> : <span class="string">"jack"</span>, <span class="string">"password"</span> : <span class="string">"123456"</span>]) <span class="comment">// 用户名:jack 密码:123456 登陆ing </span></span><br><span class="line"></span><br><span class="line">login([<span class="string">"password"</span> : <span class="string">"123456"</span>]) <span class="comment">// 请输入密码</span></span><br><span class="line"></span><br><span class="line">login([<span class="string">"username"</span> : <span class="string">"jack"</span>]) <span class="comment">// 请输入用户名</span></span><br></pre></td></tr></table></figure>

<h3 id="如果用guard来书写"><a href="#如果用guard来书写" class="headerlink" title="如果用guard来书写"></a>如果用guard来书写</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(<span class="number">_</span> info: [String : String])</span></span> &#123;</span><br><span class="line">	<span class="keyword">guard</span> <span class="keyword">let</span> username = info[<span class="string">"username"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"请输入用户名"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">guard</span> <span class="keyword">let</span> password = info[<span class="string">"password"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"请输入密码"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if username ....</span></span><br><span class="line">	<span class="comment">// if password ....</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"用户名:\(username)"</span>, <span class="string">"密码:\(password)"</span>, <span class="string">"登陆ing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐式解包-Implicitly-Unwrapped-Optional"><a href="#隐式解包-Implicitly-Unwrapped-Optional" class="headerlink" title="隐式解包(Implicitly Unwrapped Optional)"></a>隐式解包(Implicitly Unwrapped Optional)</h2><ul>
<li>在某些情况下，可选项一旦被设定值之后，就会一直拥有值</li>
<li>在这种情况下，可以去掉检查，也不必每次访问的时候都进行解包，因为它能确定每次访问的时候都有值 </li>
<li>可以在类型后面加个感叹号 ! 定义一个隐式解包的可选项</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1: Int! = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num2: Int = num1</span><br><span class="line"><span class="keyword">if</span> num1 != nil &#123;</span><br><span class="line">    <span class="keyword">print</span>(num1 + <span class="number">6</span>) <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> num3 = num1 &#123;</span><br><span class="line">    <span class="keyword">print</span>(num3) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意不能设置为nil</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="built_in">Int</span>! = nil</span><br><span class="line"><span class="comment">// Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</span></span><br><span class="line"><span class="keyword">let</span> num2: <span class="built_in">Int</span> = num1</span><br></pre></td></tr></table></figure>

<p><strong>尽量不要使用这个强制解包。<br>除非你设计接口，不希望接收空值，如果别人传Nil过来，直接报错</strong></p>
<h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><ul>
<li>可选项在字符串插值或者直接打印时，编译器会发出警告</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"My age is \(age)"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>至少有3种方法消除警告</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">print</span>(<span class="string">"My age is \(age!)"</span>)</span><br><span class="line"><span class="comment">// My age is 10</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"My age is \(String(describing: age))"</span>)</span><br><span class="line"><span class="comment">// My age is Optional(10)</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"My age is \(age ?? 0)"</span>)</span><br><span class="line"><span class="comment">// My age is 10</span></span><br></pre></td></tr></table></figure>

<h2 id="多重可选项"><a href="#多重可选项" class="headerlink" title="多重可选项"></a>多重可选项</h2><ul>
<li>可以使用lldb指令 frame variable –R 或者 fr v –R 查看区别</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">n</span><span class="symbol">um1:</span> <span class="built_in">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">n</span><span class="symbol">um2:</span> <span class="built_in">Int</span>?? = num1</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">n</span><span class="symbol">um3:</span> <span class="built_in">Int</span>?? = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(num2 == num3) // <span class="built_in">true</span></span><br></pre></td></tr></table></figure>

<p>还有下面这种</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> num2: <span class="type">Int?</span>? = num1</span><br><span class="line"><span class="keyword">var</span> num3: <span class="type">Int?</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num2 == num3) <span class="comment">// false</span></span><br><span class="line">(num2 ?? <span class="number">1</span>) ?? <span class="number">2</span> <span class="comment">// 2</span></span><br><span class="line">(num3 ?? <span class="number">1</span>) ?? <span class="number">2</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>




<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之枚举</title>
    <url>/Swift%E4%B9%8B%E6%9E%9A%E4%B8%BE.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举的基本用法"><a href="#枚举的基本用法" class="headerlink" title="枚举的基本用法"></a>枚举的基本用法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义方向的枚举</span></span><br><span class="line">enum <span class="built_in">Direction</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> north</span><br><span class="line">     <span class="keyword">case</span> south</span><br><span class="line">	 <span class="keyword">case</span> <span class="literal">east</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="literal">west</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面也可以写成</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> dir = Direction<span class="selector-class">.west</span> </span><br><span class="line">dir = Direction<span class="selector-class">.east</span> </span><br><span class="line">dir = .north</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(dir)</span></span> <span class="comment">// north</span></span><br></pre></td></tr></table></figure>

<p>也可以在switch中使用</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> dir &#123; </span><br><span class="line"><span class="keyword">case</span> .north:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"north"</span>) </span><br><span class="line"><span class="keyword">case</span> .south:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"south"</span>) </span><br><span class="line"><span class="keyword">case</span> .east:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"east"</span>) </span><br><span class="line"><span class="keyword">case</span> .west:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"west"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><h3 id="有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中"><a href="#有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中" class="headerlink" title="有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中"></a>有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中</h3><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Score</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> points(Int)</span><br><span class="line">    <span class="keyword">case</span> grade(Character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下使用：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">score</span> = <span class="keyword">Score</span>.points(88) </span><br><span class="line"><span class="keyword">score</span> = .grade(<span class="string">"A"</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们想使用枚举的具体值，可以如下用 i 来保存数据</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> score &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .points(i):</span><br><span class="line">		<span class="keyword">print</span>(i, <span class="string">"points"</span>) </span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .grade(i):</span><br><span class="line">    	<span class="keyword">print</span>(<span class="string">"grade"</span>, i)</span><br><span class="line">&#125; <span class="comment">// grade A</span></span><br></pre></td></tr></table></figure>


<p>再比如我们想定义日期的枚举值，可以如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Date &#123;</span><br><span class="line">    <span class="keyword">case</span> digit(<span class="built_in">year</span>: Int, <span class="built_in">month</span>: Int, <span class="built_in">day</span>: Int)</span><br><span class="line">    <span class="keyword">case</span> string(<span class="keyword">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用的时候，可以直接传年月日，或者传字符串</span></span><br><span class="line"></span><br><span class="line">var date = Date.digit(<span class="built_in">year</span>: <span class="number">2011</span>, <span class="built_in">month</span>: <span class="number">9</span>, <span class="built_in">day</span>: <span class="number">10</span>) </span><br><span class="line">date = .string(<span class="string">"2011-09-10"</span>)</span><br><span class="line"><span class="keyword">switch</span> date &#123;</span><br><span class="line">	<span class="keyword">case</span> .digit(let <span class="built_in">year</span>, let <span class="built_in">month</span>, let <span class="built_in">day</span>):</span><br><span class="line">			rint(<span class="built_in">year</span>, <span class="built_in">month</span>, <span class="built_in">day</span>) </span><br><span class="line">	<span class="keyword">case</span> let .string(value):</span><br><span class="line">    	<span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="必要时let也可以改为var"><a href="#必要时let也可以改为var" class="headerlink" title="必要时let也可以改为var"></a>必要时let也可以改为var</h3><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><h3 id="枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做-原始值"><a href="#枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做-原始值" class="headerlink" title="枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做:原始值"></a>枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做:原始值</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义枚举</span></span><br><span class="line">enum Grade : String &#123;</span><br><span class="line">    case perfect = <span class="string">"A"</span></span><br><span class="line">    case great = <span class="string">"B"</span></span><br><span class="line">    case good = <span class="string">"C"</span></span><br><span class="line">    case bad = <span class="string">"D"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Grade.perfect.rawValue)</span></span> <span class="comment">// A </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Grade.great.rawValue)</span></span> <span class="comment">// B </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Grade.good.rawValue)</span></span> <span class="comment">// C </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Grade.bad.rawValue)</span></span> <span class="comment">// D</span></span><br></pre></td></tr></table></figure>

<h3 id="注意-原始值不占用枚举变量的内存"><a href="#注意-原始值不占用枚举变量的内存" class="headerlink" title="注意:原始值不占用枚举变量的内存"></a>注意:原始值不占用枚举变量的内存</h3><h2 id="隐式原始值-Implicitly-Assigned-Raw-Values"><a href="#隐式原始值-Implicitly-Assigned-Raw-Values" class="headerlink" title="隐式原始值(Implicitly Assigned Raw Values)"></a>隐式原始值(Implicitly Assigned Raw Values)</h2><h3 id="如果枚举的原始值类型是Int、String，Swift会自动分配原始值"><a href="#如果枚举的原始值类型是Int、String，Swift会自动分配原始值" class="headerlink" title="如果枚举的原始值类型是Int、String，Swift会自动分配原始值"></a>如果枚举的原始值类型是Int、String，Swift会自动分配原始值</h3><h3 id="原始值是-String-类型枚举值"><a href="#原始值是-String-类型枚举值" class="headerlink" title="原始值是 String 类型枚举值"></a>原始值是 String 类型枚举值</h3><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/<span class="regexp">/ 定义枚举值</span></span><br><span class="line"><span class="regexp">  enum Direction : String &#123;</span></span><br><span class="line"><span class="regexp">    case north = "north"</span></span><br><span class="line"><span class="regexp">    case south = "south"</span></span><br><span class="line"><span class="regexp">    case east = "east"</span></span><br><span class="line"><span class="regexp">    case west = "west"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 等价于</span></span><br><span class="line"><span class="regexp">enum Direction : String &#123;</span></span><br><span class="line"><span class="regexp">    case north, south, east, west</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用</span></span><br><span class="line"><span class="regexp">print(Direction.north) /</span><span class="regexp">/ north </span></span><br><span class="line"><span class="regexp">print(Direction.north.rawValue) /</span><span class="regexp">/ north</span></span><br></pre></td></tr></table></figure>

<h3 id="原始值是-Int-类型枚举值"><a href="#原始值是-Int-类型枚举值" class="headerlink" title="原始值是 Int 类型枚举值"></a>原始值是 Int 类型枚举值</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.spring.rawValue)</span></span> <span class="comment">// 0 </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.summer.rawValue)</span></span> <span class="comment">// 1 </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.autumn.rawValue)</span></span> <span class="comment">// 2 </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.winter.rawValue)</span></span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="如果自己指定了原始值"><a href="#如果自己指定了原始值" class="headerlink" title="如果自己指定了原始值"></a>如果自己指定了原始值</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring = <span class="number">1</span>, summer, autumn = <span class="number">8</span>, winter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.spring.rawValue)</span></span> <span class="comment">// 1 </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.summer.rawValue)</span></span> <span class="comment">// 2 </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.autumn.rawValue)</span></span> <span class="comment">// 8 </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(Season.winter.rawValue)</span></span> <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><h3 id="递归枚举要加上关键字-indirect"><a href="#递归枚举要加上关键字-indirect" class="headerlink" title="递归枚举要加上关键字 indirect"></a>递归枚举要加上关键字 indirect</h3><p>eg:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归枚举</span></span><br><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithExpr</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">case</span> sum(<span class="type">ArithExpr</span>, <span class="type">ArithExpr</span>)</span><br><span class="line">	<span class="keyword">case</span> difference(<span class="type">ArithExpr</span>, <span class="type">ArithExpr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的递归枚举和下面的等效</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithExpr</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">indirect</span> <span class="keyword">case</span> sum(<span class="type">ArithExpr</span>, <span class="type">ArithExpr</span>) </span><br><span class="line">	<span class="keyword">indirect</span> <span class="keyword">case</span> difference(<span class="type">ArithExpr</span>, <span class="type">ArithExpr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下列几种使用枚举都是可以的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five = <span class="type">ArithExpr</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithExpr</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> two = <span class="type">ArithExpr</span>.number(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithExpr</span>.sum(five, four)</span><br><span class="line"><span class="keyword">let</span> difference = <span class="type">ArithExpr</span>.difference(sum, two)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写个 calculate 方法，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(<span class="number">_</span> expr: ArithExpr)</span></span> -&gt; <span class="type">Int</span> &#123; </span><br><span class="line">	<span class="keyword">switch</span> expr &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .number(value): </span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .sum(<span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">		<span class="keyword">return</span> calculate(<span class="keyword">left</span>) + calculate(<span class="keyword">right</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .difference(<span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">		<span class="keyword">return</span> calculate(<span class="keyword">left</span>) - calculate(<span class="keyword">right</span>)</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用，计算差值</span></span><br><span class="line">calculate(difference)</span><br></pre></td></tr></table></figure>

<h2 id="MemoryLayout"><a href="#MemoryLayout" class="headerlink" title="MemoryLayout"></a>MemoryLayout</h2><h3 id="可以使用MemoryLayout获取数据类型占用的内存大小"><a href="#可以使用MemoryLayout获取数据类型占用的内存大小" class="headerlink" title="可以使用MemoryLayout获取数据类型占用的内存大小"></a>可以使用MemoryLayout获取数据类型占用的内存大小</h3><h4 id="关联值-1"><a href="#关联值-1" class="headerlink" title="关联值"></a>关联值</h4><ul>
<li>将关联值直接存入到枚举内存中</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义枚举</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">Password</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> number(<span class="keyword">Int</span>, <span class="keyword">Int</span>, <span class="keyword">Int</span>, <span class="keyword">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Password&gt;.stride <span class="comment">// 40, 分配占用的空间大小 </span></span><br><span class="line">MemoryLayout&lt;Password&gt;.size <span class="comment">// 33, 实际用到的空间大小 4*8 + 1 = 33</span></span><br><span class="line">MemoryLayout&lt;Password&gt;.alignment <span class="comment">// 8, 对齐参数</span></span><br></pre></td></tr></table></figure>

<p>定义变量来使用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var pwd = <span class="module-access"><span class="module"><span class="identifier">Password</span>.</span></span>number(<span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MemoryLayout</span>.</span></span>stride(ofValue: pwd) <span class="comment">// 40</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MemoryLayout</span>.</span></span>size(ofValue: pwd) <span class="comment">// 33 </span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MemoryLayout</span>.</span></span>alignment(ofValue: pwd) <span class="comment">// 8</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果改变了pwd</span></span><br><span class="line"> pwd = .other </span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MemoryLayout</span>.</span></span>stride(ofValue: pwd) <span class="comment">// 40</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MemoryLayout</span>.</span></span>size(ofValue: pwd) <span class="comment">// 33 </span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MemoryLayout</span>.</span></span>alignment(ofValue: pwd) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h4 id="原始值-1"><a href="#原始值-1" class="headerlink" title="原始值"></a>原始值</h4><ul>
<li>原始值不会直接存入到枚举内存中</li>
<li>如果是下面这种枚举，只需要1个字节就可以了</li>
<li>一个字节可以存放 FF 也就是 0~255个枚举值。如果</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> : <span class="title">Int</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> spring, summer, autumn = <span class="number">8</span>, winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Season&gt;.stride /<span class="regexp">/ 1, 分配占用的空间大小 </span></span><br><span class="line"><span class="regexp">MemoryLayout&lt;Season&gt;.size /</span><span class="regexp">/ 1, 实际用到的空间大小 1</span></span><br><span class="line"><span class="regexp">MemoryLayout&lt;Season&gt;.alignment /</span><span class="regexp">/ 1, 对齐参数</span></span><br></pre></td></tr></table></figure>

<h2 id="窥探内存"><a href="#窥探内存" class="headerlink" title="窥探内存"></a>窥探内存</h2><p>使用 <a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a> 我们可以很轻松的获取swift中，这些枚举值的内存地址</p>
<h3 id="简单枚举内存"><a href="#简单枚举内存" class="headerlink" title="简单枚举内存"></a>简单枚举内存</h3><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span>&#123;</span></span><br><span class="line">    <span class="keyword">case</span> k0,k1,k2,k3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var t = TestEnum.k1</span><br><span class="line">print(Mems.ptr(<span class="symbol">ofVal:</span> &amp;t)) </span><br><span class="line"></span><br><span class="line">t = TestEnum.k2</span><br></pre></td></tr></table></figure>

<p>执行完 print(Mems.ptr(ofVal: &amp;t))  代码之后<br>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x00000001000054b8</span></span><br></pre></td></tr></table></figure>
<p>此时去查看 0x00000001000054b8地址的数据，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>执行完 t = TestEnum.k2 之后</p>
<p>此时去查看 0x00000001000054b8地址的数据，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<h3 id="具体查看内存"><a href="#具体查看内存" class="headerlink" title="具体查看内存"></a>具体查看内存</h3><p>假设我们有这么下面带代码，考虑下内存怎么布局呢？</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">enum TestEnum &#123;</span><br><span class="line">        <span class="keyword">case</span> test1(<span class="keyword">Int</span>, <span class="keyword">Int</span>, <span class="keyword">Int</span>)</span><br><span class="line">        <span class="keyword">case</span> test2(<span class="keyword">Int</span>, <span class="keyword">Int</span>)</span><br><span class="line">        <span class="keyword">case</span> test3(<span class="keyword">Int</span>)</span><br><span class="line">        <span class="keyword">case</span> test4(<span class="keyword">Bool</span>)</span><br><span class="line">        <span class="keyword">case</span> test5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(MemoryLayout&lt;TestEnum&gt;.size)  <span class="comment">// 25, 分配占用的空间大小</span></span><br><span class="line"><span class="keyword">print</span>(MemoryLayout&lt;TestEnum&gt;.stride)    <span class="comment">//32, 实际用到的空间大小</span></span><br><span class="line"><span class="keyword">print</span>(MemoryLayout&lt;TestEnum&gt;.alignment)<span class="comment">// 8, 对齐参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = TestEnum.test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span>(Mems.ptr(ofVal: &amp;e))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">e = .test2(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span>(Mems.memStr(ofVal: &amp;e))</span><br><span class="line">    </span><br><span class="line">e = .test3(<span class="number">6</span>)</span><br><span class="line">     </span><br><span class="line">e = .test4(<span class="keyword">true</span>)</span><br><span class="line">      </span><br><span class="line">e = .test5</span><br></pre></td></tr></table></figure>

<p>执行完之后,可知 </p>
<p>TestEnum 这个占用内存为：</p>
<ul>
<li>print(MemoryLayout<TestEnum>.size)  // 25, 分配占用的空间大小</li>
<li>print(MemoryLayout<TestEnum>.stride)    //32, 实际用到的空间大小</li>
<li>print(MemoryLayout<TestEnum>.alignment)// 8, 对齐参数</li>
</ul>
<p>具体内存里面存的是什么呢？可以借助上面说的 <a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a> 打印出来内存，然后利用Xcode的 view Memory 查看具体内存的值</p>
<p>结果如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">enum</span> <span class="string">TestEnum</span> <span class="string">&#123;</span></span><br><span class="line">       <span class="string">case</span> <span class="string">test1(Int,</span> <span class="string">Int,</span> <span class="string">Int)</span></span><br><span class="line">       <span class="string">case</span> <span class="string">test2(Int,</span> <span class="string">Int)</span></span><br><span class="line">       <span class="string">case</span> <span class="string">test3(Int)</span></span><br><span class="line">       <span class="string">case</span> <span class="string">test4(Bool)</span></span><br><span class="line">       <span class="string">case</span> <span class="string">test5</span></span><br><span class="line">   <span class="string">&#125;</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="string">print(MemoryLayout&lt;TestEnum&gt;.size)</span>  <span class="string">//</span> <span class="number">25</span><span class="string">,</span> <span class="string">分配占用的空间大小</span></span><br><span class="line">   <span class="string">print(MemoryLayout&lt;TestEnum&gt;.stride)</span>    <span class="string">//32,</span> <span class="string">实际用到的空间大小</span></span><br><span class="line">   <span class="string">print(MemoryLayout&lt;TestEnum&gt;.alignment)//</span> <span class="number">8</span><span class="string">,</span> <span class="string">对齐参数</span></span><br><span class="line"></span><br><span class="line">   <span class="string">//</span> <span class="number">1</span><span class="string">个字节存储成员值</span></span><br><span class="line">   <span class="string">//</span> <span class="string">N个字节存储关联值（N取占用内存最大的关联值），任何一个case的关联值都共用这N个字节</span></span><br><span class="line">   <span class="string">//</span> <span class="string">共用体</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">//</span> <span class="string">小端：高高低低</span></span><br><span class="line">   <span class="string">//</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="string">//对应的TestEnum.test1传入的数值</span></span><br><span class="line">   <span class="string">//</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span>                <span class="string">//</span> <span class="string">TestEnum.test1在第0个位置</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">var</span> <span class="string">e</span> <span class="string">=</span> <span class="string">TestEnum.test1(1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">)</span></span><br><span class="line">   <span class="string">print(Mems.ptr(ofVal:</span> <span class="string">&amp;e))</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">//</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">01</span>						 <span class="string">//</span> <span class="string">TestEnum.test1在第1个位置</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">e</span> <span class="string">=</span> <span class="string">.test2(4,</span> <span class="number">5</span><span class="string">)</span></span><br><span class="line">   <span class="string">print(Mems.memStr(ofVal:</span> <span class="string">&amp;e))</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">//</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">02</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">e</span> <span class="string">=</span> <span class="string">.test3(6)</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">//</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">03</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">e</span> <span class="string">=</span> <span class="string">.test4(true)</span></span><br><span class="line">   </span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">//</span> <span class="number">04</span></span><br><span class="line">   <span class="string">//</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">   <span class="string">e</span> <span class="string">=</span> <span class="string">.test5</span></span><br></pre></td></tr></table></figure>

<h3 id="只有一个case"><a href="#只有一个case" class="headerlink" title="只有一个case"></a>只有一个case</h3><p>假如只有一个case,其占用的空间为0，不需要存值来区分是哪个case</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> spring</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.size)      /<span class="regexp">/ 0, 分配占用的空间大小</span></span><br><span class="line"><span class="regexp">print(MemoryLayout&lt;TestEnum&gt;.stride)    /</span><span class="regexp">/1, 实际用到的空间大小</span></span><br><span class="line"><span class="regexp">print(MemoryLayout&lt;TestEnum&gt;.alignment)/</span><span class="regexp">/ 1, 对齐参数</span></span><br></pre></td></tr></table></figure>

<h3 id="只有一个case，有关联值"><a href="#只有一个case，有关联值" class="headerlink" title="只有一个case，有关联值"></a>只有一个case，有关联值</h3><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> spring(Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.size)      /<span class="regexp">/ 8, 分配占用的空间大小</span></span><br><span class="line"><span class="regexp">print(MemoryLayout&lt;TestEnum&gt;.stride)    /</span><span class="regexp">/8, 实际用到的空间大小</span></span><br><span class="line"><span class="regexp">print(MemoryLayout&lt;TestEnum&gt;.alignment)/</span><span class="regexp">/ 8, 对齐参数</span></span><br></pre></td></tr></table></figure>




<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
<p><a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之函数</title>
    <url>/Swift%E4%B9%8B%E5%87%BD%E6%95%B0.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><ul>
<li>形参默认是let 并且只能是let</li>
</ul>
<ol>
<li><p>无参无返回值</p>
<p>可以省略Void 也可以不省略，如下三种都可以</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span> -&gt; <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span> -&gt; <span class="params">(Void)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>无参有返回值</li>
</ol>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pi</span><span class="params">()</span> -&gt; <span class="title">Double</span> &#123;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">3.1415</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>有参有返回值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h2><ul>
<li>如果函数体是个单一表达式，那么函数会返回这个表达式<br>比如上面的代码可以去掉 return 写成</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回元组：可以实现多返回值"><a href="#返回元组：可以实现多返回值" class="headerlink" title="返回元组：可以实现多返回值"></a>返回元组：可以实现多返回值</h2><p>例如 </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">func calculate(a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span>) -&gt; (<span class="built_in">sum</span>: <span class="built_in">Int</span>, average: <span class="built_in">Int</span>) &#123;</span><br><span class="line">      let <span class="built_in">sum</span> = a + b</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">sum</span>, <span class="built_in">sum</span> &gt;&gt; <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> 调用 calculate(a: <span class="number">2</span>, b: <span class="number">8</span>)</span><br><span class="line"> 返回 (<span class="built_in">sum</span>: <span class="number">10</span>, average: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul>
<li>把光标定位到需要添加注释文档的对象起始行，或上方的空白行。按下“command + Option + /”，即“⌘ + ⌥ + /”。（如果是 Windows 键盘则为“Win键 + ALT + /”）</li>
</ul>
<p>例如上文代码增加注释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 计算两个数之和</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - Parameters:</span></span><br><span class="line">  <span class="comment">///   - a: 第一个参数</span></span><br><span class="line">  <span class="comment">///   - b: 第二个参数</span></span><br><span class="line">  <span class="comment">/// - Returns: 返回两个参数之和</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h2><ul>
<li>可以修改参数标签</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goToWork</span><span class="params">(at time: String)</span> -&gt; <span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"this time is \(time)"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用下划线 _ 省略参数标签</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> a + b</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul>
<li>同C++ 中一样参数可以有默认值</li>
<li>但是C++里面默认参数有个限制：必须从右向左设置。而Swift中拥有参数标签，所以没有这个限制    </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">定义：func <span class="keyword">check</span>(<span class="keyword">name</span>: <span class="keyword">String</span> = <span class="string">"jack"</span>, age: <span class="built_in">Int</span>, job: <span class="keyword">String</span> = <span class="string">"teacher"</span>) &#123;</span><br><span class="line">       print(<span class="string">"name = \(name), age = \(age), job = \(job)"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">调用：<span class="keyword">check</span>(age: <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">输出： <span class="keyword">name</span> = jack, age = <span class="number">22</span>, job = teacher</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>例如：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">func <span class="built_in">sum</span>(<span class="symbol">_</span> numbers: Int...) -&gt; Int&#123;</span><br><span class="line">       <span class="built_in">var</span> total = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> <span class="built_in">num</span> <span class="keyword">in</span> numbers &#123;</span><br><span class="line">           total += <span class="built_in">num</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> total</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">调用: <span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>一个函数最多只能有一个可变参数</li>
<li>紧跟着可变参数后面的参数不能省略参数标签(否则编译起来有歧义)</li>
</ul>
<p>例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数string 不能省略标签</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> numers: Int..., string: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><ul>
<li>前面说了形参只能是let，但是如果我们想再内部修改外部实参的值，可以用 inpot 定义输入输出参数</li>
</ul>
<p>例如</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">func swapValues(_ v1: <span class="keyword">inout</span> Int, _ v2: <span class="keyword">inout</span> Int) &#123;</span><br><span class="line">     let tmp = v1</span><br><span class="line">     v1 = v2</span><br><span class="line">     v2 = tmp</span><br><span class="line">     <span class="comment">//前面三行也可以换成  (v1, v2) = (v2, v1) 效果一样</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  var num1 = <span class="number">10</span></span><br><span class="line">  var num2 = <span class="number">20</span></span><br><span class="line">  swapValues(&amp;num1, &amp;num2)</span><br><span class="line"> print(<span class="string">"num1 = \(num1), num2 = \(num2)"</span>)</span><br><span class="line">    </span><br><span class="line">  输出： num1 = <span class="number">20</span>, num2 = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>注意点:</p>
<ul>
<li>可变参数不能标记为input</li>
<li>input参数不能有默认值</li>
<li>input参数的本质是地址传递(引用传递)</li>
<li>input参数只能传入可以被多次赋值的</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>函数名相同</li>
<li>参数个数不同 或者 参数类型不同 或者 参数标签不同</li>
</ul>
<p>注意点是：</p>
<ul>
<li>返回值类型与函数重载无关</li>
<li>默认参数值和函数重载一起使用产生二义性时候，编译器不会报错(c++中会报错)</li>
</ul>
<p>例如</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">func</span> sum(<span class="built_in">v1</span>: Int, <span class="built_in">v2</span>: Int) -&gt; Int &#123;</span><br><span class="line">      <span class="built_in">v1</span> + <span class="built_in">v2</span></span><br><span class="line">  &#125;</span><br><span class="line">  func sum(<span class="built_in">v1</span>: Int, <span class="built_in">v2</span>: Int, <span class="built_in">v3</span>: Int = <span class="number">10</span>) -&gt; Int &#123;</span><br><span class="line">      <span class="built_in">v1</span> + <span class="built_in">v2</span> + <span class="built_in">v3</span></span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 会调用sum(<span class="built_in">v1</span>: Int, <span class="built_in">v2</span>: Int) </span><br><span class="line">  sum(<span class="built_in">v1</span>: <span class="number">10</span>, <span class="built_in">v2</span>: <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>可变参数、省略参数标签、函数重载一起使用产生二义性时，编译器有可能会报错</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(v1: Int, v2: Int)</span></span> -&gt; <span class="type">Int</span> &#123; v1 + v2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> v1: Int, <span class="number">_</span> v2: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    v1 + v2 &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: ambiguous use of 'sum'</span></span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul>
<li>每一个函数都是有类型的，函数类型由形式参数类型、返回值类型组成</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">func test<span class="function"><span class="params">()</span> &#123; &#125; // <span class="params">()</span> -&gt;</span> Void 或者 <span class="function"><span class="params">()</span> -&gt;</span> ()</span><br><span class="line">func sum<span class="function"><span class="params">(a: Int, b: Int)</span> -&gt;</span> Int &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125; <span class="regexp">// (Int, Int) -&gt; Int</span></span><br><span class="line"><span class="regexp">//</span> 定义变量</span><br><span class="line"><span class="keyword">var</span> fn: <span class="function"><span class="params">(Int, Int)</span> -&gt;</span> Int = sum</span><br><span class="line">调用: fn(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数类型作为函数参数"><a href="#函数类型作为函数参数" class="headerlink" title="函数类型作为函数参数"></a>函数类型作为函数参数</h2><p>例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(v1: Int, v2: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">       v1 + v2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">difference</span><span class="params">(v1: Int, v2: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">       v1 - v2</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个函数类型作为参数 上面两个函数类型都是 (Int, Int) -&gt; Int</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">printResult</span><span class="params">(<span class="number">_</span> mathFn: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123; <span class="built_in">print</span>(<span class="string">"Result: \(mathFn(a, b))"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用</span></span><br><span class="line">   printResult(sum, <span class="number">5</span>, <span class="number">2</span>) <span class="comment">// Result: 7</span></span><br><span class="line">   printResult(difference, <span class="number">5</span>, <span class="number">2</span>) <span class="comment">// Result: 3</span></span><br></pre></td></tr></table></figure>

<h2 id="返回值是函数类型的函数"><a href="#返回值是函数类型的函数" class="headerlink" title="返回值是函数类型的函数"></a>返回值是函数类型的函数</h2><ul>
<li>返回值是函数类型的函数，叫做高阶函数(Higher-Order Function)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">previous</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    input - <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forward</span><span class="params">(<span class="number">_</span> forward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    forward ? next : previous</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">forward(<span class="literal">true</span>)(<span class="number">3</span>) <span class="comment">//  4  相当于 调用 next(3)</span></span><br><span class="line">forward(<span class="literal">false</span>)(<span class="number">3</span>) <span class="comment">// 2 相当于 调用 previous(3)</span></span><br></pre></td></tr></table></figure>

<h2 id="typealias-别名"><a href="#typealias-别名" class="headerlink" title="typealias 别名"></a>typealias 别名</h2><ul>
<li>用来给类型起别名</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"> typealias Date = (year: Int, month: Int, day: Int)</span><br><span class="line">   func <span class="built_in">test</span>(_ <span class="built_in">date</span>: <span class="built_in">Date</span>) &#123;</span><br><span class="line">       <span class="keyword">print</span>(<span class="built_in">date</span><span class="number">.0</span>)</span><br><span class="line">       <span class="keyword">print</span>(<span class="built_in">date</span>.year)</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// test((2011, 9, 10))</span></span><br></pre></td></tr></table></figure>


<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><ul>
<li>将函数定义在函数内部</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forward</span><span class="params">(<span class="number">_</span> forward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    input + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">previous</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; input - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forward ? next : previous</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forward(<span class="literal">true</span>)(<span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line">forward(<span class="literal">false</span>)(<span class="number">3</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之流程控制</title>
    <url>/Swift%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><ul>
<li>if后面的条件可以省略小括号</li>
<li>条件后面的大括号不可以省略</li>
</ul>
<p>下面的代码是可以的</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">let</span> <span class="variable">score</span> = <span class="number">70</span></span><br><span class="line"><span class="variable"><span class="keyword">if</span></span> <span class="variable">score</span> &gt;= <span class="number">80</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">"优秀"</span>)</span></span><br><span class="line">&#125;<span class="variable"><span class="keyword">else</span></span> <span class="variable"><span class="keyword">if</span></span> <span class="variable">score</span> &gt;= <span class="number">60</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">"及格"</span>)</span></span><br><span class="line">&#125;<span class="variable"><span class="keyword">else</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">"不及格"</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>if后面的条件只能是bool类型</li>
</ul>
<p>例如下面是不可以的</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">if</span></span> <span class="variable">score</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">"aa"</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>先看如下代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">num</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"num is \(num)"</span>)</span><br><span class="line">    <span class="built_in">num</span> -= <span class="number">1</span></span><br><span class="line">&#125;<span class="comment">// 会打印五次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">5</span></span><br><span class="line">repeat &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"num is \(num)"</span>)</span><br><span class="line">     <span class="built_in">num</span> -= <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">while</span> <span class="built_in">num</span> &gt; <span class="number">0</span><span class="comment">// 会打印五次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>repeat-while 相当于C语言中的 do-while</li>
<li>上面代码中没有用num–，是因为从Swift3开始，去掉了自增(++)、自减(–)运算符</li>
</ul>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><h3 id="闭区间运算符-a…b，代表着-a-lt-取值-lt-b"><a href="#闭区间运算符-a…b，代表着-a-lt-取值-lt-b" class="headerlink" title="闭区间运算符: a…b，代表着: a &lt;= 取值 &lt;= b"></a>闭区间运算符: a…b，代表着: a &lt;= 取值 &lt;= b</h3><p>例如</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">let persons = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wanger"</span>,<span class="string">"mazi"</span>]</span><br><span class="line"><span class="function"><span class="title">for</span></span> i in <span class="number">0.</span>.<span class="number">.3</span> &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wanger</span></span><br><span class="line"><span class="comment">//mazi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可以用range来表示区间，例如</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">let persons = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wanger"</span>,<span class="string">"mazi"</span>]</span><br><span class="line">let <span class="keyword">range</span> = <span class="number">0.</span>.<span class="number">.3</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="keyword">range</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(persons[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wanger</span></span><br><span class="line"><span class="comment">//mazi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可以用变量来表示区间，例如</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> persons = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wanger"</span>,<span class="string">"mazi"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">before</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">end</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="keyword">before</span>..<span class="variable">.end</span> &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wanger</span></span><br><span class="line"><span class="comment">//mazi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可以用变量和数值共同使用来表示区间，例如</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">let persons = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wanger"</span>,<span class="string">"mazi"</span>]</span><br><span class="line"><span class="function"><span class="title">for</span></span> i in before..<span class="number">.3</span> &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wanger</span></span><br><span class="line"><span class="comment">//mazi</span></span><br></pre></td></tr></table></figure>

<h3 id="半开区间运算符：a-lt-b-表示-a-lt-取值-lt-b"><a href="#半开区间运算符：a-lt-b-表示-a-lt-取值-lt-b" class="headerlink" title="半开区间运算符：a..&lt;b 表示 a &lt;= 取值 &lt; b"></a>半开区间运算符：a..&lt;b 表示 a &lt;= 取值 &lt; b</h3><p>例如</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">let persons = [<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>,<span class="string">"wanger"</span>,<span class="string">"mazi"</span>]</span><br><span class="line"><span class="function"><span class="title">for</span></span> i in <span class="number">1.</span>.&lt;<span class="number">3</span> &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wanger</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>区间运算符用在数组上<br>例如</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">0.</span>.<span class="number">.3</span>] &#123;</span><br><span class="line">    print(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>单侧区间</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">0.</span>..] &#123;</span><br><span class="line">    print(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums[..&lt;<span class="number">4</span>] &#123;</span><br><span class="line">    print(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h2 id="区间类型"><a href="#区间类型" class="headerlink" title="区间类型"></a>区间类型</h2><p>如下三种</p>
<ul>
<li>let range1: ClosedRange<Int> = 1…3</li>
<li>let range2: Range<Int> = 1..&lt;3</li>
<li>let range3: PartialRangeThrough<Int> = …5</li>
</ul>
<p>字符、字符串也可以使用区间运算符，但默认不能使用在for-in中<br>例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">这样写是可以的</span><br><span class="line"><span class="keyword">let</span> strRange = <span class="string">"a"</span>...<span class="string">"f"</span></span><br><span class="line">strRange.<span class="built_in">contains</span>(<span class="string">"d"</span>) <span class="comment">// true</span></span><br><span class="line">strRange.<span class="built_in">contains</span>(<span class="string">"l"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">但是下面是会报错的</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strRange &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>\0 到 “~” 包括了所有的要用到的ASCII字符<br>例如我们要判断一个字符是否是ASCII字符</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> characterRange: ClosedRange&lt;Character&gt; = <span class="string">"\0"</span><span class="params">...</span><span class="string">"~"</span></span><br><span class="line"><span class="comment">//想判断s是否是ASCII字符可以</span></span><br><span class="line">characterRange.contains(<span class="string">"s"</span>) <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="带间隔的区间值"><a href="#带间隔的区间值" class="headerlink" title="带间隔的区间值"></a>带间隔的区间值</h3><p>用到了 stride<br>看代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let all = <span class="number">100</span></span><br><span class="line">let <span class="built_in">int</span>erval = <span class="number">20</span></span><br><span class="line"><span class="comment">// res的取值为从 10 开始 每次间隔 20，直到100结束，</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> stride(<span class="keyword">from</span>: <span class="number">10</span>, to: all, by: <span class="built_in">int</span>erval) &#123;</span><br><span class="line">    print(res)</span><br><span class="line">&#125;<span class="comment">// 结果为</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//70</span></span><br><span class="line"><span class="comment">//90</span></span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul>
<li>case、default 后面不能写大括号{}</li>
<li>默认可以不写break，并不会贯穿到后面的条件</li>
</ul>
<p>例如</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> res &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"res = 0"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"res = 1"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"res = 2"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"other res"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为 res = 1</span></span><br></pre></td></tr></table></figure>

<p><strong>关键字 fallthrough</strong></p>
<p>如果我们想让其贯穿下去，就是用 fallthrough 这个关键字<br>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> res &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"res = 0"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"res = 1"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"res = 2"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"other res"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为</span></span><br><span class="line"><span class="comment">// res = 1</span></span><br><span class="line"><span class="comment">// res = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="switch中支持-字符串，字符类型"><a href="#switch中支持-字符串，字符类型" class="headerlink" title="switch中支持 字符串，字符类型"></a>switch中支持 字符串，字符类型</h3><p>例如</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">字符串</span><br><span class="line">let <span class="keyword">string</span> = <span class="string">"aaa"</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">string</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"aaa"</span>:</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"string is aaa"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"bbb"</span>:</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"string is bbb"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125; <span class="comment">// string is aaa</span></span><br><span class="line"></span><br><span class="line">字符类型</span><br><span class="line">let <span class="keyword">character</span>: Character = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">character</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>,<span class="string">"A"</span>:</span><br><span class="line">     <span class="keyword">print</span>(<span class="string">"string is a or A"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"string is not a or A"</span>)</span><br><span class="line">&#125; <span class="comment">//string is a or A</span></span><br></pre></td></tr></table></figure>

<h3 id="区间、元组匹配"><a href="#区间、元组匹配" class="headerlink" title="区间、元组匹配"></a>区间、元组匹配</h3><ul>
<li>可以用下划线_ 忽略某个值</li>
<li>可以对区间，和元组进行匹配</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">count</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"0"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1到4"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"5到10"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5到10</span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">let <span class="built_in">point</span> = (<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">point</span> &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"原点"</span>)</span><br><span class="line"><span class="keyword">case</span> (_, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x轴"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, _):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"y轴"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">-2.</span>.<span class="number">.2</span>, <span class="number">-2.</span>.<span class="number">.2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"区间"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x轴</span></span><br></pre></td></tr></table></figure>

<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> point2 = (<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> point2 &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"原点"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x轴 x是 \(x)"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"y轴 y是 \(y)"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"somewhere else at (\(x),\(y))"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x轴 x是 1</span></span><br></pre></td></tr></table></figure>


<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,]</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">num</span> <span class="keyword">in</span> numbers where <span class="built_in">num</span> &gt; <span class="number">2</span> &#123;</span><br><span class="line">    <span class="built_in">sum</span> += <span class="built_in">num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>) //<span class="number">12</span></span><br></pre></td></tr></table></figure>


<h2 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h2><p>标签语句用于执行的时候，跳转到标签的位置</p>
<p>例如</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.4</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.4</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> outer</span><br><span class="line">        &#125;</span><br><span class="line">         print(<span class="string">"i == \(i), k == \(k)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出为 </span><br><span class="line">i == <span class="number">1</span>, k == <span class="number">1</span></span><br><span class="line">i == <span class="number">1</span>, k == <span class="number">3</span></span><br><span class="line">i == <span class="number">1</span>, k == <span class="number">4</span></span><br><span class="line">i == <span class="number">2</span>, k == <span class="number">1</span></span><br><span class="line">i == <span class="number">2</span>, k == <span class="number">3</span></span><br><span class="line">i == <span class="number">2</span>, k == <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>如果加了标签</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.4</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.4</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> outer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> outer</span><br><span class="line">        &#125;</span><br><span class="line">         print(<span class="string">"i == \(i), k == \(k)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">输出为 </span><br><span class="line">i == <span class="number">1</span>, k == <span class="number">1</span></span><br><span class="line">i == <span class="number">2</span>, k == <span class="number">1</span></span><br></pre></td></tr></table></figure>




<p>参考资料:</p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift之基本运算、数据类型、元组</title>
    <url>/Swift%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%85%83%E7%BB%84.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>  Swift编程语言，支持多编程范式和编译式，用来撰写基于macOS/OS X、iOS、watchOS和tvOS的软件。 苹果公司于2014年在苹果开发者年会（WWDC）发布了Swift编程语言。从设计上苹果公司让Swift与Objective-C共存在苹果公司的操作系统上</p>
</blockquote>
<blockquote>
<p>苹果宣称Swift的特点是：快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译，可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果，能让Swift源代码在撰写过程中能即时显示出其运行结果</p>
</blockquote>
<blockquote>
<p>2015年6月8日，苹果于WWDC2015上宣布，Swift将开放源代码，包括编译器和标准库<br>2015年12月3日，苹果宣布<a href="https://github.com/apple/Swift" target="_blank" rel="noopener">开源Swift</a>，并支持Linux，苹果在新网站Swift.org和托管网站Github上开源了Swift，但苹果的app store并不支持开源的Swift，只支持苹果官方的Swift版本，官方版本会在新网站Swift.org上定期与开源版本同步</p>
</blockquote>
<p>之前由于每个版本都不兼容，所以对开发者不友好，每次新版本，就像学了一门新的语言。但是从Swift5开始，API终于稳定下来了。可以来总结，学习一下Swift了。</p>
<h2 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h2><ul>
<li>生成语法树: Swiftc -dump-ast main.Swift </li>
<li>生成最简洁的SIL代码:Swiftc -emit-sil main.Swift </li>
<li>生成LLVM IR代码: Swiftc -emit-ir main.Swift -o main.ll </li>
<li>生成汇编代码: Swiftc -emit-assembly main.Swift -o main.s</li>
</ul>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>不用编写main函数，Swift将全局范围内的首句可执行代码作为程序入口</li>
<li>一句代码尾部可以省略分号(;)</li>
<li>多句代码写到同一行时必须用分号(;)隔开 </li>
<li>用var定义变量，let定义常量，编译器能自动推断出变量\常量的类型</li>
<li>Playground可以快速预览代码效果，是学习语法的好帮手 <ul>
<li>Command + Shift + Enter: 运行整个Playground </li>
<li>Shift + Enter:运行截止到某一行代码</li>
</ul>
</li>
</ul>
<p>例如</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var <span class="attr">a</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">a</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span> = <span class="number">88</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span> = <span class="number">12</span> ; <span class="keyword">let</span> <span class="attr">d</span> = <span class="number">40</span></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>


<p>创建对象，例如view视图，控制器等也更简单</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>和OC一样，有单行注释，多行注释<br>例如</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>但是，Swift中增加了，注释的嵌套，比如这样是可以的</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="comment"> </span></span></span><br><span class="line"><span class="comment"><span class="comment"> // 单行注释</span></span></span><br><span class="line"><span class="comment"><span class="comment"> </span></span></span><br><span class="line"><span class="comment"><span class="comment"> 嵌套多行注释</span></span></span><br><span class="line"><span class="comment"><span class="comment"> */</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong><em>Playound的注释是支持markup(类似Markdown)语法的</em></strong></p>
<ul>
<li>开启markup:Editor-&gt;Show Rendered Markup</li>
<li>只能在Playground中使用</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>只能赋值1次</li>
<li>常量的值不要求在编译的时候确定，只要在使用之前赋值一次就可以了<br>例如下面都是可以的</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">num</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">num</span> += <span class="number">20</span></span><br><span class="line"><span class="built_in">num</span> += <span class="number">30</span></span><br><span class="line"><span class="built_in">let</span> age = <span class="built_in">num</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line">func getAge() -&gt; Int &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> age2 = getAge()</span><br><span class="line"><span class="built_in">print</span>(age2)</span><br></pre></td></tr></table></figure>

<p>但是下面这种是不可以的，因为在初始化之前，是不可以使用的</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">number</span>: <span class="built_in">Int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">number</span>)</span><br></pre></td></tr></table></figure>

<p>当然了，这种也是不行的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">number</span></span><br><span class="line"><span class="built_in">number</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>比如常量名，变量名，函数名等标识符</p>
<ul>
<li>标识符不能数字开头，不能包含空白字符，制表符，箭头灯特殊字符。</li>
<li>除此之外，几乎可以使用任何字符。</li>
</ul>
<h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><ol>
<li>值类型(value type)<ul>
<li>枚举(enum): optional</li>
<li>结构体(struct): Float、 Double、Float、Int、Character、String、Array、Dictionary、Set</li>
</ul>
</li>
<li>引用类型(reference type)<ul>
<li>类(class)</li>
</ul>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>不同类型之间的转换，比如</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数转换</span></span><br><span class="line"><span class="keyword">let</span> a: UInt16 = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> b: UInt8 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> c = a + <span class="constructor">UInt16(<span class="params">b</span>)</span></span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//整数和浮点数转换</span></span><br><span class="line"><span class="keyword">let</span> intNumber = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> doubleNumber = <span class="number">0.1415926</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="constructor">Double(<span class="params">intNumber</span>)</span> + doubleNumber</span><br><span class="line"><span class="keyword">let</span> intPi = <span class="constructor">Int(<span class="params">pi</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量可以直接相加，因为字面量没有明确的类型</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="number">3</span> + <span class="number">2.565</span></span><br></pre></td></tr></table></figure>


<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元祖可以把多个值保存在一起</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">格式: (数值<span class="number">1</span>, 数值<span class="number">2</span>, 数值<span class="number">3</span>)</span><br><span class="line">let numbers = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">// 可以通过索引访问</span></span><br><span class="line">numbers<span class="number">.0</span></span><br><span class="line">numbers<span class="number">.1</span></span><br><span class="line">numbers<span class="number">.2</span></span><br></pre></td></tr></table></figure>

<p>元祖中还可以保存不同的数据类型的值</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">let person = (<span class="built_in">name</span>: <span class="string">"lnj"</span>, age: <span class="number">30</span>, <span class="built_in">score</span>: <span class="number">100.0</span>)</span><br><span class="line"><span class="comment">// 可以通过名称访问</span></span><br><span class="line">person.<span class="built_in">name</span></span><br><span class="line">person.age</span><br><span class="line">person.<span class="built_in">score</span></span><br></pre></td></tr></table></figure>

<p>我们甚至可以这样子</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于同时定义了三个变量</span></span><br><span class="line">let (<span class="built_in">name</span>, age, <span class="built_in">score</span>) = (<span class="string">"lnj"</span>, <span class="number">30</span>, <span class="number">80</span>)</span><br><span class="line"><span class="built_in">name</span></span><br><span class="line">age</span><br><span class="line"><span class="built_in">score</span></span><br></pre></td></tr></table></figure>




<p>参考资料:</p>
<p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>
<p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>iOS逆向流程</title>
    <url>/iOS%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B.html/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://ityongzhen.github.io/categories">个人博客</a></p>
<h3 id="iOS逆向"><a href="#iOS逆向" class="headerlink" title="iOS逆向"></a>iOS逆向</h3><h5 id="准备：完美越狱iPhone"><a href="#准备：完美越狱iPhone" class="headerlink" title="准备：完美越狱iPhone"></a>准备：完美越狱iPhone</h5><p>逆向APP思路：1，代码分析</p>
<p>2，对Mach-O文件的静态分析MachOView、class-dump、Hopper Disassembler、ida等</p>
<p>3，动态调试 对运行中的APP进行代码调试 p debugserver、LLDB</p>
<p>4，代码编写</p>
<p>5，注入代码到APP中</p>
<p>6，必要时还可能需要重新签名、打包ipa</p>
<h4 id="一、Mac远程登录iPhone"><a href="#一、Mac远程登录iPhone" class="headerlink" title="一、Mac远程登录iPhone"></a>一、Mac远程登录iPhone</h4><ul>
<li><p>SSH (Secure Shell) 是“安全外壳协议”</p>
<p>OpenSSH 是SSH协议的免费开源实现 (在iPhone上通过Cydia安装OpenSSH工具(软件源<a href="http://apt.saurik.com" target="_blank" rel="noopener">http://apt.saurik.com</a>))</p>
<p>可以通过OpenSSH的方式让Mac远程登录到iPhone</p>
</li>
<li><p>SSH是通过TCP协议通信，所以要确保Mac和iPhone在同一局域网下，比如连接着同一个WiFi下</p>
<p>在终端输入</p>
</li>
</ul>
<p>ssh 账户名@服务器主机地址</p>
<p>例如：</p>
<p>ssh <a href="mailto:root@192.168.8.157">root@192.168.8.157</a>  然后输入密码(默认是alpine ) </p>
<p>这种方式wifi登录，受到网速限制</p>
<ul>
<li>usb连接 （不需要网络，速度快，安全） 1.1 sh usb.sh （注： python2 usbmuxd-1.0.8/python-client/tcprelay.py -t 22:10010 8888:8888）</li>
</ul>
<p>1.2  sh login.sh (注：ssh -p 10010 root@localhost)</p>
<p>上面的命令生效是因为已经把 usb.sh 和 login.sh 两个文件做了端口映射并放到了根目录 (映射需要usbmuxd工具包)</p>
<p>另外： 1.echo $PATH 查看设置的根目录，如果自己想写脚本在其他地方都能执行，也可以放在PATH路径下</p>
<p>2.手机和电脑能连接是因为，手机的授权文件 /var/root/.ssh/authorized_keys 中 添加了电脑的公钥 ~/.ssh/id_rsa.pub</p>
<p>Mac上有个服务程序usbmuxd（它会开机自动启动），可以将Mac的数据通过USB传输到iPhone</p>
<p>/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd</p>
<p>下载usbmuxd工具包（下载v1.0.8版本，主要用到里面的一个python脚本：<a href="http://tcprelay.py" target="_blank" rel="noopener">tcprelay.py</a>）</p>
<p><a href="https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz" target="_blank" rel="noopener">https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz</a></p>
<h4 id="二、获取手机上软件的ipa包"><a href="#二、获取手机上软件的ipa包" class="headerlink" title="二、获取手机上软件的ipa包"></a>二、获取手机上软件的ipa包</h4><ul>
<li><p>Cycript 安装到手机上</p>
<p>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物，可以用来探索、修改、调试正在运行的Mac\iOS APP</p>
<p>官网： <a href="http://www.cycript.org/" target="_blank" rel="noopener">http://www.cycript.org/</a></p>
<p>文档： <a href="http://www.cycript.org/manual/" target="_blank" rel="noopener">http://www.cycript.org/manual/</a></p>
<p>通过Cydia安装Cycript，即可在iPhone上调试运行中的APP</p>
<p>使用： cycript -p 进程ID 比如：cycript -p NewsBoard</p>
<p>cycript -p 进程名称</p>
<p>取消输入:Ctrl + C</p>
<p>退出:Ctrl + D</p>
<p>清屏:Command + R</p>
<p>Github 上有基于cycript封装了一些函数 参考</p>
<p><a href="https://github.com/CoderMJLee/mjcript" target="_blank" rel="noopener">https://github.com/CoderMJLee/mjcript</a></p>
<p>@import mjcript —&gt;MJAppId、MJFrontVC()、MJDocPath、MJAppPath 等</p>
</li>
<li><p>Clutch -i 获取加壳软件的appid</p>
</li>
<li><p>PS命令 （手机上安装adv-cmds）</p>
<p>ps –A 列出所有的进程</p>
</li>
</ul>
<p>ps命令是process status</p>
<p>可以过滤关键词，比如 : ps -A | grep WeChat</p>
<ul>
<li><p>也可以用github 上工具获取 <a href="https://github.com/CoderMJLee/MJAppTools" target="_blank" rel="noopener">https://github.com/CoderMJLee/MJAppTools</a></p>
<p>MJAppTools 可以获取到架构，名称，是否加壳，安装包路径，数据库路径等</p>
</li>
</ul>
<h4 id="三、脱壳"><a href="#三、脱壳" class="headerlink" title="三、脱壳"></a>三、脱壳</h4><ul>
<li>iOS中有很多好用的脱壳工具</li>
</ul>
<p>Clutch:<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch</a></p>
<p>dumpdecrypted:<a href="https://github.com/stefanesser/dumpdecrypted/" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted/</a></p>
<p>AppCrackr、Crackulous</p>
<ul>
<li><p>Clutch -i 获取到appid之后，Clutch -d (APP序号) 导出app包 eg: Clutch -d 1 会打印出脱壳路径</p>
</li>
<li><p>DYLD_INSERT_LIBRARIES 脱壳</p>
<p>例如：MJAppTools 获取 到 【网易新闻】 &lt;com.netease.news&gt;  /private/var/mobile/Containers/Bundle/Application/64F0B25C-062E-4A89-8834-3F534C24E70D/NewsBoard.app</p>
<p>执行：</p>
<blockquote>
<blockquote>
<p>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /private/var/mobile/Containers/Bundle/Application/64F0B25C-062E-4A89-8834-3F534C24E70D/NewsBoard.app/NewsBoard</p>
</blockquote>
</blockquote>
<p>获取到的脱壳文件再当前目录下 (Device/var/root)</p>
</li>
<li><p>查看是否脱壳</p>
<p>otool -l 名称 | grep crypt 例如： otool -l NewsBoard | grep crypt 查看网易新闻是否脱壳</p>
</li>
</ul>
<p>也可以用hopper看是否脱壳</p>
<p>cryptid 0 为脱壳 cryptid 1 是加壳</p>
<h4 id="四、反编译出头文件"><a href="#四、反编译出头文件" class="headerlink" title="四、反编译出头文件"></a>四、反编译出头文件</h4><ul>
<li><p>class-dump</p>
<p>顾名思义，它的作用就是把Mach-O文件的class信息给dump出来(把类信息给导出来)，生成对应的.h头文件</p>
</li>
</ul>
<p>官方地址:<a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">http://stevenygard.com/projects/class-dump/</a></p>
<p>下载完工具包后将class-dump文件复制到Mac的/usr/local/bin目录，这样在终端就能识别class-dump命令了</p>
<p>常用格式：</p>
<p>class-dump -H Mach-O文件路径 -o 头文件存放目录 -H表示要生成头文件 -o用于制定头文件的存放目录</p>
<p>例如：当前目录下 class-dump -H NewsBoard -o Header (新建一个Header的文件夹) 这时候可以用hopper 等分析代码了</p>
<h4 id="五、theos"><a href="#五、theos" class="headerlink" title="五、theos"></a>五、theos</h4><ul>
<li><p>􏰂􏰃􏰄安装签名工具ldid</p>
<p>1.先确保安装brew<br>$(curl -fsSL<br><a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p>
</li>
</ul>
<p>2.利用brew安装ldid</p>
<p>$ brew install ldid</p>
<ul>
<li><p>修改环境变量</p>
<ol>
<li>编辑用户配置文件</li>
</ol>
<p>$ vim ~/.bash_profile</p>
<p>2.在􏰝..bash_profie􏰛 文件后面加入下面两行</p>
<blockquote>
<p>export THEOS=~/theos<br>export PATH=$THEOS/bin:$PATH</p>
</blockquote>
<p>3,让.bash_profie配置的环境变量立即生效(或者重新打开终端)</p>
<blockquote>
<p>$ source ~/.bash_profile</p>
</blockquote>
</li>
<li><p>􏰣􏰵下载theos</p>
<p>建议在$PATH 目录下载代码(就是刚才配置的)</p>
<blockquote>
<p>$ git clone –recursive <a href="https://github.com/theos/theos.git" target="_blank" rel="noopener">https://github.com/theos/theos.git</a> $THEOS</p>
</blockquote>
</li>
<li><p>新建tweak 项目</p>
<p>1，cd到放文件的目录下（比如桌面</p>
<blockquote>
<p>$ cd ~/Desktop<br>$ nic.pl</p>
</blockquote>
<p>2，选择􏱋􏱌[13.] iphone/tweak</p>
<p>3，填写项目信息</p>
<p>名称 项目ID随便写， MobileSubstrate Bundle filter 写应用的id 其他回车</p>
</li>
</ul>
<h4 id="六、编写代码"><a href="#六、编写代码" class="headerlink" title="六、编写代码"></a>六、编写代码</h4><p>具体情况具体分析</p>
<h4 id="七、打包编译安装"><a href="#七、打包编译安装" class="headerlink" title="七、打包编译安装"></a>七、打包编译安装</h4><p>当前tweak文件目录下make clean &amp;&amp; make &amp;&amp; make package &amp;&amp; make install （已经写好了文件，可以直接 sh ~/tweak.sh</p>
<p>自己做的插件在 Device/Library/MobileSubstrate/DynamicLibraries</p>
<h4 id="八、theos资料"><a href="#八、theos资料" class="headerlink" title="八、theos资料"></a>八、theos资料</h4><ul>
<li><p>目录结构： <a href="https://github.com/theos/theos/wiki/Structure" target="_blank" rel="noopener">https://github.com/theos/theos/wiki/Structure</a></p>
</li>
<li><p>环境变量：<a href="http://iphonedevwiki.net/index.php/Theos" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/Theos</a></p>
</li>
<li><p>Logoes语法: <a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/Logos</a></p>
<ul>
<li><p>%hook %end : hook一个类的开始和结束</p>
</li>
<li><p>%log : 打印方法调用详情</p>
<p>可以 􏱧􏰢􏱨􏱩Xcode -&gt; Window -&gt; Devices and Simulators􏱪􏱫􏳕􏳖 中查看</p>
</li>
<li><p>HBDebugLog 类似NSLog</p>
</li>
<li><p>%new : 添加一个新的方法</p>
</li>
<li><p>%c(className)： 生成一个class对象，比如Class%c(NSObject) ，类似于NSStringFromClass()􏰁、objc_getClass()</p>
</li>
<li><p>%orig :  函数调用原来的逻辑</p>
</li>
<li><p>%ctor ： 在加载动态库时候调用</p>
</li>
<li><p>%dtor : 程序退出时调用</p>
</li>
<li><p>logify.pl： 可以将一个头文件快速转成已经包含打印信息的xm文件</p>
<blockquote>
<p>logify.pl xx.h &gt; xx.xm</pre></p>
</blockquote>
<pre><code>1，在 UserCenterViewController.h 目录下执行

logify.pl UserCenterViewController.h &gt; UserCenterViewController.xm

2， UserCenterViewController.xm 拷贝到Makefile(Tweak.xm) 所在目录

3, 新建一个src目录，把.xm文件放进去，修改路径 YZRongxin_FILES = $(wildcard src/*.xm)

4，不认识的类 替换为void 删除__weak 删除协议

5, 不想太详细 %log 换成NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));

6，HBLogDebug(@&quot; = 0x%x&quot;, (unsigned int)r) 改为 HBLogDebug(@&quot; = 0x%@&quot;, r)</code></pre></li>
</ul>
</li>
</ul>
<h4 id="九、MAC、IPhone-软件破解"><a href="#九、MAC、IPhone-软件破解" class="headerlink" title="九、MAC、IPhone 软件破解"></a>九、MAC、IPhone 软件破解</h4><p>例：PC软件破解 ./YZCTest</p>
<p>例：网易新闻去广告 NTESNBNewsListController hasAd</p>
<p>例：优酷去掉90s开头广告 XAdEnginePreAdModule setupVideoAd  needAd</p>
<p>如果是未越狱的IPhone 则还需要打包签名等操作。</p>
<h4 id="十、动态调试"><a href="#十、动态调试" class="headerlink" title="十、动态调试"></a>十、动态调试</h4><h4 id="十一、签名打包"><a href="#十一、签名打包" class="headerlink" title="十一、签名打包"></a>十一、签名打包</h4><ul>
<li><h4 id="准备一个embedded-mobileprovision文件（必须是付费证书产生的，appid-device一定要匹配）并放入到-app包中。"><a href="#准备一个embedded-mobileprovision文件（必须是付费证书产生的，appid-device一定要匹配）并放入到-app包中。" class="headerlink" title="准备一个embedded.mobileprovision文件（必须是付费证书产生的，appid,device一定要匹配）并放入到.app包中。"></a>准备一个embedded.mobileprovision文件（必须是付费证书产生的，appid,device一定要匹配）并放入到.app包中。</h4><ul>
<li><p>可以通过Xcode自动生成，然后再编译后的APP包中找到</p>
</li>
<li><p>可以去开发者网站生成证书下载</p>
</li>
</ul>
</li>
<li><p>从embedded.mobileprovision文件中提取出entitlements.plist权限文件</p>
<ul>
<li><p>security  cms  -D -i embedded.mobileprovision &gt; temp.plist</p>
</li>
<li><p>/usr/libexec/PlistBuddy -x -c’Print :Entitlements’ temp.plist &gt; entilements.plist</p>
</li>
</ul>
</li>
<li><p>查看可用的证书</p>
<ul>
<li>security find-identity -v -p codesigning</li>
</ul>
</li>
<li><p>对.app内的动态库、AppExtension等进行签名</p>
<ul>
<li>codesign -f -s 证书ID XXX.dylib</li>
</ul>
</li>
<li><p>对.app包进行签名</p>
<ul>
<li>codesign -f -s 证书id –entitlements entitlements.plist xxx.app</li>
</ul>
</li>
<li><p>重签名工具</p>
<ul>
<li><p>iOS App Signer</p>
<p>“&gt;<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="noopener">https://github.com/DanTheMan827/ios-app-signer</a></p>
<ul>
<li><p>对.app重签名，打包成ipa</p>
</li>
<li><p>需要再.app包中提供对应的embedded.mobileprovision文件</p>
</li>
</ul>
</li>
<li><p>iReSign</p>
<ul>
<li><p><a href="https://github.com/maciekish/iReSign" target="_blank" rel="noopener">https://github.com/maciekish/iReSign</a></p>
</li>
<li><p>可以对ipa进行重签名，打包成ipa</p>
</li>
<li><p>需要提供embedded.mobileprovision、entitlements.plist文件的路径</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="十二、其他笔记："><a href="#十二、其他笔记：" class="headerlink" title="十二、其他笔记："></a>十二、其他笔记：</h4><p>Tweak 技巧</p>
<p>1，加载 图片资源 创建 layout 文件夹 相当于Device/Library</p>
<p>图片会放在 在Device/Library/PreferenceLoader/Preference</p>
<p>2，自己做的插件在 Device/Library/MobileSubstrate/DynamicLibraries</p>
<p>3，#define YZFile(path) @”/Library/PreferenceLoader/Preferences/yzxmly/“ #path</p>
<p>4，多个文件，多个目录，引用头文件要使用路径比如 @import “abc/def/person.h”</p>
<p>5，路径 全路径，或者 <em>代替 比如：src/test.xm src/</em>.m （中间一个空格）</p>
<p>6，如果自己增加类，方法属性等，要声明的话</p>
<p>eg:</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> yzdefine</span><br><span class="line">​</span><br><span class="line">-(<span class="keyword">void</span>)vipReOpenPlayer;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@end</span>&lt;/pre&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(九)观察者模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%B9%9D)%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/设计模式之(九)观察者模式.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h3><p><a href="https://baike.baidu.com/item/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/5881786?fr=aladdin" target="_blank" rel="noopener">观察者模式</a>  属于行为型模式。</p>
<blockquote>
<p>观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>
</blockquote>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>抽象主题（Subject）：<br>它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>具体主题（Concrete Subject）：<br>将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</li>
<li>抽象观察者（Observer）：<br>为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li>
<li>具体观察者（Concrete Observer）：<br>实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调</li>
</ul>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要被改变。</li>
<li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象是紧密耦合的</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>观察者模式的主要的作用就是对对象解耦，将观察者和被观察者完全隔离。</li>
</ul>
<h4 id="观察者模式的优点"><a href="#观察者模式的优点" class="headerlink" title="观察者模式的优点"></a>观察者模式的优点</h4><ul>
<li>观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。</li>
</ul>
<h4 id="观察者模式的缺点"><a href="#观察者模式的缺点" class="headerlink" title="观察者模式的缺点"></a>观察者模式的缺点</h4><ul>
<li>在应用观察者模式时需要考虑一下开发小路问题，程序中包括一个被观察者和多个被观察者，开发和调试比较复杂，而且Java中的消息的通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。</li>
</ul>
<h2 id="iOS中的观察者模式"><a href="#iOS中的观察者模式" class="headerlink" title="iOS中的观察者模式"></a>iOS中的观察者模式</h2><p>一般两种：KVO和通知。通知比较简单，这里只说一下KVO</p>
<ul>
<li>KVO全称KeyValueObserving，俗称<strong>键值监听</strong>，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于KVO的实现机制，所以对属性才会发生作用，一般继承自NSObject的对象都默认支持KVO。</li>
<li>KVC和KVO都属于键值编程而且底层实现机制都是<strong>isa-swizzing</strong>。</li>
<li>KVO和NSNotificationCenter都是iOS中<strong>观察者模式</strong>的一种实现。KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听。</li>
<li>KVO可以监听单个属性的变化，也可以监听集合对象的变化。通过KVC的mutableArrayValueForKey:等方法获得代理对象，当代理对象的内部对象发生改变时，会回调KVO监听的方法。集合对象包含NSArray和NSSet。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>KVO是通过isa-swizzling技术实现的(这句话是整个KVO实现的重点)。</li>
<li>在运行时根据原类创建一个中间类，这个中间类是原类的子类，并动态修改当前对象的isa指向中间类。当修改 instance 对象的属性时，会调用 Foundation框架的 _NSSetXXXValueAndNotify 函数 ,该函数里面会先调用 willChangeValueForKey: 然后调用父类原来的 setter 方法修改值，最后是 didChangeValueForKey:。didChangeValueForKey 内部会触发监听器（Oberser）的监听方法observeValueForKeyPath:ofObject:change:context:</li>
<li>并且将class方法重写，返回原类的Class。</li>
</ul>
<h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>通过addObserver:forKeyPath:options:context:方法注册观察者，观察者可以接收keyPath属性的变化事件。</li>
<li>在观察者中实现observeValueForKeyPath:ofObject:change:context:方法，当keyPath属性发生改变后，KVO会回调这个方法来通知观察者。</li>
<li>当观察者不需要监听时，可以调用removeObserver:forKeyPath:方法将KVO移除。需要注意的是，调用removeObserver需要在观察者消失之前，否则会导致Crash。</li>
</ol>
<p>例如，我们定义一个 YZPerson 类 继承自 NSObject ，里面有name 和 age 两个属性</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic ,assign) int age;</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) NSString  *name;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>然后在ViewController中，写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   	<span class="comment">//调用方法</span></span><br><span class="line">    [<span class="keyword">self</span> setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@属性值改变了 - %@ - %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">  <span class="keyword">self</span>.person.name = <span class="string">@"ccc"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">11482</span>:<span class="number">141804</span>] 监听到&lt;YZPerson: <span class="number">0x6000004e8400</span>&gt;的name属性值改变了 - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = ccc;</span><br><span class="line">    old = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125; - <span class="number">1111</span>- <span class="number">1111</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>需要注意的是，上面代码中我们已经移除了监听，如果再次移除的话，就会crash</strong></p>
<p>例如</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   	<span class="comment">//调用方法</span></span><br><span class="line">    [<span class="keyword">self</span> setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">   <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">       <span class="comment">// 移除监听</span></span><br><span class="line">    [person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">    <span class="comment">// 再次移除</span></span><br><span class="line">     [person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除多次会报错 </p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">9261</span>:<span class="number">2171323</span>] *** Terminating app due <span class="keyword">to</span> uncaught exception <span class="comment">'NSRangeException', </span></span><br><span class="line">reason: <span class="comment">'Cannot remove an observer <span class="doctag">&lt;ViewController 0x139e07220&gt;</span> for the key path "name" </span></span><br><span class="line"><span class="keyword">from</span> &lt;YZPerson <span class="number">0x281322f20</span>&gt; because it <span class="keyword">is</span> <span class="keyword">not</span> registered <span class="keyword">as</span> an observer.<span class="comment">'</span></span><br></pre></td></tr></table></figure>


<p><strong>如果忘记移除的话，有可能下次收到这个属性的变化的时候，会carsh</strong></p>
<p>所以，我们要保证add和remove是成对出现的</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>更多关于KVO的内容，包括KVO的本质，KVO内部的流程，手动调用KVO等，可以参考之前的一篇文章<a href="https://ityongzhen.github.io/%E5%85%B3%E4%BA%8EKVO%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html">关于KVO看这篇就够了</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(八)访问者模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E5%85%AB)%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html/</url>
    <content><![CDATA[<p><a href="https://ityongzhen.github.io/设计模式之(八)访问者模式.html">本文首发于个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本文代码为java代码</strong></p>
<h3 id="什么是访问者模式"><a href="#什么是访问者模式" class="headerlink" title="什么是访问者模式"></a>什么是访问者模式</h3><p><a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">访问者模式</a>  属于行为型模式，在<a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">菜鸟教程</a>中的定义如下</p>
<blockquote>
<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
</blockquote>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>意图：主要将数据结构与数据操作分离。</li>
</ul>
<h3 id="主要解决："><a href="#主要解决：" class="headerlink" title="主要解决："></a>主要解决：</h3><ul>
<li>稳定的数据结构和易变的操作耦合问题。</li>
</ul>
<h3 id="何时使用："><a href="#何时使用：" class="headerlink" title="何时使用："></a>何时使用：</h3><ul>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</li>
</ul>
<h3 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h3><ul>
<li>在被访问的类里面加一个对外提供接待访问者的接口。</li>
</ul>
<h3 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h3><ul>
<li>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</li>
</ul>
<h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><ul>
<li>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>符合单一职责原则。 </li>
<li>优秀的扩展性。 3、灵活性。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>具体元素对访问者公布细节，违反了迪米特原则。 </li>
<li>具体元素变更比较困难。 </li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
</ul>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 </li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假设我们写了一个平衡二叉树，那么对应的肯定有对应的肯定有添加元素，删除元素，中序遍历，后序遍历…等等。我们就以中序遍历二叉树为例，先看不用访问者模式会有什么问题。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>创建<code>Node</code>节点类，有左子树，右子树，父节点</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public static class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">		Integer element;</span><br><span class="line">		<span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; left;</span><br><span class="line">		<span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; right;</span><br><span class="line">		<span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; parent;</span><br><span class="line">		public <span class="keyword">Node</span><span class="title">(Integer</span> element, <span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; parent) &#123;</span><br><span class="line">			this.element = element;</span><br><span class="line">			this.parent = parent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BinarySearchTree"><a href="#BinarySearchTree" class="headerlink" title="BinarySearchTree"></a>BinarySearchTree</h3><p>创建<code>BinarySearchTree</code>类，有size，根节点<code>root</code>, 添加，删除，遍历等等</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public class BinarySearchTree<span class="tag">&lt;Integer&gt;</span> &#123;</span><br><span class="line">	private int size;</span><br><span class="line">	public <span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; root;</span><br><span class="line">	</span><br><span class="line">	public void add(Integer element) &#123;</span><br><span class="line">		//添加的代码就不写了</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void remove(Integer element) &#123;</span><br><span class="line">		//删除的代码就不写了	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	... 其他接口</span><br><span class="line">	</span><br><span class="line">	// 中序遍历</span><br><span class="line">	</span><br><span class="line">	private void inorder(<span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">		if</span> (<span class="keyword">node</span> <span class="title">== null</span> ) return;</span><br><span class="line">	</span><br><span class="line">		// 遍历左子树</span><br><span class="line">		inorder(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">		// 打印</span><br><span class="line">		System.out.println(<span class="keyword">node</span>.<span class="title">element</span>);</span><br><span class="line">		</span><br><span class="line">		// 遍历右子树</span><br><span class="line">		inorder(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p>上面的代码是否也是可以用的，调用<code>inorder</code>遍历之后，这个二叉树可以按照中序遍历的方式打印出来，似乎没什么问题。但是仔细想想，其实存在问题的。因为这个我们写死了是打印出元素，假设我们真正使用的时候，不是想直接打印呢？而是想每个元素的值加上2 然后再打印呢？又或者每个元素的值加上10，而且不想打印呢?</p>
<p>你可能会说，那简单啊，直接改啊，例如每个元素的值加上2 然后再打印</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public class BinarySearchTree<span class="tag">&lt;Integer&gt;</span> &#123;</span><br><span class="line">	//... 其他接口</span><br><span class="line">	</span><br><span class="line">	// 中序遍历</span><br><span class="line">	</span><br><span class="line">	private void inorder(<span class="keyword">Node</span><span class="title">&lt;Integer</span>&gt; <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">		if</span> (<span class="keyword">node</span> <span class="title">== null</span> ) return;</span><br><span class="line">		// 遍历左子树</span><br><span class="line">		inorder(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">		</span><br><span class="line">		// 打印</span><br><span class="line">		System.out.println(<span class="keyword">node</span>.<span class="title">element</span> + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		// 遍历右子树</span><br><span class="line">		inorder(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来也没问题，既然是加上2再打印那就直接加上2再打印咯。但是有如下两个问题</p>
<ul>
<li>很麻烦，每次不同的场景都要修改遍历的实现</li>
<li>如果是我们提供给外界使用的话，尽量不要让使用者修改内部实现。</li>
</ul>
<p>也就是说，有没有一种不修改遍历的具体实现，就能满足不同场景下的遍历呢？答案是有的，就是访问者模式</p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class BinarySearchTree&lt;<span class="built_in">Integer</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> int size;</span><br><span class="line">	<span class="keyword">public</span> Node&lt;<span class="built_in">Integer</span>&gt; root;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="literal">void</span> add(<span class="built_in">Integer</span> element) &#123;</span><br><span class="line">		<span class="comment">//添加的代码就不写了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="literal">void</span> remove(<span class="built_in">Integer</span> element) &#123;</span><br><span class="line">		<span class="comment">//删除的代码就不写了	</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="params">...</span> 其他接口</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 中序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="literal">void</span> inorder(Visitor&lt;<span class="built_in">Integer</span>&gt; visitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (visitor == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		inorder(root, visitor);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="literal">void</span> inorder(Node&lt;<span class="built_in">Integer</span>&gt; node, Visitor&lt;<span class="built_in">Integer</span>&gt; visitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="built_in">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历左子树</span></span><br><span class="line">		inorder(node.left, visitor);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 元素给visitor，具体的逻辑由外界的visitor处理</span></span><br><span class="line">		visitor.visit(node.element);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历右子树</span></span><br><span class="line">		inorder(node.right, visitor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用访问者模式的调用"><a href="#使用访问者模式的调用" class="headerlink" title="使用访问者模式的调用"></a>使用访问者模式的调用</h3><p>这样修改之后，使用的时候</p>
<p>每个节点的值加上2再打印</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">BinarySearchTree&lt;<span class="type">Integer</span>&gt; bst = <span class="built_in">new</span> BinarySearchTree&lt;&gt;();</span><br><span class="line">bst.preorder(<span class="built_in">new</span> Visitor&lt;<span class="type">Integer</span>&gt;() &#123;</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> visit(<span class="type">Integer</span> element) &#123;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.print(element + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>每个节点的值加上10再打印</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">BinarySearchTree&lt;<span class="type">Integer</span>&gt; bst = <span class="built_in">new</span> BinarySearchTree&lt;&gt;();</span><br><span class="line">bst.preorder(<span class="built_in">new</span> Visitor&lt;<span class="type">Integer</span>&gt;() &#123;</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> visit(<span class="type">Integer</span> element) &#123;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.print(element + <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样的话，无论使用者如何更改需求，不同的场景下，都不用修改二叉树内部的遍历代码，都可以满足。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(七)外观模式(门面模式、过程模式)</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%B8%83)%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F(%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E3%80%81%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%BC%8F).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/设计模式之(七)外观模式(门面模式、过程模式).html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是外观模式"><a href="#什么是外观模式" class="headerlink" title="什么是外观模式"></a>什么是外观模式</h3><p><a href="https://baike.baidu.com/item/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/9592040?fr=aladdin" target="_blank" rel="noopener">外观模式</a>  属于结构型模式，在<a href="https://www.runoob.com/design-pattern/facade-pattern.html" target="_blank" rel="noopener">菜鸟教程</a>中的定义如下</p>
<blockquote>
<p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
</blockquote>
<blockquote>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/18/16ddddfa442651d5?w=560&h=306&f=jpeg&s=20330" alt=""></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<h4 id="主要解决："><a href="#主要解决：" class="headerlink" title="主要解决："></a>主要解决：</h4><p>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<h4 id="何时使用："><a href="#何时使用：" class="headerlink" title="何时使用："></a>何时使用：</h4><ul>
<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 </li>
<li>定义系统的入口。</li>
</ul>
<h4 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h4><p>客户端不与系统耦合，外观类与系统耦合。</p>
<h4 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h4><p>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<h4 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h4><ul>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 </li>
<li>JAVA 的三层开发模式。</li>
</ul>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul>
<li>为复杂的模块或子系统提供外界访问的模块。 </li>
<li>子系统相对独立。 </li>
<li>预防低水平人员带来的风险。</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>每天到公司开电脑，下班离开公司关电脑。而每次开电脑之后，都要打开Xcode、微信、QQ等等。而每次关电脑的时候，这些软件又会依次关闭。所以我们可以把这些设置为开机自启动。那么，每次开机的时候，只需要开电脑就行了，其他的我们不用关心，能自动开启。</p>
<h3 id="YZComputer"><a href="#YZComputer" class="headerlink" title="YZComputer"></a>YZComputer</h3><p>创建<code>YZComputer</code>类，给外界两个接口，分别是open和close</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZQQ.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZWeChat.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZXcode.h"</span></span></span><br><span class="line"></span><br><span class="line">@interface YZComputer : NSObject</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)<span class="built_in">close</span>;</span><br><span class="line">-(<span class="keyword">void</span>)<span class="built_in">open</span>;</span><br><span class="line"></span><br><span class="line">@<span class="built_in">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZComputer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZComputer</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZQQ * qq;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZWeChat * weChat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZXcode * xcode;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZComputer</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.qq = [[YZQQ alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.weChat = [[YZWeChat alloc]init];</span><br><span class="line">        <span class="keyword">self</span>.xcode = [[YZXcode alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)close&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    [<span class="keyword">self</span>.qq close];</span><br><span class="line">    [<span class="keyword">self</span>.weChat close];</span><br><span class="line">    [<span class="keyword">self</span>.xcode close];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)open&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    [<span class="keyword">self</span>.qq open];</span><br><span class="line">    [<span class="keyword">self</span>.weChat open];</span><br><span class="line">    [<span class="keyword">self</span>.xcode open];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="YZQQ"><a href="#YZQQ" class="headerlink" title="YZQQ"></a>YZQQ</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZQQ</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)close;</span><br><span class="line">-(<span class="keyword">void</span>)open;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZQQ.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZQQ</span></span></span><br><span class="line">-(<span class="keyword">void</span>)close&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)open&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="YZWeChat"><a href="#YZWeChat" class="headerlink" title="YZWeChat"></a>YZWeChat</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZWeChat</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)close;</span><br><span class="line">-(<span class="keyword">void</span>)open;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZWeChat.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZWeChat</span></span></span><br><span class="line">-(<span class="keyword">void</span>)close&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)open&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="YZXcode"><a href="#YZXcode" class="headerlink" title="YZXcode"></a>YZXcode</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZXcode</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)close;</span><br><span class="line">-(<span class="keyword">void</span>)open;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZXcode.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZXcode</span></span></span><br><span class="line">-(<span class="keyword">void</span>)close&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)open&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li><p>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</p>
</li>
<li><p>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</p>
</li>
<li><p>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</p>
</li>
<li><p>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</p>
</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li><p>外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了用户使用成本。</p>
</li>
<li><p>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</p>
</li>
<li><p>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
</li>
</ul>
<p><a href="https://github.com/ITyongzhen/iOS-DesignPatterns" target="_blank" rel="noopener">Demo地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(六)命令模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E5%85%AD)%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是命令模式"><a href="#什么是命令模式" class="headerlink" title="什么是命令模式"></a>什么是命令模式</h3><p><a href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/7277118" target="_blank" rel="noopener">命令模式</a>  属于行为型模式，在<a href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/7277118" target="_blank" rel="noopener">百度百科</a>中的定义如下</p>
<blockquote>
<p>在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/14/16dc9c2ffb89022e?w=1144&h=504&f=jpeg&s=69381" alt=""></p>
<h4 id="Command："><a href="#Command：" class="headerlink" title="Command："></a>Command：</h4><p>定义命令的接口，声明执行的方法。</p>
<h4 id="ConcreteCommand："><a href="#ConcreteCommand：" class="headerlink" title="ConcreteCommand："></a>ConcreteCommand：</h4><p>命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</p>
<h4 id="Receiver："><a href="#Receiver：" class="headerlink" title="Receiver："></a>Receiver：</h4><p>接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</p>
<h4 id="Invoker："><a href="#Invoker：" class="headerlink" title="Invoker："></a>Invoker：</h4><p>要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</p>
<h4 id="Client："><a href="#Client：" class="headerlink" title="Client："></a>Client：</h4><p>创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 </p>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul>
<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在当前控制器中心创建一个红色view,增加三个按钮，分别是放大，缩小，回退。对应的红色view就会放大，缩小，回退。</p>
<h3 id="ViewController"><a href="#ViewController" class="headerlink" title="ViewController"></a>ViewController</h3><p>创建<code>ViewController</code>类，显示redView,并有三个按钮</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Receiver.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"reduceCommand.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Invoker.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"amplifyCommand.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CommandProtocol.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  kccWidth [UIScreen mainScreen].bounds.size.width;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIView</span> * redView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Receiver * receiver;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">CGPoint</span> centerPoint =  <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.bounds.size.width/<span class="number">2</span>, <span class="keyword">self</span>.view.bounds.size.height/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">self</span>.redView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(centerPoint.x - <span class="number">50</span>/<span class="number">2</span>,centerPoint.y - <span class="number">50</span>/<span class="number">2</span>, <span class="number">50</span>, <span class="number">50</span>)];</span><br><span class="line">    <span class="keyword">self</span>.redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.redView];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.receiver = [[Receiver alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.receiver.redView = <span class="keyword">self</span>.redView;</span><br><span class="line">    <span class="keyword">self</span>.receiver.width = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 扩大</span></span><br><span class="line"><span class="comment">/// @param sender 扩大按钮</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)amplify:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    </span><br><span class="line">    amplifyCommand *command = [[amplifyCommand alloc]initWithReceiver:<span class="keyword">self</span>.receiver paramter:<span class="number">10</span>];</span><br><span class="line">    [[Invoker sharedInstance] addAndExcute:command];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 缩小</span></span><br><span class="line"><span class="comment">/// @param sender  缩小按钮</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)reduce:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">      reduceCommand *command = [[reduceCommand alloc]initWithReceiver:<span class="keyword">self</span>.receiver paramter:<span class="number">10</span>];</span><br><span class="line">       [[Invoker sharedInstance] addAndExcute:command];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 回退</span></span><br><span class="line"><span class="comment">/// @param sender 回退按钮</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)rollback:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="comment">// 回退操作</span></span><br><span class="line">    [[Invoker sharedInstance] rollBack];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="接收者Receiver"><a href="#接收者Receiver" class="headerlink" title="接收者Receiver"></a>接收者Receiver</h3><p>负责具体实现的细节</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Receiver</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIView</span> * redView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 扩大view</span></span><br><span class="line"><span class="comment">/// @param pamameter 边长</span></span><br><span class="line">-(<span class="keyword">void</span>)amplifyView:(<span class="built_in">CGFloat</span>)pamameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缩小view</span></span><br><span class="line"><span class="comment">/// @param pamameter 边长</span></span><br><span class="line">-(<span class="keyword">void</span>)reduceView:(<span class="built_in">CGFloat</span>)pamameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Receiver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> centerX [UIScreen mainScreen].bounds.size.width/2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> centerY [UIScreen mainScreen].bounds.size.height/2</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Receiver</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)amplifyView:(<span class="built_in">CGFloat</span>)pamameter&#123;</span><br><span class="line">    _width += pamameter;</span><br><span class="line">    _width = MIN(_width, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width);</span><br><span class="line">    _redView.frame = <span class="built_in">CGRectMake</span>(centerX - _width/<span class="number">2</span>,centerY - _width/<span class="number">2</span>, _width, _width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)reduceView:(<span class="built_in">CGFloat</span>)pamameter&#123;</span><br><span class="line">    _width -= pamameter;</span><br><span class="line">    _width = MAX(_width, <span class="number">30</span>);</span><br><span class="line">    _redView.frame = <span class="built_in">CGRectMake</span>(centerX - _width/<span class="number">2</span>,centerY - _width/<span class="number">2</span>, _width, _width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<h3 id="接口命令CommandProtocol"><a href="#接口命令CommandProtocol" class="headerlink" title="接口命令CommandProtocol"></a>接口命令CommandProtocol</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CommandProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">/// 执行命令</span></span><br><span class="line">- (<span class="keyword">void</span>)excute;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 撤销命令</span></span><br><span class="line">- (<span class="keyword">void</span>)backExcute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="具体的命令"><a href="#具体的命令" class="headerlink" title="具体的命令"></a>具体的命令</h3><h4 id="amplifyCommand-放大"><a href="#amplifyCommand-放大" class="headerlink" title="amplifyCommand 放大"></a>amplifyCommand 放大</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CommandProtocol.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Receiver.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">amplifyCommand</span> : <span class="title">NSObject</span>&lt;<span class="title">CommandProtocol</span>&gt;</span></span><br><span class="line"><span class="comment">// 绑定接收器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithReceiver:(Receiver *)receiver paramter:(<span class="built_in">CGFloat</span>)paramter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"amplifyCommand.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">amplifyCommand</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Receiver *receiver;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> paramter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">amplifyCommand</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithReceiver:(Receiver *)receiver paramter:(<span class="built_in">CGFloat</span>)paramter&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">self</span>.receiver = receiver;</span><br><span class="line">           <span class="keyword">self</span>.paramter = paramter;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">- (<span class="keyword">void</span>)excute &#123;</span><br><span class="line">    [<span class="keyword">self</span>.receiver amplifyView:<span class="keyword">self</span>.paramter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销命令</span></span><br><span class="line">- (<span class="keyword">void</span>)backExcute &#123;</span><br><span class="line">    [<span class="keyword">self</span>.receiver reduceView:<span class="keyword">self</span>.paramter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="reduceCommand-缩小"><a href="#reduceCommand-缩小" class="headerlink" title="reduceCommand 缩小"></a>reduceCommand 缩小</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CommandProtocol.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Receiver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">reduceCommand</span> : <span class="title">NSObject</span>&lt;<span class="title">CommandProtocol</span>&gt;</span></span><br><span class="line"><span class="comment">// 绑定接收器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithReceiver:(Receiver *)receiver paramter:(<span class="built_in">CGFloat</span>)paramter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"reduceCommand.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">reduceCommand</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Receiver *receiver;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> paramter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">reduceCommand</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithReceiver:(Receiver *)receiver paramter:(<span class="built_in">CGFloat</span>)paramter&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">self</span>.receiver = receiver;</span><br><span class="line">           <span class="keyword">self</span>.paramter = paramter;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">- (<span class="keyword">void</span>)excute &#123;</span><br><span class="line">    [<span class="keyword">self</span>.receiver reduceView:<span class="keyword">self</span>.paramter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销命令</span></span><br><span class="line">- (<span class="keyword">void</span>)backExcute &#123;</span><br><span class="line">    [<span class="keyword">self</span>.receiver amplifyView:<span class="keyword">self</span>.paramter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h3 id="请求者-Receiver"><a href="#请求者-Receiver" class="headerlink" title="请求者 Receiver"></a>请求者 Receiver</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"CommandProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Invoker</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退指令</span></span><br><span class="line">- (<span class="keyword">void</span>)rollBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加操作指令</span></span><br><span class="line">- (<span class="keyword">void</span>)addAndExcute:(<span class="keyword">id</span> &lt;CommandProtocol&gt;)command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Invoker.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Invoker</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *mArr; <span class="comment">//存储操作指令的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Invoker</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="keyword">static</span> Invoker *cls = <span class="literal">nil</span>;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">         cls = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">         cls.mArr = [[<span class="built_in">NSMutableArray</span> alloc]init];</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)rollBack&#123;</span><br><span class="line">    <span class="comment">// 1.获取数组中的最后一个操作</span></span><br><span class="line">      <span class="keyword">id</span> &lt;CommandProtocol&gt; command = <span class="keyword">self</span>.mArr.lastObject;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2.操作调用,撤销的步骤</span></span><br><span class="line">      [command backExcute];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 3.删除最后操作</span></span><br><span class="line">      [<span class="keyword">self</span>.mArr removeLastObject];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加操作指令</span></span><br><span class="line">- (<span class="keyword">void</span>)addAndExcute:(<span class="keyword">id</span> &lt;CommandProtocol&gt;)command &#123;</span><br><span class="line">    <span class="comment">// 1.把操作添加到数组</span></span><br><span class="line">    [<span class="keyword">self</span>.mArr addObject:command];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.让操作调用实现的协议方法</span></span><br><span class="line">    [command excute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><ul>
<li>降低对象之间的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个组合命令。</li>
<li>调用同一方法实现不同的功能</li>
</ul>
<h2 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h2><ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li>
</ul>
<p><a href="https://github.com/ITyongzhen/iOS-DesignPatterns" target="_blank" rel="noopener">Demo地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(五)生成器模式(建造模式)</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%BA%94)%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F(%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F).html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/设计模式之(五)生成器模式(建造模式)">个人博客</a>.html)</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是生成器模式"><a href="#什么是生成器模式" class="headerlink" title="什么是生成器模式"></a>什么是生成器模式</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">生成器模式</a> 又名：建造模式 属于创建型模式，在<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">wikipedia</a>中的定义如下</p>
<blockquote>
<p>生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
</blockquote>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>在以下情况使用生成器模式：</p>
<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>Builder 抽象建造者类<ul>
<li>为创建一个Product对象的各个部件指定抽象接口。</li>
</ul>
</li>
<li>ConcreteBuilder 建造者类<ul>
<li>实现Builder的接口以构造和装配该产品的各个部件。</li>
<li>定义并明确它所创建的表示。</li>
<li>提供一个检索产品的接口</li>
</ul>
</li>
<li>Director 导演类<ul>
<li>构造一个使用Builder接口的对象。</li>
</ul>
</li>
<li>Product 产品类<ul>
<li>表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="YZBuilderCar"><a href="#YZBuilderCar" class="headerlink" title="YZBuilderCar"></a>YZBuilderCar</h3><p>创建<code>YZBuilderCar</code>类，有两个属性，分别是名字和价格</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZBuilderCar</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,   <span class="keyword">strong</span>)<span class="built_in">NSString</span> *name;<span class="comment">// 名字</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">NSString</span> *price;<span class="comment">// 价格</span></span><br><span class="line"></span><br><span class="line">-(YZBuilderCar *)makeCar;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>实现如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZBuilderCar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZBuilderCar</span>()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZBuilderCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"我是一辆:%@ 车 价格:%@"</span>,<span class="keyword">self</span>.name,<span class="keyword">self</span>.price];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (YZProductCar *)makeCar&#123;</span><br><span class="line">    YZBuilderCar *car = [[YZBuilderCar alloc] init];</span><br><span class="line">    car.name = <span class="keyword">self</span>.name;</span><br><span class="line">    car.price = <span class="keyword">self</span>.price;</span><br><span class="line">    <span class="keyword">return</span>  car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="YZBMWCar和YZAudiCar继承自YZBuilderCar"><a href="#YZBMWCar和YZAudiCar继承自YZBuilderCar" class="headerlink" title="YZBMWCar和YZAudiCar继承自YZBuilderCar"></a><code>YZBMWCar</code>和<code>YZAudiCar</code>继承自<code>YZBuilderCar</code></h3><p>创建车型<code>YZBMWCar</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZProductCar.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZBMWCar</span> : <span class="title">YZBuilderCar</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZBMWCar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZBMWCar</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">@"宝马740Li"</span>;</span><br><span class="line">        <span class="keyword">self</span>.price = <span class="string">@"98万"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>创建车型<code>YZAudiCar</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZProductCar.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZAudiCar</span> : <span class="title">YZBuilderCar</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZAudiCar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZAudiCar</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">@"奥迪Q5"</span>;</span><br><span class="line">        <span class="keyword">self</span>.price = <span class="string">@"45万"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h3 id="YZDirector"><a href="#YZDirector" class="headerlink" title="YZDirector"></a><code>YZDirector</code></h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZBuilderCar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZDirector</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 建造一辆车</span></span><br><span class="line">+ (YZProductCar *)creatBuickCar:(YZBuilderCar *)builder;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZDirector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZDirector</span></span></span><br><span class="line">+ (YZProductCar *)creatBuickCar:(YZBuilderCar *)builder&#123;</span><br><span class="line">    YZProductCar *car = [builder makeCar];</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        YZBuilderCar *car = [[YZBMWCar alloc] init];</span><br><span class="line">        YZDirector *dir = [YZDirector creatBuickCar:car];</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,dir.description);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<blockquote>
<p>我是一辆:宝马740Li 车 价格:98万</p>
</blockquote>
<h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>首先，建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在Director类中对整体而言可以取得比较好的稳定性。</p>
<p>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的ConcreteBuilder类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。</p>
<h2 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h2><p>我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个”导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</p>
<p>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建造者模式与工厂模式类似，他们都是建造者模式，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。</p>
<p><a href="https://github.com/ITyongzhen/iOS-DesignPatterns" target="_blank" rel="noopener">Demo地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(四)原型模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E5%9B%9B)%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/设计模式之(四)原型模式.html">个人博客</a></p>
<h2 id="什么是原型模式"><a href="#什么是原型模式" class="headerlink" title="什么是原型模式"></a>什么是原型模式</h2><h3 id="原型模式定义"><a href="#原型模式定义" class="headerlink" title="原型模式定义"></a>原型模式定义</h3><p> 参考wikipedia中的定义<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">原型模式</a></p>
<blockquote>
<p>原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p>
</blockquote>
<blockquote>
<p>原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>
</blockquote>
<p>简单来说就是：可以通过深拷贝来快速而方便的创建一个新对象</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>百度百科中对深拷贝和浅拷贝这么说明的</p>
<ul>
<li><p>浅拷贝</p>
<ul>
<li>拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间，浅拷贝只是一种简单的拷贝，让几个对象公用一个内存，然而当内存销毁的时候，指向这个内存空间的所有指针需要重新定义，不然会造成野指针错误。</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>一个引用对象一般来说由两个部分组成：一个具名的Handle，也就是我们所说的声明（如变量）和一个内部（不具名）的对象，也就是具名Handle的内部对象。它在Manged Heap（托管堆）中分配，一般由新增引用对象的New方法是进行创建。深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。</li>
</ul>
</li>
</ul>
<h3 id="原型模式结构"><a href="#原型模式结构" class="headerlink" title="原型模式结构"></a>原型模式结构</h3><p>对应结构如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c65bac38a19cd8?w=1200&h=478&f=png&s=31510" alt=""></p>
<p><code>Prototype</code>声明了复制自身的接口。作为<code>Prototype</code>的实现，<code>ConcretePrototype</code>实现了复制自身的<code>clone</code>操作。这里的客户端是指使用了原型类实例的类。客户端通过<code>clone</code>创建了一个新的对象，即<code>prototype</code>的副本</p>
<h2 id="什么时候使用原型模式？"><a href="#什么时候使用原型模式？" class="headerlink" title="什么时候使用原型模式？"></a>什么时候使用原型模式？</h2><ul>
<li>需要创建的对象不依赖于具体的类型以及创建方式</li>
<li>具体实例化的对象类型是在运行期决定的</li>
<li>不同类型之间的差异紧紧是状态的组合</li>
<li>类型创建复杂,例如类型有复杂的嵌套</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>有类YZPerson继承自NSObject,有两个属性name 和 age. 因为NSObject NSCopying</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="使用Cocoa-Touch框架中的对象复制"><a href="#使用Cocoa-Touch框架中的对象复制" class="headerlink" title="使用Cocoa Touch框架中的对象复制"></a>使用Cocoa Touch框架中的对象复制</h3><p><code>Cocoa Touch</code>框架为<code>NSObject</code>的派生类提供了实现深拷贝的协议。<code>NSObject</code>的子类需要实现<code>NSCopying</code>协议以及其方法：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(id)</span>copyWithZone:<span class="params">(NSZone *)</span>zone;</span><br></pre></td></tr></table></figure>

<p>NSObject有一个实列方法叫做<code>-(id)copy</code>。默认的copy方法调用<code>[self copyWithZone:nil]</code>;对于采纳了<code>NSCopying</code>协议的子类，需要实现这个方法，否则会引发异常。</p>
<h3 id="不实现-copyWithZone"><a href="#不实现-copyWithZone" class="headerlink" title="不实现 copyWithZone:"></a>不实现 <code>copyWithZone:</code></h3><p>在<code>ViewController.m</code>中，有如下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="literal">[<span class="identifier">super</span> <span class="identifier">viewDidLoad</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    YZPerson *p1 = <span class="literal">[[YZP<span class="identifier">erson</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">    p1.name = @<span class="string">"jack"</span>;</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    YZPerson<span class="operator"> * </span>p2 = <span class="literal">[<span class="identifier">p1</span> <span class="identifier">copy</span>]</span>;</span><br><span class="line">    p2.name = @<span class="string">"rose"</span>;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"p1 = %@,p1.name = %@, p1.age = %d"</span>,<span class="params">p1</span>,<span class="params">p1</span>.<span class="params">name</span>,<span class="params">p1</span>.<span class="params">age</span>)</span>;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"p2 = %@,p2.name = %@, p2.age = %d"</span>,<span class="params">p2</span>,<span class="params">p2</span>.<span class="params">name</span>,<span class="params">p2</span>.<span class="params">age</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行起来时候，会崩溃</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSInvalidArgumentException', </span><br><span class="line">reason: '-[YZPerson copyWithZone:]: unrecognized selector sent to<span class="built_in"> instance </span>0x2832857e0'</span><br></pre></td></tr></table></figure>

<p>由崩溃可知，是找不到<code>copyWithZone</code>的实现。所以，<code>YZPerson.m</code>中，写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone&#123;</span><br><span class="line">    </span><br><span class="line">    YZPerson *p = [[YZPerson allocWithZone:zone] init];</span><br><span class="line">    p.name = <span class="keyword">self</span>.name;</span><br><span class="line">    p.age = <span class="keyword">self</span>.age;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在<code>ViewController.m</code>中，有如下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="literal">[<span class="identifier">super</span> <span class="identifier">viewDidLoad</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    YZPerson *p1 = <span class="literal">[[YZP<span class="identifier">erson</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">    p1.name = @<span class="string">"jack"</span>;</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    YZPerson<span class="operator"> * </span>p2 = <span class="literal">[<span class="identifier">p1</span> <span class="identifier">copy</span>]</span>;</span><br><span class="line">    p2.name = @<span class="string">"rose"</span>;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"p1 = %@,p1.name = %@, p1.age = %d"</span>,<span class="params">p1</span>,<span class="params">p1</span>.<span class="params">name</span>,<span class="params">p1</span>.<span class="params">age</span>)</span>;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"p2 = %@,p2.name = %@, p2.age = %d"</span>,<span class="params">p2</span>,<span class="params">p2</span>.<span class="params">name</span>,<span class="params">p2</span>.<span class="params">age</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-原型模式[<span class="number">5950</span>:<span class="number">1131770</span>] p1 = &lt;YZPerson: <span class="number">0x2826c2e00</span>&gt;,p1.name = jack, p1.age = <span class="number">10</span></span><br><span class="line">iOS-原型模式[<span class="number">5950</span>:<span class="number">1131770</span>] p2 = &lt;YZPerson: <span class="number">0x2826c2de0</span>&gt;,p2.name = rose, p2.age = <span class="number">10</span></span><br></pre></td></tr></table></figure>


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用<code>- (id)copyWithZone:(nullable NSZone *)zone</code>方法实现了深拷贝，通过<code>copy</code>方法（该方法默认调用<code>copyWithZone</code>方法）复制得到<code>p2</code>,从结果可以看出：深复制对象和和源对象的地址是不一样的：</p>
<p>需要注意的是,<code>- (id)copyWithZone:(NSZone *)zone;</code>已经被废弃，本案例仅仅为了说明这个设计模式而已。</p>
<blockquote>
<p>zone<br>This parameter is ignored. Memory zones are no longer used by Objective-C.</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">p1</span> = &lt;YZPerson: <span class="number">0</span>x2826c2e00&gt;</span><br><span class="line"><span class="attr">p2</span> = &lt;YZPerson: <span class="number">0</span>x2826c2de0&gt;</span><br></pre></td></tr></table></figure>




<p><a href="https://github.com/ITyongzhen/iOS-DesignPatterns" target="_blank" rel="noopener">Demo地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(三)单例模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%B8%89)%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html/</url>
    <content><![CDATA[<h2 id="本文首发于我的个人博客"><a href="#本文首发于我的个人博客" class="headerlink" title="本文首发于我的个人博客"></a>本文首发于<a href="https://ityongzhen.github.io/设计模式之(三)单例模式.html">我的个人博客</a></h2><h2 id="什么是单例"><a href="#什么是单例" class="headerlink" title="什么是单例"></a>什么是单例</h2><p>在开发中，单例模式应该是每个人都会用的，但是你真的深入了解过单例模式么？希望这篇文章能给你更加深入的认识。</p>
<h3 id="wikipedia中这么介绍"><a href="#wikipedia中这么介绍" class="headerlink" title="wikipedia中这么介绍"></a><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">wikipedia</a>中这么介绍</h3><blockquote>
<p>单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
</blockquote>
<blockquote>
<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
</blockquote>
<blockquote>
<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>
</blockquote>
<h2 id="苹果官方定义"><a href="#苹果官方定义" class="headerlink" title="苹果官方定义"></a>苹果官方定义</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32" target="_blank" rel="noopener">苹果官方示例</a>中如下定义单例</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> MyGizmoClass *sharedGizmoManager = <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line">+ (MyGizmoClass*)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sharedGizmoManager == <span class="literal">nil</span>) &#123;</span><br><span class="line">        sharedGizmoManager = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sharedGizmoManager;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> sharedManager] <span class="keyword">retain</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSUIntegerMax</span>;  <span class="comment">//denotes an object that cannot be released</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)autorelease</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题：为什么用了allocWithZone"><a href="#问题：为什么用了allocWithZone" class="headerlink" title="问题：为什么用了allocWithZone"></a>问题：为什么用了<code>allocWithZone</code></h3><h4 id="官方文档描述"><a href="#官方文档描述" class="headerlink" title="官方文档描述"></a>官方文档描述</h4><ul>
<li>官方文档对于<a href="https://developer.apple.com/documentation/objectivec/nsobject/1571945-allocwithzone" target="_blank" rel="noopener">allocWithZone</a> 的描述是</li>
</ul>
<blockquote>
<p>The isa instance variable of the new instance is initialized to a data structure that describes the class; memory for all other instance variables is set to 0.</p>
</blockquote>
<blockquote>
<p>You must use an init… method to complete the initialization process. For example:</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">&gt;TheClass *<span class="keyword">new</span><span class="type">Object</span> = [[TheClass allocWithZone:<span class="type">nil</span>] init];</span><br></pre></td></tr></table></figure>
<p>Do not override allocWithZone: to include any initialization code. Instead, class-specific versions of init… methods.</p>
<blockquote>
<p>This method exists for historical reasons; memory zones are no longer used by Objective-C.</p>
</blockquote>
<h4 id="文档提到，使用allocWithZone是因为保证分配对象的唯一性"><a href="#文档提到，使用allocWithZone是因为保证分配对象的唯一性" class="headerlink" title="文档提到，使用allocWithZone是因为保证分配对象的唯一性"></a>文档提到，使用<code>allocWithZone</code>是因为保证分配对象的唯一性</h4><p>原因是单例类只有一个唯一的实例，而平时我们在初始化一个对象的时候， <code>[[Class alloc] init]</code>，其实是做了两件事。 <code>alloc</code> 给对象分配内存空间，<code>init</code>是对对象的初始化，包括设置成员变量初值这些工作。而给对象分配空间，除了alloc方法之外，还有另一个方法： <code>allocWithZone</code>.</p>
<p>而实践证明，使用<code>alloc</code>方法初始化一个类的实例的时候，默认是调用了 <code>allocWithZone</code> 的方法。于是覆盖<code>allocWithZone</code>方法的原因已经很明显了：为了保持单例类实例的唯一性，需要覆盖所有会生成新的实例的方法，如果有人初始化这个单例类的时候不走<code>[[Class alloc] init]</code> ，而是直接 <code>allocWithZone</code>， 那么这个单例就不再是单例了，所以必须把这个方法也堵上。</p>
<h4 id="allocWithZone已经被废弃了"><a href="#allocWithZone已经被废弃了" class="headerlink" title="allocWithZone已经被废弃了"></a><code>allocWithZone</code>已经被废弃了</h4><blockquote>
<p>This method exists for historical reasons; memory zones are no longer used by Objective-C</p>
</blockquote>
<p>前面说了 <code>allocWithZone</code>是为了保证单例的唯一性，然而，文档中又说了<code>allocWithZone</code>已经被废弃了，只是因为历史原因才保留了这个接口。所以我们应该怎么使用单例呢？</p>
<h2 id="现代单例模式实现"><a href="#现代单例模式实现" class="headerlink" title="现代单例模式实现"></a>现代单例模式实现</h2><p>在前辈大牛的指引下，后人总能站的更高，看得更远</p>
<p>现代一般单例实现如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;</span><br><span class="line">  __<span class="keyword">strong</span> <span class="keyword">static</span> <span class="keyword">id</span> _sharedObject = <span class="literal">nil</span>;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    _sharedObject = [[<span class="keyword">self</span> alloc] init]; <span class="comment">// or some other init method</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> _sharedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h2><h3 id="synchronized-和dispatch-once对比"><a href="#synchronized-和dispatch-once对比" class="headerlink" title="@synchronized 和dispatch_once对比"></a><code>@synchronized</code> 和<code>dispatch_once</code>对比</h3><p>我们之所以使用<code>dispatch_once</code> 主要是因为为了加锁保证单例的唯一性，因为苹果官方推荐的<code>allocWithZone</code>已经被废弃了。那么问题来了，如果要加锁来保证单例的唯一性，也可以用<code>@synchronized</code>呀，为什么用的是 <code>dispatch_once</code>，而不是<code>@synchronized</code>呢</p>
<p>国外有开发者做过性能测试<a href="http://webcache.googleusercontent.com/search?q=cache:http://blog.bjhomer.com/2011/09/synchronized-vs-dispatchonce.html" target="_blank" rel="noopener">@synchronized 和dispatch_once对比</a>。在单线程和多线程情况下测试了 <code>@synchronized</code> 与 <code>dispatch_once</code> 实现单例的性能对比，结果如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Single threaded results</span><br><span class="line">-----------------------</span><br><span class="line"><span class="code">  @synchronized: 3.3829 seconds</span></span><br><span class="line"><span class="code">  dispatch_once: 0.9891 seconds</span></span><br><span class="line"></span><br><span class="line">Multi threaded results</span><br><span class="line">----------------------</span><br><span class="line"><span class="code">  @synchronized: 33.5171 seconds</span></span><br><span class="line"><span class="code">  dispatch_once: 1.6648 seconds</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>dispatch_once</code> 在线程竞争环境下性能显著优于 <code>@synchronized</code>。</p>
<h3 id="dispatch-once分析"><a href="#dispatch-once分析" class="headerlink" title="dispatch_once分析"></a><code>dispatch_once</code>分析</h3><p>在 <code>Objective-C</code> 中，<code>@synchronized</code> 是用 <code>NSRecursiveLock</code> 实现的，并且隐式添加一个 <code>exception handler</code>，如果有异常抛出，<code>handler</code> 会自动释放互斥锁。而 <code>dispatch_once</code> 之所以拥有高性能是因为它省去了锁操作，代替的是大量的原子操作，该原子操作内部不是靠 <code>pthread</code> 等锁来实现，而是直接利用了 <code>lock</code> 的汇编指令，靠底层 CPU 指令来支持的。</p>
<p>我们如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">static</span> <span class="keyword">id</span> _sharedObject = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before dispatch_once onceToken = %ld"</span>,onceToken);</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"before dispatch_once onceToken = %ld"</span>,onceToken);</span><br><span class="line">        _sharedObject = [[<span class="keyword">self</span> alloc] init]; <span class="comment">// or some other init method</span></span><br><span class="line">    &#125;);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"before dispatch_once onceToken = %ld"</span>,onceToken);</span><br><span class="line">    <span class="keyword">return</span> _sharedObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在<code>dispatch_once</code>之前，进行中，之后，分别打印<code>onceToken</code>的值。</p>
<p>多次调用单例</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[YZPerson sharedInstance]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[YZPerson sharedInstance]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[YZPerson sharedInstance]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[YZPerson sharedInstance]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[YZPerson sharedInstance]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">0</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">772</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br><span class="line">iOS-单例模式[<span class="number">8255</span>:<span class="number">91704</span>] before dispatch_once onceToken = <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过输出我们可以发现，在 <code>dispatch_once</code> 执行前，<code>onceToken</code> 的值是 0，因为 <code>dispatch_once_t</code> 是由 <code>typedef long dispatch_once_t</code> 而来，所以在 <code>onceToken</code> 还没被手动赋值的情况下，0 是编译器给 <code>onceToken</code> 的初始化赋值。</li>
<li>在 <code>dispatch_once</code> 执行过程中，<code>onceToken</code> 是一个很大的数字，这个值是 <code>dispath_once</code> 内部实现中一个局部变量的地址，并不是一个固定的值。</li>
<li>当 <code>dispatch_once</code> 执行完毕，<code>onceToken</code> 的值被赋为 -1。之后再次调用的时候，<code>onceToken</code>已经是-1了，就直接跳过<code>dispatch_once</code>的执行</li>
</ul>
<h3 id="dispatch-once-使用场景"><a href="#dispatch-once-使用场景" class="headerlink" title="dispatch_once 使用场景"></a><code>dispatch_once</code> 使用场景</h3><p>所以 <code>dispatch_once</code> 的实现需要满足以下三种场景的需求：</p>
<ol>
<li><code>dispatch_once</code> 第一次执行，<code>block</code> 被调用，调用结束需标记 <code>onceToken</code>。</li>
<li><code>dispatch_once</code> 第一次执行过程中，有其它线程执行该 <code>dispatch_once</code>，则其它线程的请求需要等待 <code>dispatch_once</code> 的第一次执行结束才能被处理。</li>
<li><code>dispatch_once</code> 第一次执行已经结束，有其它线程执行该 <code>dispatch_once</code>，则其它线程直接跳过 block 执行后续任务。</li>
</ol>
<p>由于场景 1 只会发生一次，场景 2 发生的次数也是有限的，甚至根本不会发生，而场景 3 的发生次数可能是非常高的数量级，也正是影响 <code>dispatch_once</code> 性能的关键所在。</p>
<h4 id="对于场景三的优化："><a href="#对于场景三的优化：" class="headerlink" title="对于场景三的优化："></a>对于场景三的优化：</h4><p>OC中，<code>dispatch_once</code>的代码是开源的，我们直接查看源码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#ifdef __BLOCKS__</span><br><span class="line"><span class="constructor">__OSX_AVAILABLE_STARTING(<span class="params">__MAC_10_6</span>,<span class="params">__IPHONE_4_0</span>)</span>  </span><br><span class="line">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW  </span><br><span class="line">void  </span><br><span class="line">dispatch<span class="constructor">_once(<span class="params">dispatch_once_t</span> <span class="operator">*</span><span class="params">predicate</span>, <span class="params">dispatch_block_t</span> <span class="params">block</span>)</span>;</span><br><span class="line"></span><br><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW  </span><br><span class="line">void  </span><br><span class="line"><span class="constructor">_dispatch_once(<span class="params">dispatch_once_t</span> <span class="operator">*</span><span class="params">predicate</span>, <span class="params">dispatch_block_t</span> <span class="params">block</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 告诉 CPU *predicate 等于 ~0l 的可能性非常高，</span></span><br><span class="line">    <span class="comment">// 这就使得 CPU 预测不进入 if 分支，提前取后续指令，译码，</span></span><br><span class="line">    <span class="comment">// 甚至提前计算一些结果，提高效率，</span></span><br><span class="line">    <span class="comment">// 场景 3 的性能优化主要在此体现</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">DISPATCH_EXPECT(<span class="operator">*</span><span class="params">predicate</span>, ~0l)</span> != ~<span class="number">0l</span>) &#123;</span><br><span class="line">        dispatch<span class="constructor">_once(<span class="params">predicate</span>, <span class="params">block</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#undef dispatch_once</span><br><span class="line">#define dispatch_once _dispatch_once</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>


<p>通过宏定义 <code>#define dispatch_once _dispatch_once</code>可知，我们实际调用的是 <code>_dispatch_once</code>方法，并且是强制 <code>inline</code>。<code>DISPATCH_EXPECT</code> 是 <code>__builtin_expect((x), (v))</code> 的宏替换，<code>long __builtin_expect (long EXP, long C)</code> 是 GCC 提供的内建函数来处理分支预测，EXP 为一个整型表达式，这个内建函数的返回值也是 EXP，C 为一个编译期常量。这个函数相当于告诉编译器，EXP == C 的可能性非常高，其作用是帮助编译器判断条件跳转的预期值，编译器会产生相应的代码来优化 CPU 执行效率，CPU 遇到条件转移指令时会提前预测并装载某个分支的指令，避免跳转造成时间乱费，但并没有改变其对真值的判断，如果分支预测错了，就会丢弃之前的指令，从正确的分支重新开始执行。</p>
<h4 id="对于场景一，场景二的处理："><a href="#对于场景一，场景二的处理：" class="headerlink" title="对于场景一，场景二的处理："></a>对于场景一，场景二的处理：</h4><p>在 <code>dispatch_once</code> 的写入端来保证，实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> _dispatch_once_waiter_s &#123;  </span><br><span class="line">    volatile <span class="keyword">struct</span> _dispatch_once_waiter_s *volatile dow_next;</span><br><span class="line">    <span class="comment">// _dispatch_thread_semaphore_t 是 unsigned long 类型的别名，用来表示信号量</span></span><br><span class="line">    _dispatch_thread_semaphore_t dow_sema;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 DISPATCH_ONCE_DONE 定义为 _dispatch_once_waiter_s 类型的指针，</span></span><br><span class="line"><span class="comment">// ~0l 是 long 的 0 取反，也就是一大堆 1（输出为 -1），是个无效的指针，</span></span><br><span class="line"><span class="comment">// 即指向的地址不可能为一个有效的 _dispatch_once_waiter_s 类型，</span></span><br><span class="line"><span class="comment">// 用来标记 onceToken，表示 dispatch_once 第一次执行已经完成</span></span><br><span class="line">#define DISPATCH_ONCE_DONE ((<span class="keyword">struct</span> _dispatch_once_waiter_s *)~<span class="number">0l</span>)</span><br><span class="line"></span><br><span class="line">#ifdef __BLOCKS__</span><br><span class="line">void  </span><br><span class="line">dispatch<span class="constructor">_once(<span class="params">dispatch_once_t</span> <span class="operator">*</span><span class="params">val</span>, <span class="params">dispatch_block_t</span> <span class="params">block</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dispatch_block_t 的类型定义：typedef void (^dispatch_block_t)(void)</span></span><br><span class="line">    <span class="keyword">struct</span> Block_basic *bb = (void *)block;</span><br><span class="line">    <span class="comment">// 执行 block 最终是调用 C 函数</span></span><br><span class="line">    dispatch<span class="constructor">_once_f(<span class="params">val</span>, <span class="params">block</span>, (<span class="params">void</span> <span class="operator">*</span>)</span>bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">// val 即外部传入的 &amp;onceToken，ctxt 传入指向 block 的指针，可取到 block 上下文，</span></span><br><span class="line"><span class="comment">// dispatch_function_t 的类型定义：typedef void (*dispatch_function_t)(void *)</span></span><br><span class="line"><span class="comment">// func 是 block 内部的函数指针，指向函数执行体，执行它就是执行 block</span></span><br><span class="line">DISPATCH_NOINLINE  </span><br><span class="line">void  </span><br><span class="line">dispatch<span class="constructor">_once_f(<span class="params">dispatch_once_t</span> <span class="operator">*</span><span class="params">val</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">ctxt</span>, <span class="params">dispatch_function_t</span> <span class="params">func</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// volatile 是一个类型修饰符，用来修饰被不同线程访问和修改的变量，</span></span><br><span class="line">    <span class="comment">// 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，</span></span><br><span class="line">    <span class="comment">// 优化器在用到这个变量时必须重新从它所在的内存读取数据，而不是使用保存在寄存器里的备份</span></span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s<span class="operator"> * </span>volatile *vval =</span><br><span class="line">            (<span class="keyword">struct</span> _dispatch_once_waiter_s**)<span class="keyword">val</span>;</span><br><span class="line">    <span class="comment">// dow 意为 dispatch_once waiter</span></span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s dow = &#123; NULL, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">    _dispatch_thread_semaphore_t sema;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_atomic_cmpxchg 是原子比较交换函数 __sync_bool_compare_and_swap 的宏替换，</span></span><br><span class="line">    <span class="comment">// 原理是大致如下（真正的实现并非如此）：</span></span><br><span class="line">    <span class="comment">//     if(*vval == NULL)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         *vval = &amp;dow;</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     else</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return false;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// 当 dispatch_once 第一次执行时，*vval 为 0，</span></span><br><span class="line">    <span class="comment">// 则 *vval 被值赋值为 &amp;dow 并返回 true，</span></span><br><span class="line">    <span class="comment">// 此时 *vval 的值是类似上文中的 140734723410256</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch<span class="constructor">_atomic_cmpxchg(<span class="params">vval</span>, NULL, &amp;<span class="params">dow</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// 空的宏替换，什么都不做</span></span><br><span class="line">        dispatch<span class="constructor">_atomic_acquire_barrier()</span>;</span><br><span class="line">        <span class="comment">// _dispatch_client_callout 实际上就是调用了func，执行了 block，即初始化并写入 obj</span></span><br><span class="line">        <span class="constructor">_dispatch_client_callout(<span class="params">ctxt</span>, <span class="params">func</span>)</span>;</span><br><span class="line"></span><br><span class="line">        dispatch<span class="constructor">_atomic_maximally_synchronizing_barrier()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dispatch_atomic_xchg 原子交换函数 __sync_swap 的宏替换，</span></span><br><span class="line">        <span class="comment">// 执行的操作是：</span></span><br><span class="line">        <span class="comment">//         temp = *vval;</span></span><br><span class="line">        <span class="comment">//         *vval = DISPATCH_ONCE_DONE;</span></span><br><span class="line">        tmp = dispatch<span class="constructor">_atomic_xchg(<span class="params">vval</span>, DISPATCH_ONCE_DONE)</span>;</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="comment">// 若在 block 执行过程中，没有其它线程进入线程等待分支来等待，</span></span><br><span class="line">        <span class="comment">// 则 *vval == &amp;dow，即 tmp == &amp;dow，while 循环不会被执行，分支结束，</span></span><br><span class="line">        <span class="comment">// 若有其它线程进入线程等待分支来等待，那么会构造一个信号量链表，</span></span><br><span class="line">        <span class="comment">// *vval 变为信号量链的头部，&amp;dow 为链表的尾部，</span></span><br><span class="line">        <span class="comment">// 则在此 while 循环中，遍历链表来 signal 每个信号量</span></span><br><span class="line">         <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="comment">// 因为线程等待分支会中途将 val（即 *vval）赋值为 &amp;dow，</span></span><br><span class="line">            <span class="comment">// 然后再为 val-&gt;dow_next 赋值，</span></span><br><span class="line">            <span class="comment">// 在 val-&gt;dow_next 赋值之前其值为 NULL，需要等待，</span></span><br><span class="line">            <span class="comment">// pause 就像 nop，延迟空等，主要是提高性能和节省 CPU 耗电</span></span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                <span class="constructor">_dispatch_hardware_pause()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            <span class="constructor">_dispatch_thread_semaphore_signal(<span class="params">sema</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = <span class="constructor">_dispatch_get_thread_semaphore()</span>;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            tmp = *vval;</span><br><span class="line">            <span class="comment">// 如果发现 *vval 已经为 DISPATCH_ONCE_DONE，则直接break，</span></span><br><span class="line">            <span class="comment">// 然后调用 _dispatch_put_thread_semaphore 销毁信号量</span></span><br><span class="line">            <span class="keyword">if</span> (tmp<span class="operator"> == </span>DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 空的宏替换，什么都不做</span></span><br><span class="line">            dispatch<span class="constructor">_atomic_store_barrier()</span>;</span><br><span class="line">            <span class="comment">// 如果 *vval 不为 DISPATCH_ONCE_DONE，则进行原子比较并交换操作，</span></span><br><span class="line">            <span class="comment">// 如果期间有其它线程同时进入线程等待分支并交错修改链表，则可能导致 *vval != tmp，</span></span><br><span class="line">            <span class="comment">// 则 for 循环重新开始，重新获取一次 vval 来进行同样的操作，</span></span><br><span class="line">            <span class="comment">// 若 *vval == tmp，则将 *vval 赋值为 &amp;dow，</span></span><br><span class="line">            <span class="comment">// 接着执行 dow.dow_next = tmp 增加链表节点，然后等待信号量，</span></span><br><span class="line">            <span class="comment">// 当 block 执行分支完成并遍历链表来 signal 时，结束等待往下执行</span></span><br><span class="line">            <span class="keyword">if</span> (dispatch<span class="constructor">_atomic_cmpxchg(<span class="params">vval</span>, <span class="params">tmp</span>, &amp;<span class="params">dow</span>)</span>) &#123;</span><br><span class="line">             dow.dow_next = tmp;</span><br><span class="line">                <span class="constructor">_dispatch_thread_semaphore_wait(<span class="params">dow</span>.<span class="params">dow_sema</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="constructor">_dispatch_put_thread_semaphore(<span class="params">dow</span>.<span class="params">dow_sema</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于 CPU 的流水线特性，有一种边缘状况可能出现。假如线程 a 在初始化并写入 obj 尚未完成时，线程 b 读取了 obj，则此时 obj 为 nil，而线程 b 在线程 a 置 <code>predicate</code> 为 <code>DISPATCH_ONCE_DONE</code> 之后读取 <code>predicate</code>，线程 b 会认为 obj 初始化已经完成，将空的 obj 返回，那么接下来关于 obj 函数调用可能会导致程序崩溃。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/13/16be9648b12ac997?w=708&h=390&f=png&s=379900" alt=""></p>
<p>假如写入端能在 初始化并写入 obj 与 置 <code>predicate</code> 为 <code>DISPATCH_ONCE_DONE</code> 之间等待足够长的时间，即满足 Ta &gt; Tb，那上述的问题就都解决了。因此 <code>dispatch_once</code> 在执行了 block 之后，会调用 <code>dispatch_atomic_maximally_synchronizing_barrier()</code> 宏函数，在 intel 处理器上，这个函数编译出的是 cpuid 指令，并强制将指令流串行化，在其他厂商处理器上，这个宏函数编译出的是合适的其它指令，这些指令都将耗费可观数量的 CPU 时钟周期，以保证 Ta &gt; Tb。</p>
<h3 id="总结，为了性能的优化，dispatch-once做到了极致"><a href="#总结，为了性能的优化，dispatch-once做到了极致" class="headerlink" title="总结，为了性能的优化，dispatch_once做到了极致"></a>总结，为了性能的优化，<code>dispatch_once</code>做到了极致</h3><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>前面说了这么多单例，实际使用的时候，我们可以用宏来定义，以后只需要一行就可以了。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define SYNTHESIZE_SINGLETON_FOR_CLASS_HEADER(className) \</span></span><br><span class="line">\</span><br><span class="line">+ (className *)<span class="keyword">sharedInstance;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">#define </span>SYNTHESIZE_SINGLETON_FOR_CLASS(className) \</span><br><span class="line">\</span><br><span class="line">+ (className *)<span class="keyword">sharedInstance </span>&#123; \</span><br><span class="line">static className *<span class="keyword">sharedInstance </span>= nil<span class="comment">; \</span></span><br><span class="line">static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">; \</span></span><br><span class="line"><span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123; \</span><br><span class="line"><span class="keyword">sharedInstance </span>= [[self alloc] init]<span class="comment">; \</span></span><br><span class="line">&#125;)<span class="comment">; \</span></span><br><span class="line">return <span class="keyword">sharedInstance; </span>\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//YZPerson类单例的声明</span></span><br><span class="line"><span class="function"><span class="title">SYNTHESIZE_SINGLETON_FOR_CLASS_HEADER</span><span class="params">(YZPerson)</span></span></span><br><span class="line"><span class="comment">// YZPerson类单例的实现</span></span><br><span class="line"><span class="function"><span class="title">SYNTHESIZE_SINGLETON_FOR_CLASS</span><span class="params">(YZPerson)</span></span></span><br></pre></td></tr></table></figure>


<p>参考资料：</p>
<p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1571945-allocwithzone" target="_blank" rel="noopener">苹果关于allocWithZone的文档</a></p>
<p><a href="http://blog.jimmyis.in/dispatch_once/" target="_blank" rel="noopener">GCD 中 dispatch_once 的性能与实现</a></p>
<p><a href="https://justinyan.me/post/1306" target="_blank" rel="noopener">从 Objective-C 里的 Alloc 和 AllocWithZone 谈起</a></p>
<p><a href="http://webcache.googleusercontent.com/search?q=cache:http://blog.bjhomer.com/2011/09/synchronized-vs-dispatchonce.html" target="_blank" rel="noopener">@synchronized 和dispatch_once对比</a></p>
<p>更多资料，欢迎关注个人公众号，不定时分享各种技术文章。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/23/16cbc63186bd64cc?w=258&h=258&f=jpeg&s=27560" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(二)生产者-消费者</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%BA%8C)%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85.html/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://ityongzhen.github.io/设计模式之(二)生产者-消费者.html">我的个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">维基百科中</a>，这么描述 生产者消费者问题</p>
<blockquote>
<p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多进程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
</blockquote>
<blockquote>
<p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法[1]等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们公司自己项目中，有个场景，就是IM消息，当我们收到消息时候，进行一些业务逻辑的处理，还有数据库的操作，然后刷新列表。存在的问题是，如果消息接收的特别快，例如离线消息，可能登陆的是，有几百条消息拉取下来，如果每一条每一条的处理，将会导致两个问题：</p>
<ul>
<li>上次刷新还没完成，下次就进来了。导致界面闪的问题</li>
<li>每条消息进行一次写入数据库操作，IO操作耗时，所以导致，性能问题严重</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>上述问题，使用生产者-消费者就能解决这个问题</p>
<p>为了简单高效。我们用计时器，间隔0.1秒接收一条消息，刷新列表，假设需要2秒。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;<span class="comment">//存放数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) dispatch_semaphore_t semaphore;</span><br></pre></td></tr></table></figure>

<h3 id="开启定时器"><a href="#开启定时器" class="headerlink" title="开启定时器"></a>开启定时器</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">NSTimer *curTimer =[NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">0.1</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">producerFuncWithNumber:</span>) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>curTimer <span class="string">forMode:</span>NSDefaultRunLoopMode];</span><br><span class="line">[curTimer fire];</span><br></pre></td></tr></table></figure>

<h3 id="假设0-1秒收到一条数据"><a href="#假设0-1秒收到一条数据" class="headerlink" title="假设0.1秒收到一条数据"></a>假设0.1秒收到一条数据</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line">- (<span class="keyword">void</span>)producerFuncWithNumber:(<span class="built_in">NSInteger</span> )number&#123;</span><br><span class="line">    </span><br><span class="line">    number = random()%<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//生产者生成数据</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> t = dispatch_queue_create(<span class="string">"222222"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(t, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.array addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>,(<span class="keyword">long</span>)number]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"生产了%lu 个"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.array.count);</span><br><span class="line">        dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line">- (<span class="keyword">void</span>)consumerFunc&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> t1 = dispatch_queue_create(<span class="string">"11111"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(t1, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.array.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"消费了%lu 个"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.array.count);</span><br><span class="line">                [<span class="keyword">self</span>.array removeAllObjects];</span><br><span class="line">                [<span class="keyword">self</span> reload];</span><br><span class="line">                dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每次刷新的时候，假设用时2秒"><a href="#每次刷新的时候，假设用时2秒" class="headerlink" title="每次刷新的时候，假设用时2秒"></a>每次刷新的时候，假设用时2秒</h3><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(void)</span>reload&#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"休眠2秒"</span>)</span>;</span><br><span class="line">    sleep<span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;<span class="comment">//存放数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) dispatch_semaphore_t semaphore;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="comment">//开启计时器</span></span><br><span class="line">    <span class="built_in">NSTimer</span> *curTimer =[<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(producerFuncWithNumber:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:curTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [curTimer fire];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> consumerFunc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)reload&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"休眠2秒"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)array&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_array) &#123;</span><br><span class="line">        _array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  _array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (dispatch_semaphore_t)semaphore&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_semaphore) &#123;</span><br><span class="line">        _semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _semaphore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">- (<span class="keyword">void</span>)producerFuncWithNumber:(<span class="built_in">NSInteger</span> )number&#123;</span><br><span class="line">    </span><br><span class="line">    number = random()%<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//生产者生成数据</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> t = dispatch_queue_create(<span class="string">"222222"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(t, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.array addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>,(<span class="keyword">long</span>)number]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"生产了%lu 个"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.array.count);</span><br><span class="line">        dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">- (<span class="keyword">void</span>)consumerFunc&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> t1 = dispatch_queue_create(<span class="string">"11111"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(t1, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.array.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"消费了%lu 个"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.array.count);</span><br><span class="line">                [<span class="keyword">self</span>.array removeAllObjects];</span><br><span class="line">                [<span class="keyword">self</span> reload];</span><br><span class="line">                dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75404</span>] 生产了<span class="number">1</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75407</span>] 生产了<span class="number">2</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75406</span>] 生产了<span class="number">3</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75411</span>] 生产了<span class="number">4</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75440</span>] 生产了<span class="number">5</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75443</span>] 生产了<span class="number">6</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75450</span>] 生产了<span class="number">7</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75458</span>] 生产了<span class="number">8</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75463</span>] 生产了<span class="number">9</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75472</span>] 生产了<span class="number">10</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75480</span>] 生产了<span class="number">11</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75481</span>] 生产了<span class="number">12</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75482</span>] 生产了<span class="number">13</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75494</span>] 生产了<span class="number">14</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75518</span>] 生产了<span class="number">15</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75521</span>] 生产了<span class="number">16</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75526</span>] 生产了<span class="number">17</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75528</span>] 生产了<span class="number">18</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75531</span>] 生产了<span class="number">19</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75545</span>] 生产了<span class="number">20</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75405</span>] 消费了<span class="number">20</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75405</span>] 休眠<span class="number">2</span>秒</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75545</span>] 生产了<span class="number">1</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75531</span>] 生产了<span class="number">2</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75528</span>] 生产了<span class="number">3</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75526</span>] 生产了<span class="number">4</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75521</span>] 生产了<span class="number">5</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75518</span>] 生产了<span class="number">6</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75494</span>] 生产了<span class="number">7</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75482</span>] 生产了<span class="number">8</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75481</span>] 生产了<span class="number">9</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75480</span>] 生产了<span class="number">10</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75472</span>] 生产了<span class="number">11</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75463</span>] 生产了<span class="number">12</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75458</span>] 生产了<span class="number">13</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75450</span>] 生产了<span class="number">14</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75443</span>] 生产了<span class="number">15</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75440</span>] 生产了<span class="number">16</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75406</span>] 生产了<span class="number">17</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75407</span>] 生产了<span class="number">18</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75404</span>] 生产了<span class="number">19</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75411</span>] 生产了<span class="number">20</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75405</span>] 消费了<span class="number">20</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75405</span>] 休眠<span class="number">2</span>秒</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75411</span>] 生产了<span class="number">1</span> 个</span><br><span class="line">iOS-生产者消费者[<span class="number">5508</span>:<span class="number">75404</span>] 生产了<span class="number">2</span> 个</span><br><span class="line"></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>


<p>由输出结果可知，每次完成业务逻辑需要2秒的话，可以等待上次完成，再进行下次取数据，此时，已经有了20条数据，可以一次性处理，对性能是个挺大的提升。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>生产者和消费者各自在信号量处理，为了保证数据的唯一性，需要用信号量 <code>dispatch_semaphore_t semaphore</code> 来保证多条线程不拥挤，不抢数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对生产者消费者的简单实用，实际使用的时候，可以灵活实用，有时候能有挺大的优化空间。</p>
<p><a href="https://github.com/ITyongzhen/iOS-DesignPatterns" target="_blank" rel="noopener">Demo地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之(一)策略模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%B8%80)%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://ityongzhen.github.io/设计模式之(一)策略模式.html">我的个人博客</a></p>
<h2 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h2><h3 id="类型：行为类模式"><a href="#类型：行为类模式" class="headerlink" title="类型：行为类模式"></a>类型：行为类模式</h3><blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。——《Head First 设计模式》</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有个需求是，小孩和大人，小孩吃蔬菜，大人吃肉，小孩每天跑步一小时，大人每天跑步2小时，那么这个简单的需求怎么实现呢？</p>
<h2 id="继承来实现"><a href="#继承来实现" class="headerlink" title="继承来实现"></a>继承来实现</h2><p>首先，我们想到的是继承，定义一个<code>Person</code>类，里么有两个方法</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">- (<span class="name">void</span>)eatSomeThing<span class="comment">;</span></span><br><span class="line">- (<span class="name">void</span>)runEveryDay<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>然后，定义<code>ChildPerson</code> 和 <code>AdultPerson</code> 都继承自<code>Person</code>。然后在各自的类中，分别实现，<code>eatSomeThing</code> 和 <code>runEveryDay</code> 的方法</p>
<p>这种方法是可以，但是，有个问题，就是代码重用性较差，例如，如果再来一个 老人，吃蔬菜，能跑2小时，那么实现起来的话，就是在定义一个类 <code>OldPerson</code> 继承<code>Person</code> ,也实现<code>eatSomeThing</code> 和 <code>runEveryDay</code> 的方法，但问题是，我们之前已经实现了，吃蔬菜的方法，所以没必要再写重复的代码。</p>
<p>这时候，就可以用到策略模式</p>
<h2 id="策略模式来实现"><a href="#策略模式来实现" class="headerlink" title="策略模式来实现"></a>策略模式来实现</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><ul>
<li>协议 <code>Run.h</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Run</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)runEveryDay;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义类 <code>RunOneHour</code> 准守协议 <code>&lt;Run&gt;</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Run.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunOneHour</span> : <span class="title">NSObject</span>&lt;<span class="title">Run</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)runEveryDay;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RunOneHour.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RunOneHour</span></span></span><br><span class="line">- (<span class="keyword">void</span>)runEveryDay&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我每天能跑一个小时"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义类 <code>RunTwoHours</code>准守协议 <code>&lt;Run&gt;</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Run.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunTwoHours</span> : <span class="title">NSObject</span>&lt;<span class="title">Run</span>&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)runEveryDay;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RunTwoHours.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RunTwoHours</span></span></span><br><span class="line">- (<span class="keyword">void</span>)runEveryDay&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我每天能跑两个小时"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h3 id="eat"><a href="#eat" class="headerlink" title="eat"></a>eat</h3><ul>
<li>协议 <code>Eat</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Eat</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义类 <code>EatMeat</code>准守协议 <code>&lt;Eat&gt;</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Eat.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EatMeat</span> : <span class="title">NSObject</span>&lt;<span class="title">Eat</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EatMeat.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EatMeat</span></span></span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我吃肉"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>定义类 <code>EatVegetables</code>准守协议 <code>&lt;Eat&gt;</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Eat.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EatVegetables</span> : <span class="title">NSObject</span>&lt;<span class="title">Eat</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EatVegetables.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EatVegetables</span></span></span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我吃蔬菜"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="person"><a href="#person" class="headerlink" title="person"></a>person</h3><p><code>Person</code>有两个属性，实现了<code>&lt;Eat&gt;</code>协议的<code>eat</code>属性 和 实现了<code>&lt;Run&gt;</code>协议的<code>run</code>属性<br>两个方法，分别是，<code>eatSomeThing</code> 和<code>runEveryDay</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Eat.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Run.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span>&lt;Eat&gt; eat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span>&lt;Run&gt; run;</span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing;</span><br><span class="line">- (<span class="keyword">void</span>)runEveryDay;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">void</span>)eatSomeThing&#123;</span><br><span class="line">    [<span class="keyword">self</span>.eat eatSomeThing];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)runEveryDay&#123;</span><br><span class="line">    [<span class="keyword">self</span>.run runEveryDay];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ChildPerson</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ChildPerson</span> : <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ChildPerson.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EatVegetables.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RunOneHour.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ChildPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.eat = [[EatVegetables alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.run = [[RunOneHour alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我是小孩"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AdultPerson</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdultPerson</span> : <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AdultPerson.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EatMeat.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RunTwoHours.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AdultPerson</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.eat = [[EatMeat alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.run = [[RunTwoHours alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我是大人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *child = <span class="comment">[<span class="comment">[ChildPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[child eatSomeThing]</span>;</span><br><span class="line"><span class="comment">[child runEveryDay]</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">Person</span> *adult = <span class="comment">[<span class="comment">[AdultPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[adult eatSomeThing]</span>;</span><br><span class="line"><span class="comment">[adult runEveryDay]</span>;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">41.159747</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">1402</span>:<span class="number">13333</span>] 我是小孩</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">41.160257</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">1402</span>:<span class="number">13333</span>] 我吃蔬菜</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">41.160300</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">1402</span>:<span class="number">13333</span>] 我每天能跑一个小时</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">41.160343</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">1402</span>:<span class="number">13333</span>] 我是大人</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">41.160379</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">1402</span>:<span class="number">13333</span>] 我吃肉</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">41.160396</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">1402</span>:<span class="number">13333</span>] 我每天能跑两个小时</span><br></pre></td></tr></table></figure>

<p>这样就用策略模式实现了这个需求，如果这时候，增加一个需求 如果再来一个 老人，吃蔬菜，能跑2小时</p>
<p>只需要再定义一个类 <code>OldPerson</code> 如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OldPerson</span> : <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OldPerson.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RunTwoHours.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EatVegetables.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OldPerson</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.eat = [[EatVegetables alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.run = [[RunTwoHours alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我是老人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>调用时候 只需要如下</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *old = <span class="comment">[<span class="comment">[OldPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[old eatSomeThing]</span>;</span><br><span class="line"><span class="comment">[old runEveryDay]</span>;</span><br></pre></td></tr></table></figure>

<p>即可输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">46</span>:<span class="number">16.007758</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">2567</span>:<span class="number">27396</span>] 我是老人</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">46</span>:<span class="number">16.007770</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">2567</span>:<span class="number">27396</span>] 我吃蔬菜</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">46</span>:<span class="number">16.007780</span>+<span class="number">0800</span> iOS-策略模式[<span class="number">2567</span>:<span class="number">27396</span>] 我每天能跑两个小时</span><br></pre></td></tr></table></figure>

<p>根本不需要重写吃，和跑的方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</li>
<li>提供了可以替换继承关系的办法</li>
<li>策略模式的Stategy类层次为Context定义了一些列的可供重用的算法或行为。继承有助于析取出算法中的公共功能。</li>
<li>策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。</li>
<li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展        </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>维护各个策略类会给开发带来额外开销，一般来说，策略类的数量超过6个，就比较麻烦</li>
<li>必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。</li>
</ul>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul>
<li>策略模式是一种简单常用的模式，我们在进行开发的时候，会经常有意无意地使用它，一般来说，策略模式不会单独使用，跟模版方法模式、工厂模式等混合使用的情况比较多。</li>
</ul>
<p><a href="https://github.com/ITyongzhen/iOS-DesignPatterns" target="_blank" rel="noopener">Demo地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之桶排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A1%B6%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之桶排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?w=1452&h=814&f=png&s=620682" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>冒泡、选择、插入、归并、希尔、堆排序都是基于比较的排序</p>
<ul>
<li>平均时间复杂度最低O(nlogn)</li>
</ul>
</li>
<li><p>计数排序、桶排序、基数排序不是基于比较的排序</p>
<ul>
<li>使用空间换时间，某些时候，平均时间复杂度可以低于O(nlogn)</li>
</ul>
</li>
</ul>
<h2 id="什么是桶排序"><a href="#什么是桶排序" class="headerlink" title="什么是桶排序"></a>什么是桶排序</h2><ul>
<li><a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin" target="_blank" rel="noopener">桶排序</a> (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</li>
</ul>
<p><strong>桶排序可以看做计数排序的升级版</strong></p>
<ul>
<li>它将要排的数据分到多个有序的桶里，每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序</li>
</ul>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><ul>
<li>桶排序是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>桶排序不属于 In-place</li>
</ul>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul>
<li>时间复杂度：O(n+k)，k为 <code>n*logn-n*logm</code></li>
</ul>
<ul>
<li>空间复杂度：O(n+m), m是桶的数量</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><p>桶排序内部的实现可以用计数排序的思路</p>
</li>
<li><p>代码中创建了数组长度的四分之一个桶，具体数量根据自己需要，可以自己调整</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">package YZ.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BucketSort</span> <span class="symbol">extends</span> <span class="symbol">Sort</span>&lt;<span class="symbol">Integer</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">void</span> sort() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	    <span class="comment">//最大最小值</span></span><br><span class="line">	    <span class="built_in">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">	    <span class="built_in">int</span> min = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">	    <span class="built_in">int</span> length = <span class="built_in">array</span>.length/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">	        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &gt; max) &#123;</span><br><span class="line">	            max = <span class="built_in">array</span>[i];</span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; min) &#123;</span><br><span class="line">	            min = <span class="built_in">array</span>[i];</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//最大值和最小值的差</span></span><br><span class="line">	    <span class="built_in">int</span> diff = max - min;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//桶列表</span></span><br><span class="line">	    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;();</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">	        bucketList.add(new ArrayList&lt;&gt;());</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//每个桶的存数区间</span></span><br><span class="line">	    <span class="built_in">float</span> section = (<span class="built_in">float</span>) diff / (<span class="built_in">float</span>) (length - <span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//数据入桶</span></span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++)&#123;</span><br><span class="line">	        <span class="comment">//当前数除以区间得出存放桶的位置 减1后得出桶的下标</span></span><br><span class="line">	        <span class="built_in">int</span> num = (<span class="built_in">int</span>) (<span class="built_in">array</span>[i] / section) - <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	            num = <span class="number">0</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	        bucketList.<span class="keyword">get</span>(num).add(<span class="built_in">array</span>[i]);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//桶内排序</span></span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)&#123;</span><br><span class="line">	        <span class="comment">//jdk的排序速度当然信得过</span></span><br><span class="line">	        Collections.sort(bucketList.<span class="keyword">get</span>(i));</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//写入原数组</span></span><br><span class="line">	    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(ArrayList&lt;Integer&gt; <span class="built_in">array</span>List : bucketList)&#123;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="built_in">int</span> value : <span class="built_in">array</span>List)&#123;</span><br><span class="line">	        	<span class="built_in">array</span>[index] = value;</span><br><span class="line">	            index++;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="数据源："><a href="#数据源：" class="headerlink" title="数据源："></a>数据源：</h3><p>从1到80000之间随机生成20000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(20000, 1, 80000);</p>
</blockquote>
<h3 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h3><p>【CountingSort】<br>稳定性：true     耗时：0.005s(5ms)     比较次数：0     交换次数：0</p>
<p>【QuickSort】<br>稳定性：false     耗时：0.009s(9ms)     比较次数：33.27万     交换次数：1.32万</p>
<p>【MergeSort】<br>稳定性：true     耗时：0.01s(10ms)     比较次数：26.10万     交换次数：0</p>
<p>【RadixSort】<br>稳定性：true     耗时：0.014s(14ms)     比较次数：0     交换次数：0</p>
<p>【ShellSort】<br>稳定性：false     耗时：0.016s(16ms)     比较次数：43.34万     交换次数：0</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.023s(23ms)     比较次数：51.09万     交换次数：2.00万</p>
<p>【BucketSort】<br>稳定性：true     耗时：0.024s(24ms)     比较次数：0     交换次数：0</p>
<p>【SelectionSort】<br>稳定性：true     耗时：0.514s(514ms)     比较次数：2.00亿     交换次数：2.00万</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：1.362s(1362ms)     比较次数：9935.15万     交换次数：9933.15万</p>
<p>【BubbleSort】<br>稳定性：true     耗时：2.529s(2529ms)     比较次数：2.00亿     交换次数：9933.15万</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之基数排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之基数排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>冒泡、选择、插入、归并、希尔、堆排序都是基于比较的排序</p>
<ul>
<li>平均时间复杂度最低O(nlogn)</li>
</ul>
</li>
<li><p>计数排序、桶排序、基数排序不是基于比较的排序</p>
<ul>
<li>使用空间换时间，某些时候，平均时间复杂度可以低于O(nlogn)</li>
</ul>
</li>
</ul>
<h2 id="什么是基数排序"><a href="#什么是基数排序" class="headerlink" title="什么是基数排序"></a>什么是基数排序</h2><ul>
<li><a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">基数排序</a>（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法</li>
</ul>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul>
<li>最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。</li>
<li>最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>以LSD为例，假设原来有一串数值如下所示：</p>
<blockquote>
<p>73, 22, 93, 43, 55, 14, 28, 65, 39, 81</p>
</blockquote>
<p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">81</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">22</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">73</span> <span class="number">93</span> <span class="number">43</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">14</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">55</span> <span class="number">65</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">28</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">39</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</p>
<blockquote>
<p>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p>
</blockquote>
<p>接着再进行一次分配，这次是根据十位数来分配：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">14</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">22</span> <span class="number">28</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">39</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">43</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">55</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">65</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">73</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">81</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">93</span></span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</p>
<blockquote>
<p>14, 22, 28, 39, 43, 55, 65, 73, 81, 93</p>
</blockquote>
<p>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p>
<ul>
<li>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</li>
</ul>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><ul>
<li>基数排序是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>基数排序不属于 In-place</li>
</ul>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul>
<li><p>最好、最坏、平均时间复杂度：O(d*(n+k))</p>
<ul>
<li>d是最大值的位数，k是进制    </li>
</ul>
</li>
<li><p>空间复杂度：O(n+k)</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><p><a href="https://ityongzhen.github.io/十大排序算法之计数排序.html">十大排序算法之计数排序</a>中，先使用最简单的实现方案，先求最大值，用于创建数组，然后遍历出来，统计元素出现的次数，最后再按照顺序赋值</p>
</li>
<li><p>基数排序内部的实现可以用计数排序的思路</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">package YZ.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">RadixSort</span> <span class="symbol">extends</span> <span class="symbol">Sort</span>&lt;<span class="symbol">Integer</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">void</span> sort() &#123;</span><br><span class="line">		<span class="built_in">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;max) &#123;</span><br><span class="line">				max = <span class="built_in">array</span>[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 个位数: array[i] / 1 % 10 = 3</span></span><br><span class="line">		<span class="comment">// 十位数：array[i] / 10 % 10 = 9</span></span><br><span class="line">		<span class="comment">// 百位数：array[i] / 100 % 10 = 5</span></span><br><span class="line">		<span class="comment">// 千位数：array[i] / 1000 % 10 = ...</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> divider = <span class="number">1</span>; divider &lt;= max; divider*=<span class="number">10</span>) &#123;</span><br><span class="line">			sort(divider);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">void</span> sort(<span class="built_in">int</span> divider) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">		<span class="built_in">int</span>[] counts = new <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">			counts[<span class="built_in">array</span>[i]/divider%<span class="number">10</span>]++;</span><br><span class="line">		&#125;<span class="comment">// O(n)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 累加次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">			counts[i]+= counts[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从后向前遍历元素，将她放在有序数组中的合适位置</span></span><br><span class="line">		<span class="built_in">int</span>[] newArray = new <span class="built_in">int</span>[<span class="built_in">array</span>.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="built_in">array</span>.length<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">			<span class="comment">//获取元素在counts中的索引</span></span><br><span class="line">			<span class="built_in">int</span> index = <span class="built_in">array</span>[i]/divider%<span class="number">10</span>;</span><br><span class="line">			<span class="comment">//获取元素在counts中的值</span></span><br><span class="line">			<span class="comment">//counts[index];</span></span><br><span class="line">			<span class="comment">//放在合适位置</span></span><br><span class="line">			newArray[--counts[index]] = <span class="built_in">array</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">			<span class="built_in">array</span>[i] = newArray[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="数据源："><a href="#数据源：" class="headerlink" title="数据源："></a>数据源：</h3><p>从1到80000之间随机生成20000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(20000, 1, 80000);</p>
</blockquote>
<h3 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h3><p>【CountingSort】<br>稳定性：true     耗时：0.005s(5ms)     比较次数：0     交换次数：0</p>
<p>【QuickSort】<br>稳定性：false     耗时：0.009s(9ms)     比较次数：33.27万     交换次数：1.32万</p>
<p>【MergeSort】<br>稳定性：true     耗时：0.01s(10ms)     比较次数：26.10万     交换次数：0</p>
<p>【RadixSort】<br>稳定性：true     耗时：0.014s(14ms)     比较次数：0     交换次数：0</p>
<p>【ShellSort】<br>稳定性：false     耗时：0.016s(16ms)     比较次数：43.34万     交换次数：0</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.023s(23ms)     比较次数：51.09万     交换次数：2.00万</p>
<p>【SelectionSort】<br>稳定性：true     耗时：0.514s(514ms)     比较次数：2.00亿     交换次数：2.00万</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：1.362s(1362ms)     比较次数：9935.15万     交换次数：9933.15万</p>
<p>【BubbleSort】<br>稳定性：true     耗时：2.529s(2529ms)     比较次数：2.00亿     交换次数：9933.15万</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之计数排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之计数排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>冒泡、选择、插入、归并、希尔、堆排序都是基于比较的排序</p>
<ul>
<li>平均时间复杂度最低O(nlogn)</li>
</ul>
</li>
<li><p>计数排序、桶排序、基数排序不是基于比较的排序</p>
<ul>
<li>使用空间换时间，某些时候，平均时间复杂度可以低于O(nlogn)</li>
</ul>
</li>
</ul>
<h2 id="什么是计数排序"><a href="#什么是计数排序" class="headerlink" title="什么是计数排序"></a>什么是计数排序</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">计数排序</a>（Counting sort）是一种稳定的线性时间排序算法。该算法于1954年由 Harold H. Seward 提出。计数排序使用一个额外的数组 C ，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C 来将A中的元素排到正确的位置</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><strong>当输入的元素是n个0 到 k 之间的整数时，它的运行时间是O(n+k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</strong></p>
<p><strong>核心思想：统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引</strong></p>
<ul>
<li><p>由于用来计数的数组C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。</p>
</li>
<li><p>通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去<br>1。算法的步骤如下：</p>
<ul>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C 的第i项</li>
<li>对所有的计数累加 (从C 中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1</li>
</ul>
</li>
</ul>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>计数排序是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>计数排序不属于 In-place</li>
</ul>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul>
<li><p>最好、最坏、平均时间复杂度：O(n+k)</p>
</li>
<li><p>空间复杂度：O(n+k)</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>先使用最简单的实现方案，先求最大值，用于创建数组，然后遍历出来，统计元素出现的次数，最后再按照顺序赋值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">CountingSort</span> <span class="symbol">extends</span> <span class="symbol">Sort</span>&lt;<span class="symbol">Integer</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">void</span> sort() &#123;</span><br><span class="line">		<span class="comment">//找出最大值</span></span><br><span class="line">		<span class="built_in">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;max) &#123;</span><br><span class="line">				max= <span class="built_in">array</span>[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">// O(n)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 开辟内存空间，存储每个整数出现的次数</span></span><br><span class="line">		<span class="built_in">int</span>[] counts = new <span class="built_in">int</span>[max+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">			counts[<span class="built_in">array</span>[i]]++;</span><br><span class="line">		&#125;<span class="comment">// O(n)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 根据整数的出现次数，对整数进行排序</span></span><br><span class="line">		<span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (counts[i]--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">array</span>[index++] = i;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">// O(n)</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上述代码有些问题</p>
<ul>
<li>无法对负整数进行排序</li>
<li>浪费内存空间</li>
<li>不是稳定排序</li>
</ul>
<p>优化思路：</p>
<ul>
<li>假设array中的最小值是min，最大值为max，就以min为索引0开始<ul>
<li>例如数组为 -2 4 5,那么 -2索引为0，4索引为6，5的索引为7</li>
</ul>
</li>
<li>定义个counts数组，里面存放着每个次数累加上前面的所有次数，得到的就是元素在有序序列中的位置信息<br><img src="https://user-gold-cdn.xitu.io/2019/11/11/16e59a9237313173?w=1916&h=878&f=png&s=515034" alt=""></li>
</ul>
<h3 id="优化过的代码为"><a href="#优化过的代码为" class="headerlink" title="优化过的代码为"></a>优化过的代码为</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//找出最大值和最小值</span></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line">				<span class="built_in">max</span>= <span class="built_in">array</span>[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[i]&lt;<span class="built_in">min</span>) &#123;</span><br><span class="line">				<span class="built_in">min</span>= <span class="built_in">array</span>[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">// O(n)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">		<span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">			counts[<span class="built_in">array</span>[i]-<span class="built_in">min</span>]++;</span><br><span class="line">		&#125;<span class="comment">// O(n)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 累加次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">			counts[i]+= counts[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从后向前遍历元素，将她放在有序数组中的合适位置</span></span><br><span class="line">		<span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">array</span>.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">array</span>.length<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">			<span class="comment">//获取元素在counts中的索引</span></span><br><span class="line">			<span class="keyword">int</span> index = <span class="built_in">array</span>[i]-<span class="built_in">min</span>;</span><br><span class="line">			<span class="comment">//获取元素在counts中的值</span></span><br><span class="line">			<span class="comment">//counts[index];</span></span><br><span class="line">			<span class="comment">//放在合适位置</span></span><br><span class="line">			newArray[--counts[index]] = <span class="built_in">array</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">			<span class="built_in">array</span>[i] = newArray[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="数据源："><a href="#数据源：" class="headerlink" title="数据源："></a>数据源：</h3><p>从1到80000之间随机生成20000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(20000, 1, 80000);</p>
</blockquote>
<h3 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h3><p>【CountingSort】<br>稳定性：true     耗时：0.005s(5ms)     比较次数：0     交换次数：0</p>
<p>【QuickSort】<br>稳定性：false     耗时：0.009s(9ms)     比较次数：33.27万     交换次数：1.32万</p>
<p>【MergeSort】<br>稳定性：true     耗时：0.01s(10ms)     比较次数：26.10万     交换次数：0</p>
<p>【ShellSort】<br>稳定性：false     耗时：0.016s(16ms)     比较次数：43.34万     交换次数：0</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.023s(23ms)     比较次数：51.09万     交换次数：2.00万</p>
<p>【SelectionSort】<br>稳定性：true     耗时：0.514s(514ms)     比较次数：2.00亿     交换次数：2.00万</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：1.362s(1362ms)     比较次数：9935.15万     交换次数：9933.15万</p>
<p>【BubbleSort】<br>稳定性：true     耗时：2.529s(2529ms)     比较次数：2.00亿     交换次数：9933.15万</p>
<p>可以看到这种情况下计数排序的甚至比快速排序，归并排序还要快。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之希尔排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之希尔排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是希尔排序"><a href="#什么是希尔排序" class="headerlink" title="什么是希尔排序"></a>什么是希尔排序</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">希尔排序</a>（Shellsort）也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<h2 id="希尔排序的历史"><a href="#希尔排序的历史" class="headerlink" title="希尔排序的历史"></a>希尔排序的历史</h2><p>希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。一些老版本教科书和参考手册把该算法命名为Shell-Metzner，即包含Marlene Metzner Norton的名字，但是根据Metzner本人的说法，“我没有为这种算法做任何事，我的名字不应该出现在算法的名字中。”</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ul>
<li><p>原始的算法实现在最坏的情况下需要进行O(n<sup>2</sup>)的比较和交换。 V. Pratt的书对算法进行了少量修改，可以使得性能提升至O(n log<sup>2</sup> n)。这比最好的比较算法的O(n log n)要差一些。</p>
</li>
<li><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
</li>
<li><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n<sup>2</sup>)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
</li>
<li><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p>
</li>
<li><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
</li>
</ul>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">13 </span><span class="number">14</span> <span class="number">94</span> <span class="number">33</span> <span class="number">82</span></span><br><span class="line"><span class="symbol">25 </span><span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">23</span></span><br><span class="line"><span class="symbol">45 </span><span class="number">27</span> <span class="number">73</span> <span class="number">25</span> <span class="number">39</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>然后我们对每列进行排序：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">14</span> <span class="number">73</span> <span class="number">25</span> <span class="number">23</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">27</span> <span class="number">94</span> <span class="number">33</span> <span class="number">39</span></span><br><span class="line"><span class="symbol">25 </span><span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">82</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">14</span> <span class="number">73</span></span><br><span class="line"><span class="symbol">25 </span><span class="number">23</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">27 </span><span class="number">94</span> <span class="number">33</span></span><br><span class="line"><span class="symbol">39 </span><span class="number">25</span> <span class="number">59</span></span><br><span class="line"><span class="symbol">94 </span><span class="number">65</span> <span class="number">82</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p>排序之后变为：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">14</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">25 </span><span class="number">23</span> <span class="number">33</span></span><br><span class="line"><span class="symbol">27 </span><span class="number">25</span> <span class="number">59</span></span><br><span class="line"><span class="symbol">39 </span><span class="number">65</span> <span class="number">73</span></span><br><span class="line"><span class="symbol">45 </span><span class="number">94</span> <span class="number">82</span></span><br><span class="line"><span class="number">94</span></span><br></pre></td></tr></table></figure>

<p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>希尔排序不是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>希尔排序属于 In-place</li>
</ul>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul>
<li>最好时间复杂度：O(n)</li>
<li>最坏时间复杂度：O(n<sup>4/3</sup>)~O(n<sup>2</sup>)</li>
<li>平均时间复杂度：取决于步长</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h2><ul>
<li><p>希尔本人给出的步长序列，最坏情况时间复杂度是O(n<sup>2</sup>)</p>
<ul>
<li>希尔给出的步长序列为1,2,4,8,16,32,64…</li>
</ul>
</li>
<li><p>目前已知的最好步长序列，最快情况时间复杂度为O(n<sup>4/3</sup>)，是在1986年由Robert Sedgewick提出的。</p>
<ul>
<li>1，5，19，41，109…</li>
</ul>
</li>
<li><p>Robert Sedgewick给出的步长序列实现如下</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取最优步长</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; sedgewickStepSequence() &#123;</span><br><span class="line">		List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;();</span><br><span class="line">		<span class="built_in">int</span> k = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">int</span> pow = (<span class="built_in">int</span>) Math.pow(<span class="number">2</span>, k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				step = <span class="number">1</span> + <span class="number">9</span> * (pow * pow - pow);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">int</span> pow1 = (<span class="built_in">int</span>) Math.pow(<span class="number">2</span>, (k - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">int</span> pow2 = (<span class="built_in">int</span>) Math.pow(<span class="number">2</span>, (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				step = <span class="number">1</span> + <span class="number">8</span> * pow1 * pow2 - <span class="number">6</span> * pow2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (step &gt;= <span class="built_in">array</span>.length) <span class="keyword">break</span>;</span><br><span class="line">			stepSequence.add(<span class="number">0</span>, step);</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stepSequence;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="最简单的插入排序为基础，步长为1，2，4，8，16，32…"><a href="#最简单的插入排序为基础，步长为1，2，4，8，16，32…" class="headerlink" title="最简单的插入排序为基础，步长为1，2，4，8，16，32…"></a>最简单的插入排序为基础，步长为1，2，4，8，16，32…</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="title">extends</span> <span class="title">Sort</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		List&lt;Integer&gt; stepSequence = sedgewickStepSequence();</span><br><span class="line">		<span class="keyword">for</span> (Integer <span class="built_in">step</span> : stepSequence) &#123;</span><br><span class="line">			sort(<span class="built_in">step</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分成step列进行排序</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="built_in">step</span>; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">			<span class="comment">// col、col+step、col+2*step、col+3*step</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">begin</span> = col + <span class="built_in">step</span>; <span class="built_in">begin</span> &lt; <span class="built_in">array</span>.length; <span class="built_in">begin</span> += <span class="built_in">step</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> cur = <span class="built_in">begin</span>;</span><br><span class="line">				<span class="keyword">while</span> (cur &gt; col &amp;&amp; cmp(cur, cur - <span class="built_in">step</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					swap(cur, cur - <span class="built_in">step</span>);</span><br><span class="line">					cur -= <span class="built_in">step</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取步长序列</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; shellStepSequence() &#123;</span><br><span class="line">		List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">step</span> = <span class="built_in">array</span>.length;</span><br><span class="line">		<span class="keyword">while</span> ((<span class="built_in">step</span> &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			stepSequence.add(<span class="built_in">step</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stepSequence;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>思路：</p>
<ul>
<li>按照安卓<a href="https://ityongzhen.github.io/十大排序算法之插入排序.html">十大排序算法之插入排序</a>中的，对插入排序算法进行优化</li>
<li>对步长进行优化</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="built_in">step</span>; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="built_in">step</span>+col; <span class="built_in">begin</span> &lt; <span class="built_in">array</span>.length; <span class="built_in">begin</span>+=<span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="built_in">begin</span>;</span><br><span class="line">			T res =<span class="built_in">array</span>[cur];</span><br><span class="line">			<span class="keyword">while</span> (cur&gt;col &amp;&amp; cmp(res,<span class="built_in">array</span>[cur-<span class="built_in">step</span>])&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">array</span>[cur] = <span class="built_in">array</span>[cur-<span class="built_in">step</span>];</span><br><span class="line">				cur-=<span class="built_in">step</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[cur] = res;</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取最优步长</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; sedgewickStepSequence() &#123;</span><br><span class="line">		List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;();</span><br><span class="line">		<span class="built_in">int</span> k = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">int</span> pow = (<span class="built_in">int</span>) Math.pow(<span class="number">2</span>, k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				step = <span class="number">1</span> + <span class="number">9</span> * (pow * pow - pow);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">int</span> pow1 = (<span class="built_in">int</span>) Math.pow(<span class="number">2</span>, (k - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">int</span> pow2 = (<span class="built_in">int</span>) Math.pow(<span class="number">2</span>, (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				step = <span class="number">1</span> + <span class="number">8</span> * pow1 * pow2 - <span class="number">6</span> * pow2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (step &gt;= <span class="built_in">array</span>.length) <span class="keyword">break</span>;</span><br><span class="line">			stepSequence.add(<span class="number">0</span>, step);</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stepSequence;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="优化过的代码为"><a href="#优化过的代码为" class="headerlink" title="优化过的代码为"></a>优化过的代码为</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package YZ.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="title">extends</span> <span class="title">Sort</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		List&lt;Integer&gt; stepSequence = sedgewickStepSequence();</span><br><span class="line">		<span class="keyword">for</span> (Integer <span class="built_in">step</span> : stepSequence) &#123;</span><br><span class="line">			sort2(<span class="built_in">step</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分成step列进行排序</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="built_in">step</span>; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">			<span class="comment">// col、col+step、col+2*step、col+3*step</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">begin</span> = col + <span class="built_in">step</span>; <span class="built_in">begin</span> &lt; <span class="built_in">array</span>.length; <span class="built_in">begin</span> += <span class="built_in">step</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> cur = <span class="built_in">begin</span>;</span><br><span class="line">				<span class="keyword">while</span> (cur &gt; col &amp;&amp; cmp(cur, cur - <span class="built_in">step</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					swap(cur, cur - <span class="built_in">step</span>);</span><br><span class="line">					cur -= <span class="built_in">step</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="built_in">step</span>; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="built_in">step</span>+col; <span class="built_in">begin</span> &lt; <span class="built_in">array</span>.length; <span class="built_in">begin</span>+=<span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="built_in">begin</span>;</span><br><span class="line">			T res =<span class="built_in">array</span>[cur];</span><br><span class="line">			<span class="keyword">while</span> (cur&gt;col &amp;&amp; cmp(res,<span class="built_in">array</span>[cur-<span class="built_in">step</span>])&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">array</span>[cur] = <span class="built_in">array</span>[cur-<span class="built_in">step</span>];</span><br><span class="line">				cur-=<span class="built_in">step</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[cur] = res;</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取步长序列</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; shellStepSequence() &#123;</span><br><span class="line">		List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">step</span> = <span class="built_in">array</span>.length;</span><br><span class="line">		<span class="keyword">while</span> ((<span class="built_in">step</span> &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			stepSequence.add(<span class="built_in">step</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stepSequence;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取最优步长</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; sedgewickStepSequence() &#123;</span><br><span class="line">		List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>, <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> <span class="built_in">pow</span> = (<span class="keyword">int</span>) Math.<span class="built_in">pow</span>(<span class="number">2</span>, k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">step</span> = <span class="number">1</span> + <span class="number">9</span> * (<span class="built_in">pow</span> * <span class="built_in">pow</span> - <span class="built_in">pow</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> pow1 = (<span class="keyword">int</span>) Math.<span class="built_in">pow</span>(<span class="number">2</span>, (k - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">int</span> pow2 = (<span class="keyword">int</span>) Math.<span class="built_in">pow</span>(<span class="number">2</span>, (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">step</span> = <span class="number">1</span> + <span class="number">8</span> * pow1 * pow2 - <span class="number">6</span> * pow2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">step</span> &gt;= <span class="built_in">array</span>.length) <span class="keyword">break</span>;</span><br><span class="line">			stepSequence.add(<span class="number">0</span>, <span class="built_in">step</span>);</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stepSequence;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="数据源："><a href="#数据源：" class="headerlink" title="数据源："></a>数据源：</h3><p>从1到20000之间随机生成10000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(20000, 1, 80000);</p>
</blockquote>
<h3 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h3><p>【MergeSort】<br>稳定性：true     耗时：0.011s(11ms)     比较次数：26.10万     交换次数：0</p>
<p>【QuickSort】<br>稳定性：false     耗时：0.012s(12ms)     比较次数：34.55万     交换次数：1.32万</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.018s(18ms)     比较次数：51.10万     交换次数：2.00万</p>
<p>【ShellSort】<br>稳定性：false     耗时：0.02s(20ms)     比较次数：43.04万     交换次数：0</p>
<p>【SelectionSort】<br>稳定性：true     耗时：0.485s(485ms)     比较次数：2.00亿     交换次数：2.00万</p>
<p>【InsertionSort3】<br>稳定性：true     耗时：0.526s(526ms)     比较次数：25.80万     交换次数：0</p>
<p>【InsertionSort2】<br>稳定性：true     耗时：0.801s(801ms)     比较次数：9963.29万     交换次数：0</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：1.281s(1281ms)     比较次数：9963.29万     交换次数：9961.29万</p>
<p>【BubbleSort2】<br>稳定性：true     耗时：2.271s(2271ms)     比较次数：2.00亿     交换次数：9961.29万</p>
<p>【BubbleSort】<br>稳定性：true     耗时：2.339s(2339ms)     比较次数：2.00亿     交换次数：9961.29万</p>
<p>【BubbleSort1】<br>稳定性：true     耗时：2.403s(2403ms)     比较次数：2.00亿     交换次数：9961.29万</p>
<p>可以看到希尔排序的性能还是很不错的，对比插入排序，优化的还是挺多的。</p>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><h3 id="什么是逆序对？"><a href="#什么是逆序对？" class="headerlink" title="什么是逆序对？"></a>什么是逆序对？</h3><p>数组[2,4,1]中的逆序对为&lt;2,1&gt; 和 &lt;4,1&gt;</p>
<h3 id="插入排序的时间复杂度和逆序对的数量成正比关系"><a href="#插入排序的时间复杂度和逆序对的数量成正比关系" class="headerlink" title="插入排序的时间复杂度和逆序对的数量成正比关系"></a>插入排序的时间复杂度和逆序对的数量成正比关系</h3><p>逆序对越多，插入排序的时间复杂度越高</p>
<h3 id="当逆序对的数量极少时候，插入排序的效率特别高"><a href="#当逆序对的数量极少时候，插入排序的效率特别高" class="headerlink" title="当逆序对的数量极少时候，插入排序的效率特别高"></a>当逆序对的数量极少时候，插入排序的效率特别高</h3><p>甚至有时候可以比O(nlogn)级别的快速排序还要快</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之快速排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之快速排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是快速排序"><a href="#什么是快速排序" class="headerlink" title="什么是快速排序"></a>什么是快速排序</h2><ul>
<li>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="快速排序算法通过多次比较和交换来实现排序，其排序流程如下："><a href="#快速排序算法通过多次比较和交换来实现排序，其排序流程如下：" class="headerlink" title="快速排序算法通过多次比较和交换来实现排序，其排序流程如下："></a>快速排序算法通过多次比较和交换来实现排序，其排序流程如下：</h3><ul>
<li><p>首先设定一个分界值，通过该分界值将数组分成左右两部分。 </p>
</li>
<li><p>将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。</p>
</li>
<li><p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
</li>
<li><p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 </p>
</li>
</ul>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>在轴点左右元素数量比较均匀的情况下，同时也是最好的情况 O(nlogn)</li>
<li>如果轴点左右元素数量极度不均匀，最坏情况 O(n^2)</li>
<li>为了降低最坏情况的出现概率，一般采用<strong>随机选择轴点元素</strong></li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>递归调用的原因，其空间复杂度是 O(nlogn)</li>
</ul>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>快速排序是一种不稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>快速排序属于 In-place</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li><p>从序列中选择一个轴点元素(pivot)</p>
<ul>
<li>假设每次选择0位置的元素为轴点元素</li>
</ul>
</li>
<li><p>利用pivot将序列分割成2个子序列</p>
<ul>
<li>将小于pivot的元素放在pivot左侧</li>
<li>将大于pivot的元素放在pivot右侧</li>
<li>等于pivot的元素放哪边都可以</li>
</ul>
</li>
<li><p>对子序列进行前面两步操作，直到不能再分割(子序列中只剩下一个元素)</p>
</li>
<li><p>快速排序的本质</p>
<ul>
<li>逐渐将每个元素都转换成轴点元素 </li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package YZ.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>&lt;T extends Comparable&lt;T&gt;&gt; <span class="title">extends</span> <span class="title">Sort</span>&lt;T&gt;   &#123;</span></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sort(<span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对 [begin, end) 范围的元素进行快速排序</span></span><br><span class="line"><span class="comment">	 * @param begin</span></span><br><span class="line"><span class="comment">	 * @param end</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">begin</span>,<span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">end</span>-<span class="built_in">begin</span>&lt;<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 确定轴点位置 O(n)</span></span><br><span class="line">		<span class="keyword">int</span> mid  = pivotIndex(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 对子序列进行快速排序</span></span><br><span class="line">		sort(<span class="built_in">begin</span>,mid);</span><br><span class="line">		sort(mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造出 [begin, end) 范围的轴点元素</span></span><br><span class="line"><span class="comment">	 * @return 轴点元素的最终位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> <span class="built_in">begin</span>,<span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//随机选择一个元素和begin位置的元素进行交换 </span></span><br><span class="line">		swap(<span class="built_in">begin</span>, <span class="built_in">begin</span>+(<span class="keyword">int</span>)Math.<span class="built_in">random</span>()*(<span class="built_in">end</span>-<span class="built_in">begin</span>));</span><br><span class="line">		<span class="comment">// 备份begin位置的元素</span></span><br><span class="line">		T pivot = <span class="built_in">array</span>[<span class="built_in">begin</span>];</span><br><span class="line">		<span class="built_in">end</span>--;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">begin</span>&lt;<span class="built_in">end</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">begin</span>&lt;<span class="built_in">end</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cmp(pivot, <span class="built_in">array</span>[<span class="built_in">end</span>])&lt;<span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">					<span class="built_in">end</span>--;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;<span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">					<span class="built_in">array</span>[<span class="built_in">begin</span>++] = <span class="built_in">array</span>[<span class="built_in">end</span>];</span><br><span class="line">					<span class="keyword">break</span>; <span class="comment">//break退出，从另外一边（begin）开始</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">begin</span>&lt;<span class="built_in">end</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cmp(pivot, <span class="built_in">array</span>[<span class="built_in">begin</span>])&gt;<span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">					<span class="built_in">begin</span>++;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;<span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">					<span class="built_in">array</span>[<span class="built_in">end</span>--] = <span class="built_in">array</span>[<span class="built_in">begin</span>];</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//break退出，从另外一边（end）开始</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将备份的轴点元素放入最终的位置</span></span><br><span class="line">		<span class="built_in">array</span>[<span class="built_in">begin</span>] = pivot;</span><br><span class="line">		<span class="comment">// 返回轴点元素的位置</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>使用数据源如下</p>
<blockquote>
<p>Integer[] array = Integers.random(20000, 1, 80000);</p>
</blockquote>
<p>结果为：</p>
<p>【BubbleSort】<br>稳定性：true     耗时：2.494s(2494ms)     比较次数：2.00亿     交换次数：9950.84万</p>
<p>【BubbleSort1】<br>稳定性：true     耗时：1.95s(1950ms)     比较次数：2.00亿     交换次数：9950.84万</p>
<p>【BubbleSort2】<br>稳定性：true     耗时：2.048s(2048ms)     比较次数：2.00亿     交换次数：9950.84万</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：1.125s(1125ms)     比较次数：9952.84万     交换次数：9950.84万</p>
<p>【InsertionSort2】<br>稳定性：true     耗时：0.772s(772ms)     比较次数：9952.84万     交换次数：0</p>
<p>【InsertionSort3】<br>稳定性：true     耗时：0.546s(546ms)     比较次数：25.80万     交换次数：0</p>
<p>【SelectionSort】<br>稳定性：true     耗时：0.458s(458ms)     比较次数：2.00亿     交换次数：2.00万</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.013s(13ms)     比较次数：51.08万     交换次数：2.00万</p>
<p>【QuickSort】<br>稳定性：false     耗时：0.01s(10ms)     比较次数：32.00万     交换次数：1.32万</p>
<p>【MergeSort】<br>稳定性：true     耗时：0.011s(11ms)     比较次数：26.08万     交换次数：0</p>
<p>结果来看快速排序性能还是很好的。</p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之归并排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之归并排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是归并排序"><a href="#什么是归并排序" class="headerlink" title="什么是归并排序"></a>什么是归并排序</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a>（mergesort）是创建在归并操作上的一种有效的排序算法，效率为O(nlog n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>采用分治法:</p>
<ul>
<li>分割：递归地把当前序列平均分割成两半。</li>
<li>集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</li>
</ul>
</li>
</ul>
<h3 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h3><ul>
<li>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</li>
</ul>
<h4 id="递归法（Top-down）"><a href="#递归法（Top-down）" class="headerlink" title="递归法（Top-down）"></a>递归法（Top-down）</h4><ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><p>原理如下（假设序列共有n个元素）：</p>
<ul>
<li>将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素</li>
<li>若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ul>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul>
<li>最好时间复杂度：O(nlogn)</li>
<li>最坏、平均时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>归并排序是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>归并排序不属于 In-place</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package YZ.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="title">extends</span> <span class="title">Sort</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T[] leftArray;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		leftArray = (T[]) <span class="keyword">new</span> Comparable[<span class="built_in">array</span>.length&gt;&gt;<span class="number">1</span>];</span><br><span class="line">		sort(<span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对 [begin, end) 范围的数据进行归并排序</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">begin</span>,<span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">end</span>-<span class="built_in">begin</span>&lt;<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (<span class="built_in">begin</span> + <span class="built_in">end</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		sort(<span class="built_in">begin</span>, mid);</span><br><span class="line">		sort(mid,<span class="built_in">end</span>);</span><br><span class="line">		</span><br><span class="line">		merge(<span class="built_in">begin</span>, mid, <span class="built_in">end</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> mid, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> li = <span class="number">0</span>, le = mid-<span class="built_in">begin</span>; <span class="comment">//左边数组（基于leftArray）</span></span><br><span class="line">		<span class="keyword">int</span> ri = mid,re=<span class="built_in">end</span>;<span class="comment">//右边数组(基于array)</span></span><br><span class="line">		<span class="keyword">int</span> ai = <span class="built_in">begin</span>; <span class="comment">//array的索引</span></span><br><span class="line">		<span class="comment">//备份左边数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = li; i &lt; le; i++) &#123;<span class="comment">//拷贝左边数组到leftArray</span></span><br><span class="line">			leftArray[i] = <span class="built_in">array</span>[<span class="built_in">begin</span>+i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (li&lt;le) &#123; <span class="comment">//左边没有结束</span></span><br><span class="line">			<span class="keyword">if</span> (ri&lt;re &amp;&amp; cmp(<span class="built_in">array</span>[ri], leftArray[li])&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">array</span>[ai++] = <span class="built_in">array</span>[ri++];<span class="comment">//拷贝右边数组到array</span></span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">array</span>[ai++] = leftArray[li++];<span class="comment">//拷贝左边数组到array</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="comment">//注意，如果cmp比较那里改成&lt;= 就会失去稳定性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>数据源：从1到20000之间随机生成10000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(10000, 1, 20000);</p>
</blockquote>
<p>结果如下：</p>
<p>【BubbleSort】<br>稳定性：true     耗时：0.481s(481ms)     比较次数：4999.50万     交换次数：2467.42万</p>
<p>【BubbleSort1】<br>稳定性：true     耗时：0.428s(428ms)     比较次数：4998.82万     交换次数：2467.42万</p>
<p>【BubbleSort2】<br>稳定性：true     耗时：0.405s(405ms)     比较次数：4993.60万     交换次数：2467.42万</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：0.239s(239ms)     比较次数：2468.42万     交换次数：2467.42万</p>
<p>【InsertionSort2】<br>稳定性：true     耗时：0.186s(186ms)     比较次数：2468.42万     交换次数：0</p>
<p>【InsertionSort3】<br>稳定性：true     耗时：0.114s(114ms)     比较次数：11.90万     交换次数：0</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.005s(5ms)     比较次数：23.53万     交换次数：9999</p>
<p>【MergeSort】<br>稳定性：true     耗时：0.004s(4ms)     比较次数：12.05万     交换次数：0</p>
<p>可以看到归并排序的性能还是很高的。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之堆排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之堆排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是堆排序"><a href="#什么是堆排序" class="headerlink" title="什么是堆排序"></a>什么是堆排序</h2><ul>
<li><a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin" target="_blank" rel="noopener">堆排序（Heap Sort）</a>堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</li>
</ul>
<h2 id="堆的一些性质和结论"><a href="#堆的一些性质和结论" class="headerlink" title="堆的一些性质和结论"></a>堆的一些性质和结论</h2><p>因为本文不是专门讲解堆这种数据结构的，主要是讲解堆排序算法的。所以这里只给出堆的一些性质和结论</p>
<h3 id="最大堆、最小堆"><a href="#最大堆、最小堆" class="headerlink" title="最大堆、最小堆"></a>最大堆、最小堆</h3><ul>
<li>如果任意节点的值总是&gt;=字节的的值，称为：最大堆、大根堆、 大顶堆</li>
<li>如果任意节点的值总是&lt;=字节的的值，称为：最小堆、小根堆、 小顶堆</li>
</ul>
<h3 id="索引i的规律（n是元素数量）"><a href="#索引i的规律（n是元素数量）" class="headerlink" title="索引i的规律（n是元素数量）"></a>索引i的规律（n是元素数量）</h3><ul>
<li>如果i=0 它是根节点</li>
<li>如果 <code>2*i+1&lt;=n-1 它的左子节点的索引为2*i+1</code></li>
<li>如果 <code>2*i+1&gt;n-1 它没有左子节点</code></li>
<li>如果 <code>2*i+2&lt;=n-1 它的右子节点的索引为2*i+2</code></li>
<li>如果 <code>2*i+2&gt;n-1 它没有右子节点</code></li>
</ul>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>堆排序不是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>堆排序属于 In-place</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">HeapSort</span> &lt;<span class="symbol">T</span> <span class="symbol">extends</span> <span class="symbol">Comparable</span>&lt;<span class="symbol">T</span>&gt;&gt; <span class="symbol">extends</span> <span class="symbol">Sort</span>&lt;<span class="symbol">T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> heapSize;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">void</span> sort() &#123;</span><br><span class="line">		<span class="comment">// 原地建堆  自下而上的下滤</span></span><br><span class="line">		heapSize = <span class="built_in">array</span>.length;</span><br><span class="line">		<span class="comment">// heapSize&gt;&gt;1-1 第一个非叶子节点的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = (heapSize&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			siftDown(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (heapSize&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 交换堆顶元素和尾部元素</span></span><br><span class="line">			swap(<span class="number">0</span>, heapSize<span class="number">-1</span>);</span><br><span class="line">			<span class="comment">//堆顶元素最大放到尾部了。下次就不需要考虑这个了。所以size要减1</span></span><br><span class="line">			heapSize--;</span><br><span class="line">			<span class="comment">// 下滤 维护堆的性质</span></span><br><span class="line">			siftDown(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//让index位置的元素下滤</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">void</span> siftDown(<span class="built_in">int</span> index) &#123;</span><br><span class="line">		<span class="comment">// 取出要下滤的坐标的值</span></span><br><span class="line">		T element = <span class="built_in">array</span>[index];</span><br><span class="line">		<span class="built_in">int</span> half = heapSize&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 第一个叶子节点的索引 == 非叶子节点的数量</span></span><br><span class="line">		<span class="comment">// index&lt;第一个叶子节点的索引</span></span><br><span class="line">		<span class="comment">// 必须保证index位置是非叶子节点</span></span><br><span class="line">		<span class="keyword">while</span> (index&lt;half) &#123;</span><br><span class="line">			<span class="comment">// index的节点有2种情况</span></span><br><span class="line">			<span class="comment">// 1.只有左子节点</span></span><br><span class="line">			<span class="comment">// 2.同时有左右子节点</span></span><br><span class="line">						</span><br><span class="line">			<span class="comment">// 默认为左子节点跟它进行比较</span></span><br><span class="line">			<span class="built_in">int</span> childIndex = (index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">			T child = <span class="built_in">array</span>[childIndex];</span><br><span class="line">			<span class="comment">// 右子节点</span></span><br><span class="line">			<span class="built_in">int</span> rightIndex = childIndex +<span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 选出左右子节点最大的那个</span></span><br><span class="line">			<span class="keyword">if</span> (rightIndex&lt;heapSize &amp;&amp; cmp(<span class="built_in">array</span>[rightIndex], child)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				childIndex = rightIndex;</span><br><span class="line">				child = <span class="built_in">array</span>[childIndex];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (cmp(element, child)&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将子节点存放到index位置</span></span><br><span class="line">			<span class="built_in">array</span>[index]= child;</span><br><span class="line">			<span class="comment">// 重新设置index</span></span><br><span class="line">			index = childIndex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将目标值存放到最终的index位置</span></span><br><span class="line">		<span class="built_in">array</span>[index] = element;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>数据源：从1到20000之间随机生成10000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(10000, 1, 20000);</p>
</blockquote>
<p>结果如下：</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.008s(8ms)     比较次数：23.54万     交换次数：9999</p>
<p>【BubbleSort】<br>稳定性：true     耗时：0.502s(502ms)     比较次数：4999.50万     交换次数：2489.42万</p>
<p>【SelectionSort】<br>稳定性：true     耗时：0.115s(115ms)     比较次数：4999.50万     交换次数：9999</p>
<p>可以看到堆排序明显比选择排序和冒泡排序的性能高很多。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之插入排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之插入排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是插入排序"><a href="#什么是插入排序" class="headerlink" title="什么是插入排序"></a>什么是插入排序</h2><ul>
<li><a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="noopener">插入排序</a>（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。。</li>
</ul>
<h2 id="插入排序的基本思想"><a href="#插入排序的基本思想" class="headerlink" title="插入排序的基本思想"></a>插入排序的基本思想</h2><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>插入排序是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>插入排序属于 In-place</li>
</ul>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul>
<li>最好时间复杂度：O(n)</li>
<li>最坏、平均时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路：第一种方案是每次比较。如果后面的比前面的小。就交换位置。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="type">YZ</span>.<span class="type">Sort</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort1&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> <span class="keyword">extends</span> <span class="title">Sort&lt;T&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> void sort() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (int begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">			int cur = begin;</span><br><span class="line">			<span class="keyword">while</span> (cur&gt;<span class="number">0</span> &amp;&amp; cmp(array[cur],array[cur<span class="number">-1</span>])&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				swap(cur, cur<span class="number">-1</span>);</span><br><span class="line">				cur--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>思路：将 <strong>交换</strong> 改为 <strong>挪动</strong></p>
<ul>
<li>先将待插入的元素备份</li>
<li>头部有序数据中比待插入元素大的，都朝尾部方向挪动一个位置</li>
<li>将待插入元素放在最终的合适位置</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InsertionSort2</span>&lt;<span class="symbol">T</span> <span class="symbol">extends</span> <span class="symbol">Comparable</span>&lt;<span class="symbol">T</span>&gt;&gt; <span class="symbol">extends</span> <span class="symbol">Sort</span>&lt;<span class="symbol">T</span>&gt;  &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">void</span> sort() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> begin = <span class="number">1</span>; begin &lt; <span class="built_in">array</span>.length; begin++) &#123;</span><br><span class="line">			<span class="built_in">int</span> cur = begin;</span><br><span class="line">			T res =<span class="built_in">array</span>[cur];</span><br><span class="line">			<span class="keyword">while</span> (cur&gt;<span class="number">0</span> &amp;&amp; cmp(res,<span class="built_in">array</span>[cur<span class="number">-1</span>])&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">array</span>[cur] = <span class="built_in">array</span>[cur<span class="number">-1</span>];</span><br><span class="line">				cur--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[cur] = res;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分法优化"><a href="#二分法优化" class="headerlink" title="二分法优化"></a>二分法优化</h3><p>前面的代码中，想要插入一个元素，是通过逐个比较来寻找要插入的位置。其实可以通过二分法来更快速的查找位置。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort3</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="title">extends</span> <span class="title">Sort</span>&lt;T&gt;  &#123;</span></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">1</span>; <span class="built_in">begin</span> &lt; <span class="built_in">array</span>.length; <span class="built_in">begin</span>++) &#123;</span><br><span class="line">			insert(<span class="built_in">begin</span>, searchIndex(<span class="built_in">begin</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将source位置的元素插入到dest位置</span></span><br><span class="line"><span class="comment">	 * @param source</span></span><br><span class="line"><span class="comment">	 * @param dest</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> source,<span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">		T v = <span class="built_in">array</span>[source];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = source; i &gt; dest; i--) &#123;</span><br><span class="line">			<span class="built_in">array</span>[i] = <span class="built_in">array</span>[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span>[dest] = v;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 利用二分搜索找到 index 位置元素的待插入位置</span></span><br><span class="line"><span class="comment">	 * 已经排好序数组的区间范围是 [0, index)</span></span><br><span class="line"><span class="comment">	 * @param index</span></span><br><span class="line"><span class="comment">	 * @return</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">end</span> = index;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">begin</span>&lt;<span class="built_in">end</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (<span class="built_in">begin</span>+<span class="built_in">end</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (cmp(<span class="built_in">array</span>[index], <span class="built_in">array</span>[mid])&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">end</span> = mid;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">begin</span> = mid +<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>数据源：从1到20000之间随机生成10000个数据来测试</p>
<blockquote>
<p>Integer[] array = Integers.random(10000, 1, 20000);</p>
</blockquote>
<p>结果如下：</p>
<p>【BubbleSort】<br>稳定性：true     耗时：0.481s(481ms)     比较次数：4999.50万     交换次数：2467.42万</p>
<p>【BubbleSort1】<br>稳定性：true     耗时：0.428s(428ms)     比较次数：4998.82万     交换次数：2467.42万</p>
<p>【BubbleSort2】<br>稳定性：true     耗时：0.405s(405ms)     比较次数：4993.60万     交换次数：2467.42万</p>
<p>【InsertionSort1】<br>稳定性：true     耗时：0.239s(239ms)     比较次数：2468.42万     交换次数：2467.42万</p>
<p>【InsertionSort2】<br>稳定性：true     耗时：0.186s(186ms)     比较次数：2468.42万     交换次数：0</p>
<p>【InsertionSort3】<br>稳定性：true     耗时：0.114s(114ms)     比较次数：11.90万     交换次数：0</p>
<p>【HeapSort】<br>稳定性：false     耗时：0.005s(5ms)     比较次数：23.53万     交换次数：9999</p>
<p>可以看到插入排序的性能高于<a href="https://juejin.im/post/5db6ab90f265da4d3d2e3b3b" target="_blank" rel="noopener">冒泡排序</a>，但是低于<a href="https://juejin.im/post/5dba9dfcf265da4d4835c503" target="_blank" rel="noopener">堆排序</a>。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之选择排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之选择排序.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是选择排序"><a href="#什么是选择排序" class="headerlink" title="什么是选择排序"></a>什么是选择排序</h2><ul>
<li><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418?fr=aladdin" target="_blank" rel="noopener">选择排序</a>（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是稳定的排序方法</li>
<li>需要注意的是，不同的写法可能会导致选择排序变成不稳定的。</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：<ul>
<li>①初始状态：无序区为R[1..n]，有序区为空。</li>
<li>②第1趟排序<br>在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。</li>
<li>……</li>
<li>③第i趟排序<br>第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 </li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。</li>
</ul>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>选择排序的最坏、最好、平均时间复杂度为 O(n^2)。<br>综上，因此选择排序总的平均时间复杂度为O(n^2)。但是总体上要比冒泡排序要好。因为交换的次数少于冒泡排序</p>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>选择排序不是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>选择排序属于 In-place</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> <span class="title">&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> <span class="keyword">extends</span> <span class="title">Sort&lt;T&gt;</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> void sort() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (int end = array.length<span class="number">-1</span>; end &gt;<span class="number">0</span>; end--) &#123;</span><br><span class="line">			</span><br><span class="line">			int maxIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (int begin = <span class="number">1</span>; begin &lt;=end; begin++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cmp(maxIndex, begin)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">					maxIndex = begin;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(maxIndex, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>使用数据源如下</p>
<blockquote>
<p>Integer[] array = {7, 3, 5, 8, 6, 7, 4, 5,19,30,40,50};</p>
</blockquote>
<p>结果为：</p>
<ul>
<li>【SelectionSort】 稳定性：true     耗时：0.0s(0ms) 比较次数：66     交换次数：11</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><a href="https://juejin.im/post/5db6ab90f265da4d3d2e3b3b" target="_blank" rel="noopener">上一篇冒泡排序</a>我们是经过了一些代码优化，那么这一种选择排序是否也可以进行优化呢？答案是肯定的。我们可以使用堆来选择最大值，从而进行优化。后续文章会讲到。</p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>十大排序算法之冒泡排序</title>
    <url>/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/十大排序算法之冒泡排序.html">个人博客</a></p>
<p><a href="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列排序包括十大经典排序算法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<ul>
<li>使用的语言为：Java</li>
<li>结构为：<br>定义抽象类<code>Sort</code>里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类<code>Sort</code>。这样我们就能专注于算法本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment">	 * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i1].compareTo(<span class="built_in">array</span>[i2]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(T v1, T v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1.compareTo(v2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">		T tmp = <span class="built_in">array</span>[i1];</span><br><span class="line">		<span class="built_in">array</span>[i1] = <span class="built_in">array</span>[i2];</span><br><span class="line">		<span class="built_in">array</span>[i2] = tmp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是冒泡排序"><a href="#什么是冒泡排序" class="headerlink" title="什么是冒泡排序"></a>什么是冒泡排序</h2><ul>
<li><a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="noopener">冒泡排序（Bubble Sort）</a>是一种计算机科学领域的较简单的排序算法。</li>
<li>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</li>
<li>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</li>
</ul>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e11936eb22cb7c?w=614&h=300&f=png&s=191258" alt=""></p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M 均达到最小值：C=n-1 ， M=0。</li>
<li>所以，冒泡排序最好的时间复杂度为O(n) 。</li>
<li>若初始文件是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>C = n(n-1)/2 = O(n^2).<br>M = 3n(n-1)/2 = O(n^2).</li>
</ul>
<p>冒泡排序的最坏时间复杂度为 O(n^2)。<br>综上，因此冒泡排序总的平均时间复杂度为O(n^2)。</p>
<h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><ul>
<li>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</li>
</ul>
<h3 id="是否是原地算法"><a href="#是否是原地算法" class="headerlink" title="是否是原地算法"></a>是否是原地算法</h3><ul>
<li>何为原地算法？<ul>
<li>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</li>
<li>空间复杂度为 𝑂(1) 的都可以认为是原地算法</li>
</ul>
</li>
<li>非原地算法，称为 Not-in-place 或者 Out-of-place</li>
<li>冒泡排序属于 In-place</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> <span class="keyword">extends</span> <span class="title">Sort&lt;T&gt;</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> void sort() &#123;</span><br><span class="line">		<span class="keyword">for</span> (int end = array.length<span class="number">-1</span>; end&gt;<span class="number">0</span>; end--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (int begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cmp(begin, begin<span class="number">-1</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//ayyay[begin] 小于 ayyay[begin-1] 就交换</span></span><br><span class="line">					swap(begin, begin<span class="number">-1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>我们知道，每次都是两两比较，如果已经拍好顺序了。可以提前终止排序</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort1&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> <span class="keyword">extends</span> <span class="title">Sort&lt;T&gt;</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> void sort() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (int end = array.length<span class="number">-1</span>; end &gt;<span class="number">0</span>; end--) &#123;</span><br><span class="line">			boolean isSorted = <span class="literal">true</span>; <span class="comment">//定义布尔值 isSorted来标记是否有交换</span></span><br><span class="line">			<span class="keyword">for</span> (int begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">				<span class="comment">//ayyay[begin] 小于 ayyay[begin-1] 就交换</span></span><br><span class="line">				<span class="keyword">if</span> (cmp(begin, begin<span class="number">-1</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">					swap(begin, begin<span class="number">-1</span>);</span><br><span class="line">					isSorted = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">				<span class="comment">//来到这里，说明没有交换过。已经是完全有序的了。提前终止排序</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h3><ul>
<li>如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort2</span>&lt;T extends Comparable&lt;T&gt;&gt; <span class="title">extends</span> <span class="title">Sort</span>&lt;T&gt;   &#123;</span></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">end</span> = <span class="built_in">array</span>.length<span class="number">-1</span>; <span class="built_in">end</span> &gt;<span class="number">0</span>; <span class="built_in">end</span>--) &#123;</span><br><span class="line">			<span class="keyword">int</span> sortedIndex = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">1</span>; <span class="built_in">begin</span> &lt;= <span class="built_in">end</span>; <span class="built_in">begin</span>++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cmp(<span class="built_in">begin</span>, <span class="built_in">begin</span><span class="number">-1</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">					swap(<span class="built_in">begin</span>, <span class="built_in">begin</span><span class="number">-1</span>);</span><br><span class="line">					sortedIndex = <span class="built_in">begin</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">end</span> = sortedIndex;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>使用数据源如下</p>
<blockquote>
<p>Integer[] array = {7, 3, 5, 8, 6, 7, 4, 5,19,30,40,50};</p>
</blockquote>
<p>结果为：</p>
<ul>
<li>【BubbleSort】 稳定性：true     耗时：0.0s(0ms) 比较次数：66     交换次数：14</li>
</ul>
<ul>
<li>【BubbleSort1】稳定性：true     耗时：0.001s(1ms)     比较次数：51     交换次数：14    </li>
</ul>
<ul>
<li>【BubbleSort2】稳定性：true     耗时：0.0s(0ms)     比较次数：30     交换次数：14</li>
</ul>
<p>可以明显感觉到做了优化之后，比较测试减少了。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><ul>
<li>文中的代码在git上：<a href="https://github.com/ITyongzhen/DataStructureAndAlgorithm" target="_blank" rel="noopener">github地址</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
  </entry>
  <entry>
    <title>iOS使用RunLoop监控线上卡顿</title>
    <url>/iOS%E4%BD%BF%E7%94%A8RunLoop%E7%9B%91%E6%8E%A7%E7%BA%BF%E4%B8%8A%E5%8D%A1%E9%A1%BF.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/iOS%E4%BD%BF%E7%94%A8RunLoop%E7%9B%91%E6%8E%A7%E7%BA%BF%E4%B8%8A%E5%8D%A1%E9%A1%BF.html">我的个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于性能优化，我之前写过<a href="https://juejin.im/post/5d1a00846fb9a07ed657eb3f" target="_blank" rel="noopener">iOS性能优化</a>，经过优化之后，我们的APP，冷启动，从2.7秒优化到了0.6秒。</p>
<p>关RunLoop，写过<a href="https://juejin.im/post/5d04c88d5188255e1305ca09" target="_blank" rel="noopener">RunLoop详解之源码分析</a>,以及<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3RunLoop%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">详解RunLoop与多线程
</a>，那么使用RunLoop如何来监控性能卡顿呢。<br>通过<a href="https://juejin.im/post/5d1a00846fb9a07ed657eb3f" target="_blank" rel="noopener">iOS性能优化</a> 我们知道，简单来说App卡顿，就是FPS达不到60帧率，丢帧现象，就会卡顿。但是很多时候，我们只知道丢帧了。具体为什么丢帧，却不是很清楚，那么我们要怎么监控呢，首先我们要明白，要找出卡顿，就是要找出主线程做了什么，而线程消息，是依赖RunLoop的，所以我们可以使用RunLoop来监控。</p>
<blockquote>
<p>RunLoop是用来监听输入源，进行调度处理的。如果RunLoop的线程进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p>
</blockquote>
<h2 id="RunLoop和信号量"><a href="#RunLoop和信号量" class="headerlink" title="RunLoop和信号量"></a>RunLoop和信号量</h2><p><strong>我们可以使用CFRunLoopObserverRef来监控NSRunLoop的状态,通过它可以实时获得这些状态值的变化。</strong></p>
<h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h3><p>关于runloop,可以参照 <a href="https://juejin.im/post/5d04c88d5188255e1305ca09" target="_blank" rel="noopener">RunLoop详解之源码分析</a> 这篇文章详细了解。这里简单总结一下: </p>
<ul>
<li>runloop的状态</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),           <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),    <span class="comment">//即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),   <span class="comment">//即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),   <span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),    <span class="comment">//刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),            <span class="comment">//即将退出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U   <span class="comment">//所有状态改变</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>CFRunLoopObserverRef 的使用流程</p>
<ol>
<li><p>设置Runloop observer的运行环境</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<pre><code>2. 创建Runloop observer对象

<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">第一个参数：用于分配observer对象的内存</span><br><span class="line">第二个参数：用以设置observer所要关注的事件</span><br><span class="line">第三个参数：用于标识该observer是在第一次进入runloop时执行还是每次进入runloop处理时均执行</span><br><span class="line">第四个参数：用于设置该observer的优先级</span><br><span class="line">第五个参数：用于设置该observer的回调函数</span><br><span class="line">第六个参数：用于设置该observer的运行环境</span><br><span class="line"> <span class="comment">// 创建Runloop observer对象</span></span><br><span class="line">   _observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       YES,</span><br><span class="line">                                       <span class="number">0</span>,</span><br><span class="line">                                       <span class="meta">&amp;runLoopObserverCallBack,</span></span><br><span class="line">                                       <span class="meta">&amp;context);</span></span><br></pre></td></tr></table></figure>


3. 将新建的observer加入到当前thread的runloop

<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddObserver(<span class="name">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

4. 将observer从当前thread的runloop中移除

<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">CFRunLoopRemoveObserver(<span class="name">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

5. 释放 observer

<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">CFRelease</span>(<span class="variable">_observer</span>); <span class="variable">_observer</span> = <span class="variable"><span class="literal">NULL</span></span>;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>关于信号量，可以详细参考 <a href="https://www.jianshu.com/p/24ffa819379c" target="_blank" rel="noopener">GCD信号量-dispatch_semaphore_t</a> </p>
<p>简单来说,主要有三个函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dispatch<span class="constructor">_semaphore_create(<span class="params">long</span> <span class="params">value</span>)</span>; <span class="comment">// 创建信号量</span></span><br><span class="line">dispatch<span class="constructor">_semaphore_signal(<span class="params">dispatch_semaphore_t</span> <span class="params">deem</span>)</span>; <span class="comment">// 发送信号量</span></span><br><span class="line">dispatch<span class="constructor">_semaphore_wait(<span class="params">dispatch_semaphore_t</span> <span class="params">dsema</span>, <span class="params">dispatch_time_t</span> <span class="params">timeout</span>)</span>; <span class="comment">// 等待信号量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<p>dispatch_semaphore_create(long value);和GCD的group等用法一致，这个函数是创建一个dispatch_semaphore_类型的信号量，并且创建的时候需要指定信号量的大小。<br>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); 等待信号量。如果信号量值为0，那么该函数就会一直等待，也就是不返回（相当于阻塞当前线程），直到该函数等待的信号量的值大于等于1，该函数会对信号量的值进行减1操作，然后返回。<br>dispatch_semaphore_signal(dispatch_semaphore_t deem); 发送信号量。该函数会对信号量的值进行加1操作。<br>通常等待信号量和发送信号量的函数是成对出现的。并发执行任务时候，在当前任务执行之前，用dispatch_semaphore_wait函数进行等待（阻塞），直到上一个任务执行完毕后且通过dispatch_semaphore_signal函数发送信号量（使信号量的值加1），dispatch_semaphore_wait函数收到信号量之后判断信号量的值大于等于1，会再对信号量的值减1，然后当前任务可以执行，执行完毕当前任务后，再通过dispatch_semaphore_signal函数发送信号量（使信号量的值加1），通知执行下一个任务……如此一来，通过信号量，就达到了并发队列中的任务同步执行的要求。</p>
</blockquote>
</blockquote>
<h2 id="监控卡顿"><a href="#监控卡顿" class="headerlink" title="监控卡顿"></a>监控卡顿</h2><h3 id="原理-利用观察Runloop各种状态变化的持续时间来检测计算是否发生卡顿"><a href="#原理-利用观察Runloop各种状态变化的持续时间来检测计算是否发生卡顿" class="headerlink" title="原理: 利用观察Runloop各种状态变化的持续时间来检测计算是否发生卡顿"></a>原理: 利用观察Runloop各种状态变化的持续时间来检测计算是否发生卡顿</h3><p> 一次有效卡顿采用了“N次卡顿超过阈值T”的判定策略，即一个时间段内卡顿的次数累计大于N时才触发采集和上报：举例，卡顿阈值T=500ms、卡顿次数N=1，可以判定为单次耗时较长的一次有效卡顿；而卡顿阈值T=50ms、卡顿次数N=5，可以判定为频次较快的一次有效卡顿</p>
<h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// minimum</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSInteger</span> MXRMonitorRunloopMinOneStandstillMillisecond = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSInteger</span> MXRMonitorRunloopMinStandstillCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="comment">// 超过多少毫秒为一次卡顿</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSInteger</span> MXRMonitorRunloopOneStandstillMillisecond = <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 多少次卡顿纪录为一次有效卡顿</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSInteger</span> MXRMonitorRunloopStandstillCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZMonitorRunloop</span>()</span>&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> _observer;  <span class="comment">// 观察者</span></span><br><span class="line">    dispatch_semaphore_t _semaphore; <span class="comment">// 信号量</span></span><br><span class="line">    <span class="built_in">CFRunLoopActivity</span> _activity;     <span class="comment">// 状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isCancel; <span class="comment">//f是否取消检测</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countTime; <span class="comment">// 耗时次数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *backtrace;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)registerObserver&#123;</span><br><span class="line"><span class="comment">//    1. 设置Runloop observer的运行环境</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 2. 创建Runloop observer对象</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//    第一个参数：用于分配observer对象的内存</span></span><br><span class="line"><span class="comment">//    第二个参数：用以设置observer所要关注的事件</span></span><br><span class="line"><span class="comment">//    第三个参数：用于标识该observer是在第一次进入runloop时执行还是每次进入runloop处理时均执行</span></span><br><span class="line"><span class="comment">//    第四个参数：用于设置该observer的优先级</span></span><br><span class="line"><span class="comment">//    第五个参数：用于设置该observer的回调函数</span></span><br><span class="line"><span class="comment">//    第六个参数：用于设置该observer的运行环境</span></span><br><span class="line">    _observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                        kCFRunLoopAllActivities,</span><br><span class="line">                                        <span class="literal">YES</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;runLoopObserverCallBack,</span><br><span class="line">                                        &amp;context);</span><br><span class="line">    <span class="comment">// 3. 将新建的observer加入到当前thread的runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">// 创建信号  dispatchSemaphore的知识参考：https://www.jianshu.com/p/24ffa819379c</span></span><br><span class="line">    _semaphore = dispatch_semaphore_create(<span class="number">0</span>); <span class="comment">////Dispatch Semaphore保证同步</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    dispatch_queue_t queue = dispatch_queue_create("kadun", NULL);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子线程监控时长</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//      dispatch_async(queue, ^&#123;</span></span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="keyword">if</span> (!strongSelf) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strongSelf.isCancel) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// N次卡顿超过阈值T记录为一次卡顿</span></span><br><span class="line">            <span class="comment">// 等待信号量：如果信号量是0，则阻塞当前线程；如果信号量大于0，则此函数会把信号量-1，继续执行线程。此处超时时间设为limitMillisecond 毫秒。</span></span><br><span class="line">            <span class="comment">// 返回值：如果线程是唤醒的，则返回非0，否则返回0</span></span><br><span class="line">            <span class="keyword">long</span> semaphoreWait = dispatch_semaphore_wait(<span class="keyword">self</span>-&gt;_semaphore, dispatch_time(DISPATCH_TIME_NOW, strongSelf.limitMillisecond * <span class="built_in">NSEC_PER_MSEC</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (semaphoreWait != <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠(kCFRunLoopBeforeSources)，或者线程唤醒后接收消息时间过长(kCFRunLoopAfterWaiting)而无法进入下一步的话，就可以认为是线程受阻。</span></span><br><span class="line">                <span class="comment">//两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够监测到是否卡顿</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;_activity == kCFRunLoopBeforeSources || <span class="keyword">self</span>-&gt;_activity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (++strongSelf.countTime &lt; strongSelf.standstillCount)&#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,strongSelf.countTime);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [strongSelf logStack];</span><br><span class="line">                    [strongSelf printLogTrace];</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">NSString</span> *backtrace = [YZCallStack yz_backtraceOfMainThread];</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"++++%@"</span>,backtrace);</span><br><span class="line">                    </span><br><span class="line">                    [[YZLogFile sharedInstance] writefile:backtrace];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (strongSelf.callbackWhenStandStill) &#123;</span><br><span class="line">                        strongSelf.callbackWhenStandStill();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            strongSelf.countTime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="demo测试"><a href="#demo测试" class="headerlink" title="demo测试"></a>demo测试</h3><p>我把demo放在了github <a href="https://github.com/ITyongzhen/YZMonitorRunloop" target="_blank" rel="noopener">demo地址</a></p>
<p>使用时候，只需要 </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    </span><br><span class="line">    [[YZMonitorRunloop sharedInstance] startMonitor];</span><br><span class="line">    [YZMonitorRunloop sharedInstance].callbackWhenStandStill = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"eagle.检测到卡顿了"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制器中，每次点击屏幕，休眠1秒钟，如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">     usleep(<span class="number">1</span> * <span class="number">1000</span> * <span class="number">1000</span>); <span class="comment">// 1秒</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>点击屏幕之后，打印如下 </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">YZMonitorRunLoopDemo[<span class="number">10288</span>:<span class="number">1915706</span>] ==========检测到卡顿之后调用堆栈==========</span><br><span class="line"> (</span><br><span class="line">    <span class="string">"0   YZMonitorRunLoopDemo                0x00000001022c653c -[YZMonitorRunloop logStack] + 96"</span>,</span><br><span class="line">    <span class="string">"1   YZMonitorRunLoopDemo                0x00000001022c62a0 __36-[YZMonitorRunloop registerObserver]_block_invoke + 484"</span>,</span><br><span class="line">    <span class="string">"2   libdispatch.dylib                   0x00000001026ab6f0 _dispatch_call_block_and_release + 24"</span>,</span><br><span class="line">    <span class="string">"3   libdispatch.dylib                   0x00000001026acc74 _dispatch_client_callout + 16"</span>,</span><br><span class="line">    <span class="string">"4   libdispatch.dylib                   0x00000001026afad4 _dispatch_queue_override_invoke + 876"</span>,</span><br><span class="line">    <span class="string">"5   libdispatch.dylib                   0x00000001026bddc8 _dispatch_root_queue_drain + 372"</span>,</span><br><span class="line">    <span class="string">"6   libdispatch.dylib                   0x00000001026be7ac _dispatch_worker_thread2 + 156"</span>,</span><br><span class="line">    <span class="string">"7   libsystem_pthread.dylib             0x00000001b534d1b4 _pthread_wqthread + 464"</span>,</span><br><span class="line">    <span class="string">"8   libsystem_pthread.dylib             0x00000001b534fcd4 start_wqthread + 4"</span></span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib          <span class="number">0x1b52ca400</span> __semwait_signal + <span class="number">8</span></span><br><span class="line">libsystem_c.dylib               <span class="number">0x1b524156c</span> nanosleep + <span class="number">212</span></span><br><span class="line">libsystem_c.dylib               <span class="number">0x1b5241444</span> usleep + <span class="number">64</span></span><br><span class="line">YZMonitorRunLoopDemo            <span class="number">0x1022c18dc</span> -[ViewController touchesBegan:withEvent:] + <span class="number">76</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e1f4fcdc</span> &lt;redacted&gt; + <span class="number">336</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e1f4fb78</span> &lt;redacted&gt; + <span class="number">60</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e1f5e0f8</span> &lt;redacted&gt; + <span class="number">1584</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e1f5f52c</span> &lt;redacted&gt; + <span class="number">3140</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e1f3f59c</span> &lt;redacted&gt; + <span class="number">340</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e2005714</span> &lt;redacted&gt; + <span class="number">1768</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e2007e40</span> &lt;redacted&gt; + <span class="number">4828</span></span><br><span class="line">UIKitCore                       <span class="number">0x1e2001070</span> &lt;redacted&gt; + <span class="number">152</span></span><br><span class="line">CoreFoundation                  <span class="number">0x1b56bf018</span> &lt;redacted&gt; + <span class="number">24</span></span><br><span class="line">CoreFoundation                  <span class="number">0x1b56bef98</span> &lt;redacted&gt; + <span class="number">88</span></span><br><span class="line">CoreFoundation                  <span class="number">0x1b56be880</span> &lt;redacted&gt; + <span class="number">176</span></span><br><span class="line">CoreFoundation                  <span class="number">0x1b56b97</span></span><br></pre></td></tr></table></figure>

<p>即可定位到卡顿位置</p>
<blockquote>
<p>-[ViewController touchesBegan:withEvent:]</p>
</blockquote>
<h2 id="卡顿日志写入本地"><a href="#卡顿日志写入本地" class="headerlink" title="卡顿日志写入本地"></a>卡顿日志写入本地</h2><p>上面已经监控到了卡顿，和调用堆栈。如果是debug模式下，可以直接看日志，如果想在线上查看的话，可以写入本地，然后上传到服务器</p>
<h3 id="写入本地数据库"><a href="#写入本地数据库" class="headerlink" title="写入本地数据库"></a>写入本地数据库</h3><ul>
<li>创建本地路径 </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">	-(<span class="built_in">NSString</span> *)getLogPath&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *paths  = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *homePath = [paths objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [homePath stringByAppendingPathComponent:<span class="string">@"Caton.log"</span>];</span><br><span class="line">    <span class="keyword">return</span> filePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是第一次写入，带上设备信息，手机型号等信息</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span> getLogPath];</span><br><span class="line">   <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(![fileManager fileExistsAtPath:filePath]) <span class="comment">//如果不存在</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">NSString</span> *str = <span class="string">@"卡顿日志"</span>;</span><br><span class="line">       <span class="built_in">NSString</span> *systemVersion = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"手机版本: %@"</span>,[YZAppInfoUtil iphoneSystemVersion]];</span><br><span class="line">       <span class="built_in">NSString</span> *iphoneType = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"手机型号: %@"</span>,[YZAppInfoUtil iphoneType]];</span><br><span class="line">       str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@\n%@\n%@"</span>,str,systemVersion,iphoneType];</span><br><span class="line">       [str writeToFile:filePath atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果本地文件已经存在，就先判断大小是否过大，决定是否直接写入，还是先上传到服务器</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">float</span> filesize = <span class="number">-1.0</span>;</span><br><span class="line"> <span class="keyword">if</span> ([fileManager fileExistsAtPath:filePath]) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *fileDic = [fileManager attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size = [[fileDic objectForKey:<span class="built_in">NSFileSize</span>] longLongValue];</span><br><span class="line">            filesize = <span class="number">1.0</span> * size / <span class="number">1024</span>;</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"文件大小 filesize = %lf"</span>,filesize);</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"文件内容 %@"</span>,string);</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@" ---------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (filesize &gt; (<span class="keyword">self</span>.MAXFileLength &gt; <span class="number">0</span> ? <span class="keyword">self</span>.MAXFileLength:DefaultMAXLogFileLength)) &#123;</span><br><span class="line">     <span class="comment">// 上传到服务器</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@" 上传到服务器"</span>);</span><br><span class="line">       [<span class="keyword">self</span> update];</span><br><span class="line">       [<span class="keyword">self</span> clearLocalLogFile];</span><br><span class="line">       [<span class="keyword">self</span> writeToLocalLogFilePath:filePath contentStr:string];</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"继续写入本地"</span>);</span><br><span class="line">        [<span class="keyword">self</span> writeToLocalLogFilePath:filePath contentStr:string];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="压缩日志，上传服务器"><a href="#压缩日志，上传服务器" class="headerlink" title="压缩日志，上传服务器"></a>压缩日志，上传服务器</h2><p>因为都是文本数据，所以我们可以压缩之后，打打降低占用空间，然后进行上传，上传成功之后，删除本地，然后继续写入，等待下次写日志</p>
<h3 id="压缩工具"><a href="#压缩工具" class="headerlink" title="压缩工具"></a>压缩工具</h3><p>使用 <a href="https://github.com/wuhaiwei/SSZipArchive" target="_blank" rel="noopener">SSZipArchive</a>具体使用起来也很简单，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unzipping</span></span><br><span class="line">NSString *zipPath = @<span class="string">"path_to_your_zip_file"</span>;</span><br><span class="line">NSString *destinationPath = @<span class="string">"path_to_the_folder_where_you_want_it_unzipped"</span>;</span><br><span class="line">[SSZipArchive <span class="string">unzipFileAtPath:</span>zipPath <span class="string">toDestination:</span>destinationPath];</span><br><span class="line"><span class="comment">// Zipping</span></span><br><span class="line">NSString *zippedPath = @<span class="string">"path_where_you_want_the_file_created"</span>;</span><br><span class="line">NSArray *inputPaths = [NSArray <span class="string">arrayWithObjects:</span></span><br><span class="line">                       [[NSBundle mainBundle] <span class="string">pathForResource:</span>@<span class="string">"photo1"</span> <span class="string">ofType:</span>@<span class="string">"jpg"</span>],</span><br><span class="line">                       [[NSBundle mainBundle] <span class="string">pathForResource:</span>@<span class="string">"photo2"</span> <span class="string">ofType:</span>@<span class="string">"jpg"</span>]</span><br><span class="line">                       nil];</span><br><span class="line">[SSZipArchive <span class="string">createZipFileAtPath:</span>zippedPath <span class="string">withFilesAtPaths:</span>inputPaths];</span><br></pre></td></tr></table></figure>


<p>代码中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *zipPath = [<span class="keyword">self</span> getLogZipPath];</span><br><span class="line">  <span class="built_in">NSString</span> *password = <span class="literal">nil</span>;</span><br><span class="line">  <span class="built_in">NSMutableArray</span> *filePaths = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  [filePaths addObject:[<span class="keyword">self</span> getLogPath]];</span><br><span class="line">  <span class="built_in">BOOL</span> success = [SSZipArchive createZipFileAtPath:zipPath withFilesAtPaths:filePaths withPassword:password.length &gt; <span class="number">0</span> ? password : <span class="literal">nil</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"压缩成功"</span>);</span><br><span class="line">      </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"压缩失败"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>具体如果上传到服务器，使用者可以用AFN等将本地的 zip文件上传到文件服务器即可，就不赘述了。</p>
<p>至此，我们做到了，用runloop，监控卡顿，写入日志，然后压缩上传服务器，删除本地的过程。</p>
<p>详细代码见<a href="https://github.com/ITyongzhen/YZMonitorRunloop" target="_blank" rel="noopener">demo地址</a></p>
<p>参考资料 ：</p>
<p><a href="https://github.com/bestswifter/BSBacktraceLogger" target="_blank" rel="noopener">BSBacktraceLogger</a></p>
<p><a href="https://www.jianshu.com/p/24ffa819379c" target="_blank" rel="noopener">GCD信号量-dispatch_semaphore_t</a></p>
<p><a href="https://github.com/wuhaiwei/SSZipArchive" target="_blank" rel="noopener">SSZipArchive</a></p>
<p><a href="https://www.jianshu.com/p/71cfbcb15842" target="_blank" rel="noopener">简单监测iOS卡顿的demo</a></p>
<p><a href="https://juejin.im/post/5cacb2baf265da03904bf93b" target="_blank" rel="noopener">RunLoop实战：实时卡顿监控</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>KVC那点儿事</title>
    <url>/KVC%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/KVC%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。而不是通过调用Setter、Getter方法访问。KVC的方法定义在Foundation/NSKeyValueCoding中。</li>
<li>KVC和KVO都属于键值编程而且底层实现机制都是<strong>isa-swizzing</strong>。</li>
</ul>
<p>常见的API有</p>
<ul>
<li>-(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</li>
<li>-(void)setValue:(id)value forKey:(NSString *)key;</li>
<li>-(id)valueForKeyPath:(NSString *)keyPath;</li>
<li>-(id)valueForKey:(NSString *)key; </li>
</ul>
<h2 id="KVC基本使用"><a href="#KVC基本使用" class="headerlink" title="KVC基本使用"></a>KVC基本使用</h2><ul>
<li>定义一个YZPerson类，有个 name 属性</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ViewController 控制器中，如下使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">     <span class="comment">// 赋值</span></span><br><span class="line">    [person setValue:<span class="string">@"jack"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">    <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[person valueForKey:<span class="string">@"name"</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结果为</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">25838</span>:<span class="number">347883</span>] jack</span><br></pre></td></tr></table></figure>

<h2 id="赋值-setValue-forKey-的原理"><a href="#赋值-setValue-forKey-的原理" class="headerlink" title="赋值  setValue:forKey:的原理"></a>赋值  setValue:forKey:的原理</h2><ol>
<li>按照 <strong>setKey:</strong>、<strong>_setKey:</strong> 的顺序查找方法</li>
<li>如果找到了方法，就传递参数，调用方法</li>
<li>如果没有找到，查看 <strong>accessInstanceVariablesDirectly</strong> 方法的返回值</li>
<li>如果<strong>accessInstanceVariablesDirectly</strong> 返回值为 <strong>NO</strong> 调用</li>
</ol>
<p><strong>setValue:forUndefinedKey:</strong> 并抛出异常 <strong>NSUnknownKeyException</strong><br>5. 如果<strong>accessInstanceVariablesDirectly</strong> 返回值为 <strong>YES</strong> 按照<strong>_key</strong>、<strong>_isKey</strong>、<strong>key</strong>、<strong>isKey</strong>的顺序查找成员变量<br>6. 如果找到了成员变量，就直接赋值。<br>7. 如果 <strong>_key</strong>、<strong>_isKey</strong>、<strong>key</strong>、<strong>isKey</strong>的顺序没有查找到成员变量就调用<strong>setValue:forUndefinedKey:</strong> 并抛出异常 <strong>NSUnknownKeyException</strong></p>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200531084215.png" alt=""></p>
<h3 id="证明赋值"><a href="#证明赋值" class="headerlink" title="证明赋值"></a>证明赋值</h3><h4 id="先证明-按照-setKey-、-setKey-的顺序查找方法"><a href="#先证明-按照-setKey-、-setKey-的顺序查找方法" class="headerlink" title="先证明 按照 setKey:、_setKey: 的顺序查找方法"></a>先证明 按照 <strong>setKey:</strong>、<strong>_setKey:</strong> 的顺序查找方法</h4><p><strong>YZPerson.h</strong> 和 <strong>YZPerson.m</strong> 如下</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 只有name属性，没有age</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YZPerson</span><br><span class="line">- (void)<span class="attribute">setAge</span>:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"setAge: - %d"</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">_setAge</span><span class="selector-pseudo">:(int)age</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"_setAge: - %d"</span>, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用地方 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">   <span class="comment">// 赋值</span></span><br><span class="line">[person <span class="string">setValue:</span>@<span class="number">20</span> <span class="string">forKey:</span>@<span class="string">"age"</span>];</span><br></pre></td></tr></table></figure>

<p>打印结果是</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">26389</span>:<span class="number">357519</span>] setAge: - <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>说明调用来的是<strong>setAge:</strong> 那如果 去掉 <strong>setAge:</strong> 呢</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 只有name属性，没有age</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YZPerson</span><br><span class="line">- (void)<span class="attribute">setAge</span>:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"setAge: - %d"</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">_setAge</span><span class="selector-pseudo">:(int)age</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"_setAge: - %d"</span>, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">26594</span>:<span class="number">360894</span>] _setAge: - <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>证明了 按照 <strong>setKey:</strong>、<strong>_setKey:</strong> 的顺序查找方法</p>
<h3 id="证明-accessInstanceVariablesDirectly"><a href="#证明-accessInstanceVariablesDirectly" class="headerlink" title="证明 accessInstanceVariablesDirectly"></a>证明 accessInstanceVariablesDirectly</h3><ol>
<li>如果<strong>accessInstanceVariablesDirectly</strong> 返回值为 <strong>NO</strong> 调用<strong>setValue:forUndefinedKey:</strong> 并抛出异常 <strong>NSUnknownKeyException</strong></li>
<li>如果<strong>accessInstanceVariablesDirectly</strong> 返回值为 <strong>YES</strong> 就去查找成员变量，就直接赋值。</li>
</ol>
<ul>
<li>我们在 YZPerson.h 中定义四个成员变量, YZPerson.m中 只有accessInstanceVariablesDirectly 并返回NO</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> isAge;</span><br><span class="line">        <span class="keyword">int</span> _isAge;</span><br><span class="line">        <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的返回值就是YES</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>运行报错:找不到 key值 age</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">27163</span>:<span class="number">369895</span>] *** Terminating app due <span class="keyword">to</span> uncaught exception </span><br><span class="line"><span class="comment">'NSUnknownKeyException', reason: '[<span class="doctag">&lt;YZPerson 0x600003a5e700&gt;</span> </span></span><br><span class="line">setValue:forUndefinedKey:]: this <span class="keyword">class</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">key</span> value </span><br><span class="line">coding-compliant <span class="keyword">for</span> the <span class="keyword">key</span> age.<span class="comment">'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们把YZPerson.m中 只有accessInstanceVariablesDirectly 返回YES</li>
</ul>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">27385</span>:<span class="number">373752</span>] <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="证明是按照-key、-isKey、key、isKey的顺序查找成员变量"><a href="#证明是按照-key、-isKey、key、isKey的顺序查找成员变量" class="headerlink" title="证明是按照_key、_isKey、key、isKey的顺序查找成员变量"></a>证明是按照<strong>_key</strong>、<strong>_isKey</strong>、<strong>key</strong>、<strong>isKey</strong>的顺序查找成员变量</h3><p>代码还是上面的代码，打断点，然后LLDB调试</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>_age</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>_isAge</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>age</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>isAge</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果去掉成员变量<strong>_age</strong></p>
<p>结果为</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>_isAge</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>age</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">lldb</span>) po person-&gt;</span>isAge</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<p>同理其他的几种情况，读者可自行尝试 <a href="[github](https://github.com/ITyongzhen/MyBlogs-iOS-Demos)">demo</a>。</p>
<h2 id="KVC与KVO"><a href="#KVC与KVO" class="headerlink" title="KVC与KVO"></a>KVC与KVO</h2><p>通过<a href="https://ityongzhen.github.io/%E5%85%B3%E4%BA%8EKVO%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html">关于KVO看这篇就够了</a> 我们知道</p>
<h3 id="KVO的本质"><a href="#KVO的本质" class="headerlink" title="KVO的本质"></a>KVO的本质</h3><ul>
<li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li>
<li>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<ul>
<li>willChangeValueForKey:</li>
<li>父类原来的setter</li>
<li>didChangeValueForKey:</li>
</ul>
</li>
<li>内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li>
</ul>
<p>那么KVC能否触发KVO呢，</p>
<p>我们在 YZPerson.h中书写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> isAge;</span><br><span class="line">        <span class="keyword">int</span> _isAge;</span><br><span class="line">        <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们知道，成员变量是不会生成set 和 get方法的<br>然后 YZPerson.m中书写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的返回值就是YES</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在VC中设置KVO监听</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) YZPerson *person;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc]init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加KVO监听</span></span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过KVC修改age属性</span></span><br><span class="line">    [<span class="keyword">self</span>.person setValue:@<span class="number">10</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"取值为：%@"</span>,[<span class="keyword">self</span>.person valueForKey:<span class="string">@"age"</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"observeValueForKeyPath - %@"</span>, change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="comment">// 移除KVO监听</span></span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">28271</span>:<span class="number">388786</span>] observeValueForKeyPath - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">10</span>;</span><br><span class="line">    old = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">KVCDemo[<span class="number">28271</span>:<span class="number">388786</span>] 取值为：<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可知，其实在系统内部，是调用了 </p>
<pre><code>- willChangeValueForKey:

- didChangeValueForKey:</code></pre><h3 id="进一步验证"><a href="#进一步验证" class="headerlink" title="进一步验证"></a>进一步验证</h3><p>然后 YZPerson.m中书写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey - %@"</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - begin - %@"</span>, key);</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - end - %@"</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认的返回值就是YES</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">KVCDemo[<span class="number">28392</span>:<span class="number">390730</span>] willChangeValueForKey - age</span><br><span class="line">KVCDemo[<span class="number">28392</span>:<span class="number">390730</span>] didChangeValueForKey - begin - age</span><br><span class="line">KVCDemo[<span class="number">28392</span>:<span class="number">390730</span>] observeValueForKeyPath - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">10</span>;</span><br><span class="line">    old = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">KVCDemo[<span class="number">28392</span>:<span class="number">390730</span>] didChangeValueForKey - end - age</span><br><span class="line">KVCDemo[<span class="number">28392</span>:<span class="number">390730</span>] 取值为：<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>所以，足以说明，KVC内部调用了 <strong>willChangeValueForKey</strong> 和 <strong>didChangeValueForKey</strong></p>
<h2 id="取值-valueForKey-的原理"><a href="#取值-valueForKey-的原理" class="headerlink" title="取值  valueForKey:的原理"></a>取值  valueForKey:的原理</h2><ol>
<li>按照<strong>getKey</strong>、<strong>key</strong>、<strong>isKey</strong>、<strong>_key</strong>的顺序查找方法</li>
<li>如果找到了，就直接调用</li>
<li>如果没找到，就查看<strong>accessInstanceVariablesDirectly</strong> 方法的返回值</li>
<li>如果<strong>accessInstanceVariablesDirectly</strong> 返回值为 <strong>NO</strong> 调用<strong>valueForUndefinedKey:</strong>并抛出异常<strong>NSUnknownKeyException</strong></li>
<li>如果<strong>accessInstanceVariablesDirectly</strong> 返回值为 <strong>YES</strong> 按照<strong>_key</strong>、<strong>_isKey</strong>、<strong>key</strong>、<strong>isKey</strong>的顺序查找成员变量</li>
<li>如果找到了成员变量，就直接取值。</li>
<li>如果 <strong>_key</strong>、<strong>_isKey</strong>、<strong>key</strong>、<strong>isKey</strong>的顺序没有查找到成员变量就调用<strong>valueForUndefinedKey:</strong>并抛出异常<strong>NSUnknownKeyException</strong></li>
</ol>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200531084422.png" alt=""></p>
<h3 id="验证取值"><a href="#验证取值" class="headerlink" title="验证取值"></a>验证取值</h3><ul>
<li>取值和赋值的大体逻辑基本一致</li>
</ul>
<p>然后 YZPerson.m中书写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)getAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)isAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)_age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认的返回值就是YES</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)accessInstanceVariablesDirectly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>VC中如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc]init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"取值为：%@"</span>,[<span class="keyword">self</span>.person valueForKey:<span class="string">@"age"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVCDemo[<span class="number">29145</span>:<span class="number">403008</span>] 取值为：<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>如果去掉  </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">int</span>)getAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则，输出结果为12。</p>
<p>上面验证了 按照<strong>getKey</strong>、<strong>key</strong>、<strong>isKey</strong>、<strong>_key</strong>的顺序查找方法</p>
<p>其他的验证逻辑，和赋值验证过程一致，就不赘述了。</p>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS性能优化</title>
    <url>/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">个人博客</a></p>
<h3 id="一、App启动优化"><a href="#一、App启动优化" class="headerlink" title="一、App启动优化"></a>一、App启动优化</h3><h4 id="1-App的启动可以分为2种"><a href="#1-App的启动可以分为2种" class="headerlink" title="1.App的启动可以分为2种"></a>1.App的启动可以分为2种</h4><ul>
<li>冷启动(Cold Launch):从零开始启动APP</li>
<li>热启动(Warm Launch):APP已经在内存中，在后台存活着，再次点击图标启动APP<ul>
<li>APP启动时间的优化，主要是针对冷启动进行优化</li>
<li>通过添加环境变量可以打印出APP的启动时间分析(Edit scheme -&gt; Run -&gt; Arguments) DYLD_PRINT_STATISTICS设置为1</li>
<li>如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1</li>
</ul>
</li>
</ul>
<h4 id="2-App-冷启动分为四大阶段"><a href="#2-App-冷启动分为四大阶段" class="headerlink" title="2.App 冷启动分为四大阶段"></a>2.App 冷启动分为四大阶段</h4><ul>
<li>dyld 加载可执行文件，动态库(递归加载)</li>
<li>runtime</li>
<li>main() 函数执行后</li>
<li>首屏渲染完成后</li>
</ul>
<h5 id="2-1关于dyld"><a href="#2-1关于dyld" class="headerlink" title="2.1关于dyld"></a>2.1关于dyld</h5><ul>
<li><p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200530101839.png" alt=""></p>
</li>
<li><p>在Mac 、iOS中，是使用了/usr/lib/dyld程序来加载动态库 </p>
</li>
<li><p>dynamic link editor，动态链接编辑器</p>
</li>
<li><p>dynamic loader，动态加载器</p>
</li>
<li><p>dyld 的源码 <a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/dyld/</a></p>
</li>
</ul>
<ul>
<li>initializeMainExecutable 方法开始的.dyld会优先初始化动态库，然后初始化App的可执行文件。</li>
</ul>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200530101923.png" alt=""></p>
<p>  用MachOView (<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">https://github.com/gdbinit/MachOView</a>)查看加载过程如上图</p>
<p>   备注1: 如果设置了 DYLD_PRINT_LIBRARIES，或者选中run/diagnostics 下面的 dynamic library loads 那么 dyld将会打印出什么库被加载了</p>
<p>​    备注2：DYLD_PRINT_STATISTICS_DETAILS  打印启动时间</p>
<p>​    备注3：dyly还可以抽取苹果原生库   方法： 1： launch-cache/dsc_extractor.cpp文件中 把#if(0) 以及之前的都删除，#endif也删除  2：编译clang++ -o dsc_extractor dsc_extractor.cpp 生成可执行文件 3：./dsc_extractor dyld_shared_cache_armv7s armv7s 进行抽取 ）</p>
<h5 id="2-2-runtime"><a href="#2-2-runtime" class="headerlink" title="2.2 runtime"></a>2.2 runtime</h5><p>​    源码： <a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/</a>   源码分析可参考：<a href="https://www.jianshu.com/p/3019605a4fc9" target="_blank" rel="noopener">https://www.jianshu.com/p/3019605a4fc9</a></p>
<p>​    启动APP时，runtime所做的事情有</p>
<ul>
<li>调用map_images进行可执行文件内容的解析和处理</li>
<li>在load_images中调用call_load_methods，调用所有Class和Category的+load方法  进行各种objc结构的初始化(注册Objc类 、初始化类对象等等)</li>
<li>调用C++静态初始化器和<strong>attribute</strong>((constructor))修饰的函数</li>
<li>到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理</li>
</ul>
<p>关于<code>load</code>和<code>initialize</code> 可参考<a href="https://juejin.im/post/5d204a9af265da1b6e65c431" target="_blank" rel="noopener">iOS中load和initialize</a>一文详细分析</p>
<h5 id="2-3main函数执行后"><a href="#2-3main函数执行后" class="headerlink" title="2.3main函数执行后"></a>2.3main函数执行后</h5><p>​    main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。</p>
<ul>
<li>首屏初始化所需配置文件的读写操作</li>
<li>首屏列表大数据的读取</li>
<li>首屏渲染的大量计算等</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库, 并由runtime负责加载成objc定义的结构,所有初始化工作结束后，dyld就会调用main函数, 接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法</p>
<h5 id="3-App启动优化"><a href="#3-App启动优化" class="headerlink" title="3.App启动优化"></a>3.App启动优化</h5><p>​    按照不同的阶段</p>
<ul>
<li><p>dyld</p>
<ul>
<li>减少动态库、合并一些动态库(定期清理不必要的动态库)。减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，苹果最多支持6个非系统的动态库合并为一个。</li>
<li>减少Objc类、分类的数量、减少Selector数量(定期清理不必要的类、分类) </li>
<li>减少C++虚函数数量， 减少C++全局变量的数量</li>
<li>Swift尽量使用struct</li>
<li>runtime</li>
<li>用+initialize方法和dispatch_once取代所有的<strong>attribute</strong>((constructor))、C++静态构造器、ObjC的+load，因为在一个+load()方法里，运行时进行方法替换操作会带来4毫秒的损耗。</li>
<li>main() 函数执行后</li>
<li>功能级别的优化：main()函数开始执行后到首屏渲染完成前，只处理首屏相关的业务，其他的非首屏业务的初始化，监听注册，配置文件读取放在首屏渲染完成后去做</li>
<li>ReactiveCocoa创建一个信号6毫秒，+load()执行一次，4毫秒</li>
<li>检测App耗时</li>
<li>抓取主线程的方法调用堆栈，计算一段时间各个方法的耗时，Xcode自带的Time Profiler</li>
<li>对objc_msgSend方法进行hook来掌握所有方法的执行耗时 objc_msgSend源码 <code>https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/</code></li>
<li><code>fackbook</code>开源了fishhook的代码<code>https://github.com/facebook/fishhook</code> 其大致思路为：通过重新绑定符号，实现对c方法的<code>hook</code>。<code>dyld</code>是通过更新Mach-O二进制的<code>_DATA segment</code>特定的部分中的指针来绑定lazy和<code>non-lazy</code>符号，通过确认传递给<code>rebind_symbol</code>里每个符号更新的位置，就可以找出替换来重新绑定这些符号。</li>
<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中  按需加载</li>
<li>不使用xib，直接视用代码加载首页视图</li>
<li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)</li>
<li>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</li>
<li>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</li>
</ul>
<h3 id="二、安装包瘦身"><a href="#二、安装包瘦身" class="headerlink" title="二、安装包瘦身"></a>二、安装包瘦身</h3></li>
</ul>
<h4 id="1、安装包-IPA-主要由可执行文件、资源组成"><a href="#1、安装包-IPA-主要由可执行文件、资源组成" class="headerlink" title="1、安装包(IPA)主要由可执行文件、资源组成"></a>1、安装包(IPA)主要由可执行文件、资源组成</h4><ul>
<li>资源(图片、音频、视频等)</li>
<li>采取无损压缩</li>
<li>去除没有用到的资源: <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">https://github.com/tinymind/LSUnusedResources</a></li>
</ul>
<h4 id="2、-可执行文件瘦身"><a href="#2、-可执行文件瘦身" class="headerlink" title="2、 可执行文件瘦身"></a>2、 可执行文件瘦身</h4><h5 id="2-1-编译器优化"><a href="#2-1-编译器优化" class="headerlink" title="2.1 编译器优化"></a>2.1 编译器优化</h5><ul>
<li><p>Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES</p>
</li>
<li><p>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions</p>
</li>
</ul>
<h5 id="2-2利用AppCode"><a href="#2-2利用AppCode" class="headerlink" title="2.2利用AppCode"></a>2.2利用AppCode</h5><p>(<a href="https://www.jetbrains.com/objc/)检测未使用的代码:菜单栏" target="_blank" rel="noopener">https://www.jetbrains.com/objc/)检测未使用的代码:菜单栏</a> -&gt; Code -&gt; Inspect Code </p>
<h5 id="2-3编写LLVM插件检测出重复代码、未被调用的代码"><a href="#2-3编写LLVM插件检测出重复代码、未被调用的代码" class="headerlink" title="2. 3编写LLVM插件检测出重复代码、未被调用的代码"></a>2. 3编写LLVM插件检测出重复代码、未被调用的代码</h5><h5 id="2-4-生成LinkMap文件，可以查看可执行文件的具体组成"><a href="#2-4-生成LinkMap文件，可以查看可执行文件的具体组成" class="headerlink" title="2.4 生成LinkMap文件，可以查看可执行文件的具体组成"></a>2.4 生成LinkMap文件，可以查看可执行文件的具体组成</h5><p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200530101953.png" alt=""></p>
<h5 id="2-5-可借助第三方工具解析LinkMap文件-https-github-com-huanxsd-LinkMap"><a href="#2-5-可借助第三方工具解析LinkMap文件-https-github-com-huanxsd-LinkMap" class="headerlink" title="2.5 可借助第三方工具解析LinkMap文件: https://github.com/huanxsd/LinkMap"></a>2.5 可借助第三方工具解析LinkMap文件: <a href="https://github.com/huanxsd/LinkMap" target="_blank" rel="noopener">https://github.com/huanxsd/LinkMap</a></h5><h3 id="三、卡顿问题"><a href="#三、卡顿问题" class="headerlink" title="三、卡顿问题"></a>三、卡顿问题</h3><h4 id="3-1、CPU-和GPU"><a href="#3-1、CPU-和GPU" class="headerlink" title="3.1、CPU 和GPU"></a>3.1、CPU 和GPU</h4><ul>
<li><p>CPU (Central Processing Unit，中央处理器)</p>
<p>对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制(Core Graphics)</p>
</li>
<li><p>GPU (Graphics Processing Unit，图形处理器)</p>
<p>纹理的渲染</p>
</li>
<li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存</p>
</li>
</ul>
<h4 id="3-2优化方向"><a href="#3-2优化方向" class="headerlink" title="3.2优化方向"></a>3.2优化方向</h4><ul>
<li>尽可能减少CPU、GPU资源消耗 </li>
<li>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView</li>
<li>不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改 </li>
<li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>
<li>Autolayout会比直接设置frame消耗更多的CPU资源</li>
<li>图片的size最好刚好跟UIImageView的size保持一致</li>
<li>控制一下线程的最大并发数量</li>
<li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>
<li>GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li>
<li>尽量减少视图数量和层次</li>
<li>减少透明的视图(alpha&lt;1)，不透明的就设置opaque为YES </li>
<li>尽量把耗时的操作放到子线程 <ul>
<li>文本处理(尺寸计算、绘制) p</li>
<li>图片处理(解码、绘制)</li>
</ul>
</li>
</ul>
<h4 id="3-3、离屏渲染"><a href="#3-3、离屏渲染" class="headerlink" title="3.3、离屏渲染"></a>3.3、离屏渲染</h4><ul>
<li>尽量避免出现离屏渲染</li>
<li>在OpenGL中，GPU有2种渲染方式<ul>
<li>On-Screen Rendering:当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li>
<li>Off-Screen Rendering:离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
</ul>
</li>
<li>离屏渲染消耗性能的原因<ul>
<li>需要创建新的缓冲区</li>
<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕(On-Screen)切换到离屏(Off-Screen);等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 </li>
</ul>
</li>
<li>哪些操作会触发离屏渲染?<ul>
<li>光栅化，layer.shouldRasterize = YES </li>
<li>遮罩，layer.mask</li>
<li>圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0（考虑通过CoreGraphics绘制裁剪圆角，或者叫UI提供圆角图片）</li>
<li>阴影，layer.shadowXXX   (如果设置了layer.shadowPath就不会产生离屏渲染)</li>
</ul>
</li>
</ul>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><h4 id="一、查找泄漏点-两种工具"><a href="#一、查找泄漏点-两种工具" class="headerlink" title="一、查找泄漏点 (两种工具)"></a>一、查找泄漏点 (两种工具)</h4><p>​    </p>
<ul>
<li><p><strong>1 &gt; Analyze</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- 学 名:  静态分析工具- 查 找:  可以通过 Product -&gt;Analyze 菜单项启动- 快捷键:  CMD+shift +b.- Analyze主要分析以下四种问题:</span><br><span class="line">  <span class="number">1</span>) 逻辑错误：访问空指针或未初始化的变量等；</span><br><span class="line">  <span class="number">2</span>) 内存管理错误：如内存泄漏等；</span><br><span class="line">  <span class="number">3</span>) 声明错误：从未使用过的变量；</span><br><span class="line">  <span class="number">4</span>) Api调用错误：未包含使用的库和框架。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2 &gt;Instruments</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">- 学 名:   动态分析工具- 查 找:   Product -&gt;Profile 菜单项启动- 快捷键:  <span class="keyword">CMD</span><span class="bash"> + i.</span></span><br><span class="line">简 介:它有很多跟踪模块可以动态分析和跟踪内存, CPU 和文件系统.</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="四、耗电优化"><a href="#四、耗电优化" class="headerlink" title="四、耗电优化"></a>四、耗电优化</h3><ul>
<li><p>尽可能降低CPU、GPU功耗</p>
</li>
<li><p>少用定时器</p>
</li>
<li><p>优化I/O操作</p>
<ul>
<li>尽量不要频繁写入小数据，最好批量一次性写入</li>
<li>读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问</li>
<li>数据量比较大的，建议使用数据库(比如SQLite、CoreData)</li>
</ul>
</li>
<li><p>网络优化</p>
<ul>
<li>减少、压缩网络数据</li>
<li>如果多次请求的结果是相同的，尽量使用缓存</li>
<li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>
<li>网络不可用时，不要尝试执行网络请求</li>
<li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li>
<li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一 次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载</li>
</ul>
</li>
<li><p>定位优化</p>
<ul>
<li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电</li>
<li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li>
<li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li>
<li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li>
<li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion:</li>
</ul>
</li>
</ul>
<ul>
<li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
</ul>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p>iOS启动优化博客：<a href="http://www.zoomfeng.com/blog/launch-time.html" target="_blank" rel="noopener">http://www.zoomfeng.com/blog/launch-time.html</a></p>
<p>dyld源码： <a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/dyld/</a>        </p>
<p>dyld简介和分析：<a href="https://www.jianshu.com/p/be413358cd45" target="_blank" rel="noopener">https://www.jianshu.com/p/be413358cd45</a></p>
<p>runtime源码：<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/</a></p>
<p>runtime源码分析：<a href="https://www.jianshu.com/p/3019605a4fc9" target="_blank" rel="noopener">https://www.jianshu.com/p/3019605a4fc9</a></p>
<p>objc_msgSend源码： <a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/</a></p>
<p>开源项目fishhook: <a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">https://github.com/facebook/fishhook</a> </p>
<p>开源项目LSUR: <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">https://github.com/tinymind/LSUnusedResources</a></p>
<p>AppCode官网：<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">https://www.jetbrains.com/objc/</a></p>
<p>开源项目LinkMap: <a href="https://github.com/huanxsd/LinkMap" target="_blank" rel="noopener">https://github.com/huanxsd/LinkMap</a></p>
<p>GNUstep源码 <a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">http://www.gnustep.org/resources/downloads.php</a></p>
<p>MachOView源码：<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">https://github.com/gdbinit/MachOView</a></p>
<p>今日头条iOS客户端启动速度优化：<a href="https://techblog.toutiao.com/2017/01/17/iosspeed/#more" target="_blank" rel="noopener">https://techblog.toutiao.com/2017/01/17/iosspeed/#more</a></p>
<p>iOS 性能优化<a href="https://github.com/skyming/iOS-Performance-Optimization" target="_blank" rel="noopener">https://github.com/skyming/iOS-Performance-Optimization</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>详解autoreleasepool</title>
    <url>/%E8%AF%A6%E8%A7%A3autoreleasepool.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3autoreleasepool.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章开始之前，先想想下面三种场景，分别输出什么呢？</p>
<p><strong>注意<code>str</code>的长度不能太短</strong></p>
<p><strong>注意<code>str</code>的长度不能太短</strong></p>
<p><strong>注意<code>str</code>的长度不能太短</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSString</span> *string_weak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景一</span></span><br><span class="line"><span class="comment">//    NSString *str =  [NSString stringWithFormat:@"https://ityongzhen.github.io/"];</span></span><br><span class="line"><span class="comment">//    string_weak = str;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景二</span></span><br><span class="line"><span class="comment">//    @autoreleasepool &#123;</span></span><br><span class="line"><span class="comment">//        NSString *str =  [NSString stringWithFormat:@"https://ityongzhen.github.io/"];</span></span><br><span class="line"><span class="comment">//        string_weak = str;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 场景三</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        str =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"https://ityongzhen.github.io/"</span>];</span><br><span class="line">        string_weak = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个问题，暂时先放下，继续往下看。</p>
<h2 id="autoreleasepool生成c-文件"><a href="#autoreleasepool生成c-文件" class="headerlink" title="autoreleasepool生成c++文件"></a><code>autoreleasepool</code>生成c++文件</h2><p>有如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">     <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp</code>生成c++文件，其对应的代码如下所示。</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">&#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        NSObject *obj = ((<span class="name">NSObject</span> *(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))(<span class="name">void</span> *)objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)((<span class="name">NSObject</span> *(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))(<span class="name">void</span> *)objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简化一下也就是</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">  NSObject *obj = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>__AtAutoreleasePool</code>是什么呢？这是一个结构体，其内容如下，包含一个构造函数，在创建结构体的时候调用。一个析构函数，在结构体销毁的时候调用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">	<span class="comment">//构造函数，在创建结构体的时候调用</span></span><br><span class="line">  <span class="constructor">__AtAutoreleasePool()</span> &#123;</span><br><span class="line">  		atautoreleasepoolobj = objc<span class="constructor">_autoreleasePoolPush()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//析构函数，在结构体销毁的时候调用</span></span><br><span class="line">  ~<span class="constructor">__AtAutoreleasePool()</span>&#123;</span><br><span class="line"> 	 objc<span class="constructor">_autoreleasePoolPop(<span class="params">atautoreleasepoolobj</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void<span class="operator"> * </span>atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，放在一起就是在开始的时候调用 <code>objc_autoreleasePoolPush()</code>结束时候调用<code>objc_autoreleasePoolPop(atautoreleasepoolobj)</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">	<span class="comment">//构造函数，在创建结构体的时候调用</span></span><br><span class="line">  <span class="constructor">__AtAutoreleasePool()</span> &#123;</span><br><span class="line">  		atautoreleasepoolobj = objc<span class="constructor">_autoreleasePoolPush()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  	<span class="comment">// 写在autoreleasepool内的代码</span></span><br><span class="line">    NSObject *obj = <span class="literal">[[NSO<span class="identifier">bject</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//析构函数，在结构体销毁的时候调用</span></span><br><span class="line">  ~<span class="constructor">__AtAutoreleasePool()</span>&#123;</span><br><span class="line"> 	 objc<span class="constructor">_autoreleasePoolPop(<span class="params">atautoreleasepoolobj</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void<span class="operator"> * </span>atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a><code>AutoreleasePoolPage</code></h3><p>具体源码可以再<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a>中查看，从源码可以看到<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这两个函数都是操作<code>AutoreleasePoolPage</code>来实现的。</p>
<p>类<code>AutoreleasePoolPage</code>中代码较多，筛选出主要代码如下</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</span><br><span class="line">    id *next;</span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;</span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line">    </span><br><span class="line">    <span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lessThanHalfFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (next - <span class="built_in">begin</span>() &lt; (<span class="built_in">end</span>() - <span class="built_in">begin</span>()) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出</p>
<p>AutoreleasePoolPage对象通过双向链表的形式连接在一起</p>
<p>其中</p>
<ul>
<li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；</li>
<li>thread 指向当前线程；说明了，AutoreleasePoolPage和线程一一对应的。</li>
<li>parent 指向父结点</li>
<li>child 指向子结点</li>
<li>depth 代表深度，从 0 开始，往后递增 1；</li>
<li>hiwat 代表 high water mark 。</li>
</ul>
<h3 id="每个AutoreleasePoolPage对象占用4096字节"><a href="#每个AutoreleasePoolPage对象占用4096字节" class="headerlink" title="每个AutoreleasePoolPage对象占用4096字节"></a>每个AutoreleasePoolPage对象占用4096字节</h3><ul>
<li>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I386_PGBYTES            4096            <span class="comment">/* bytes per 80386 page */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE               I386_PGBYTES</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = PAGE_MAX_SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  id * <span class="built_in">begin</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+SIZE);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中可以看出来</p>
<ul>
<li>每个<code>AutoreleasePoolPage</code>有是4096字节,</li>
<li>以及<code>begin</code>指向的是开始存放<code>autorelease对象</code>的地方，</li>
<li><code>end指向结尾的位置</code></li>
</ul>
<h2 id="AutoreleasePoolPage存不下了怎么办？"><a href="#AutoreleasePoolPage存不下了怎么办？" class="headerlink" title="AutoreleasePoolPage存不下了怎么办？"></a>AutoreleasePoolPage存不下了怎么办？</h2><p>如果一个<code>AutoreleasePoolPage</code>存不下了，就会再创建一个<code>AutoreleasePoolPage对象</code>，第一个<code>AutoreleasePoolPage对象</code>的<code>child</code>指向第二个<code>AutoreleasePoolPage对象</code>，第二个<code>AutoreleasePoolPage对象</code>的<code>parent</code>指向第一个<code>AutoreleasePoolPage对象</code>。图形表示就是如下</p>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200602144008.png" alt=""></p>
<h2 id="push、pop、autorelease"><a href="#push、pop、autorelease" class="headerlink" title="push、pop、autorelease"></a><code>push</code>、<code>pop</code>、<code>autorelease</code></h2><p><code>AutoreleasePoolPage</code>里面有<code>push</code>和<code>pop</code>函数</p>
<ul>
<li><p>调用<code>push</code>方法会将一个<code>POOL_BOUNDARY</code>入栈，并且返回其存放的内存地址</p>
</li>
<li><p>调用<code>pop</code>方法时传入一个<code>POOL_BOUNDARY</code>的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个<code>POOL_BOUNDARY</code></p>
</li>
<li><p><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域  </p>
</li>
</ul>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      id *dest;</span><br><span class="line">      <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">          <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">          dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">      &#125;</span><br><span class="line">      assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">      <span class="keyword">return</span> dest;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">static inline id <span class="comment">*autoreleaseFast(id obj)</span></span><br><span class="line"><span class="comment">   &#123;</span></span><br><span class="line"><span class="comment">       AutoreleasePoolPage *page = hotPage();</span></span><br><span class="line">       <span class="meta">if</span> (<span class="meta">page</span> <span class="variable">&amp;&amp;</span> !<span class="meta">page</span>-&gt;full()) &#123;//<span class="meta">page</span>没有满，就把obj对象加到<span class="meta">page</span></span><br><span class="line">           <span class="meta">return</span> <span class="meta">page</span>-&gt;<span class="meta">add</span>(obj);</span><br><span class="line">       &#125; <span class="meta">else</span> <span class="meta">if</span> (<span class="meta">page</span>) &#123;//<span class="meta">page</span>满了 创建新的<span class="meta">page</span></span><br><span class="line">           <span class="meta">return</span> autoreleaseFullPage(obj, <span class="meta">page</span>);</span><br><span class="line">       &#125; <span class="meta">else</span> &#123;</span><br><span class="line">           <span class="meta">return</span> autoreleaseNoPage(obj);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a><code>pop</code></h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static inline void pop(void *token) </span><br><span class="line">  &#123;</span><br><span class="line">      AutoreleasePoolPage *<span class="built_in">page</span>;</span><br><span class="line">      id *stop;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">          <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">          <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">              <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">              <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">              <span class="function"><span class="title">pop</span>(coldPage()-&gt;</span>begin());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">              setHotPage(<span class="literal">nil</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">page</span> = pageForPointer(token);</span><br><span class="line">      stop = (id *)token;</span><br><span class="line">      <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">          <span class="function"><span class="title">if</span> (stop == <span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">begin</span>()  &amp;&amp;  !<span class="built_in">page</span>-&gt;</span>parent) &#123;</span><br><span class="line">              <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">              <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">              <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">              <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">              return badPop(token);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">page</span>-&gt;</span>releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// memory: delete empty children</span></span><br><span class="line">      <span class="function"><span class="title">if</span> (DebugPoolAllocation  &amp;&amp;  <span class="built_in">page</span>-&gt;</span>empty()) &#123;</span><br><span class="line">          <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">          A<span class="function"><span class="title">utoreleasePoolPage</span> *parent = <span class="built_in">page</span>-&gt;</span>parent;</span><br><span class="line">          <span class="function"><span class="title">page</span>-&gt;</span>kill();</span><br><span class="line">          setHotPage(parent);</span><br><span class="line">      &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  <span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">empty</span>()  &amp;&amp;  !<span class="built_in">page</span>-&gt;</span>parent) &#123;</span><br><span class="line">          <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">          <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">          <span class="function"><span class="title">page</span>-&gt;</span>kill();</span><br><span class="line">          setHotPage(<span class="literal">nil</span>);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span>child) &#123;</span><br><span class="line">          <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">          <span class="function"><span class="title">if</span> (<span class="built_in">page</span>-&gt;</span>lessThanHalfFull()) &#123;</span><br><span class="line">              <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>child) &#123;</span><br><span class="line">              <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a><code>autorelease</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 调用rootAutorelease</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) <span class="keyword">return</span> rootAutorelease();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_autorelease);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rootAutorelease</code>调用<code>rootAutorelease2</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rootAutorelease2</code>调用<code>autorelease</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">__attribute__((<span class="params">noinline</span>,<span class="params">used</span>)</span>)</span><br><span class="line">id </span><br><span class="line">objc_object::root<span class="constructor">Autorelease2()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span>(!is<span class="constructor">TaggedPointer()</span>);</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>autorelease</code></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span>(obj);</span><br><span class="line">    <span class="keyword">assert</span>(!obj-&gt;isTaggedPointer());</span><br><span class="line">    <span class="comment">//再次调用autoreleaseFast</span></span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    <span class="keyword">assert</span>(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="POOL-BOUNDARY"><a href="#POOL-BOUNDARY" class="headerlink" title="POOL_BOUNDARY"></a><code>POOL_BOUNDARY</code></h2><p>上面的源码可以发现<code>POOL_BOUNDARY</code>是个很重要的角色，相当于一个哨兵，</p>
<ul>
<li>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的<code>AutoreleasePoolPage</code>中add进一个哨兵对象(POOL_BOUNDARY)，值为0（也就是个nil）</li>
<li><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop</code>(哨兵对象)作为入参，于是<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息，并向回移动next指针到正确位置</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</li>
</ul>
</li>
</ul>
<h2 id="autoreleasepool的嵌套"><a href="#autoreleasepool的嵌套" class="headerlink" title="@autoreleasepool的嵌套"></a><code>@autoreleasepool</code>的嵌套</h2><p>如果多个<code>@autoreleasepool</code>嵌套会怎么样呢？</p>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>源码中有如下代码</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">void </span><br><span class="line">_objc_autoreleasePoolPrint(void)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::printAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> static void printAll()</span><br><span class="line">    &#123;        </span><br><span class="line">        _objc_inform(<span class="string">"##############"</span>);</span><br><span class="line">        _objc_inform(<span class="string">"AUTORELEASE POOLS for thread %p"</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">        AutoreleasePoolPage *page;</span><br><span class="line">        ptrdiff_t objects = 0;</span><br><span class="line">        <span class="keyword">for</span> (page = coldPage();<span class="built_in"> page; page </span>= page-&gt;child) &#123;</span><br><span class="line">            objects += page-&gt;next - page-&gt;begin();</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">"%llu releases pending."</span>, (unsigned long long)objects);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"[%p]  ................  PAGE (placeholder)"</span>, </span><br><span class="line">                         EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">            _objc_inform(<span class="string">"[%p]  ################  POOL (placeholder)"</span>, </span><br><span class="line">                         EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (page = coldPage();<span class="built_in"> page; page </span>= page-&gt;child) &#123;</span><br><span class="line">                page-&gt;<span class="builtin-name">print</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _objc_inform(<span class="string">"##############"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说<code>_objc_autoreleasePoolPrint</code>函数可以用来打印一些日志</p>
<h3 id="一层-autoreleasepool"><a href="#一层-autoreleasepool" class="headerlink" title="一层@autoreleasepool"></a>一层<code>@autoreleasepool</code></h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_autoreleasePoolPrint(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出如下，只有一个哨兵对象(POOL)</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">32644</span>]: ##############</span><br><span class="line">objc[<span class="number">32644</span>]: AUTORELEASE POOLS for thread <span class="number">0x11b111d40</span></span><br><span class="line">objc[<span class="number">32644</span>]: <span class="number">3</span> releases pending.</span><br><span class="line">objc[<span class="number">32644</span>]: [<span class="number">0x7fcabf802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">32644</span>]: [<span class="number">0x7fcabf802038</span>]    <span class="number">0x600003f70500</span>  __NSArrayI</span><br><span class="line">objc[<span class="number">32644</span>]: [<span class="number">0x7fcabf802040</span>]    <span class="number">0x600000950f00</span>  __NSSetI</span><br><span class="line">objc[<span class="number">32644</span>]: [<span class="number">0x7fcabf802048</span>]  ################  POOL <span class="number">0x7fcabf802048</span></span><br><span class="line">objc[<span class="number">32644</span>]: ##############</span><br></pre></td></tr></table></figure>


<h3 id="三层-autoreleasepool"><a href="#三层-autoreleasepool" class="headerlink" title="三层@autoreleasepool"></a>三层<code>@autoreleasepool</code></h3><p>如果有三个<code>@autoreleasepool</code>呢？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_autoreleasePoolPrint(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                 _objc_autoreleasePoolPrint();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下，有三个<code>POOL</code>，说明有三个哨兵。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">32735</span>]: ##############</span><br><span class="line">objc[<span class="number">32735</span>]: AUTORELEASE POOLS for thread <span class="number">0x114f02d40</span></span><br><span class="line">objc[<span class="number">32735</span>]: <span class="number">5</span> releases pending.</span><br><span class="line">objc[<span class="number">32735</span>]: [<span class="number">0x7f91fd005000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">32735</span>]: [<span class="number">0x7f91fd005038</span>]    <span class="number">0x600001bbd380</span>  __NSArrayI</span><br><span class="line">objc[<span class="number">32735</span>]: [<span class="number">0x7f91fd005040</span>]    <span class="number">0x600002da4eb0</span>  __NSSetI</span><br><span class="line">objc[<span class="number">32735</span>]: [<span class="number">0x7f91fd005048</span>]  ################  POOL <span class="number">0x7f91fd005048</span></span><br><span class="line">objc[<span class="number">32735</span>]: [<span class="number">0x7f91fd005050</span>]  ################  POOL <span class="number">0x7f91fd005050</span></span><br><span class="line">objc[<span class="number">32735</span>]: [<span class="number">0x7f91fd005058</span>]  ################  POOL <span class="number">0x7f91fd005058</span></span><br><span class="line">objc[<span class="number">32735</span>]: ##############</span><br></pre></td></tr></table></figure>

<h3 id="销毁一个-autoreleasepool"><a href="#销毁一个-autoreleasepool" class="headerlink" title="销毁一个@autoreleasepool"></a>销毁一个<code>@autoreleasepool</code></h3><p>如果上面代码中最里面的<code>@autoreleasepool</code>退出之后再打印呢？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_autoreleasePoolPrint(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印的时候，最里面的@autoreleasepool已经退出了</span></span><br><span class="line">             _objc_autoreleasePoolPrint();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为如下，只有两个哨兵(POOL)</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">objc[<span class="number">32812</span>]: ##############</span><br><span class="line">objc[<span class="number">32812</span>]: AUTORELEASE POOLS for thread <span class="number">0x1142b1d40</span></span><br><span class="line">objc[<span class="number">32812</span>]: <span class="number">4</span> releases pending.</span><br><span class="line">objc[<span class="number">32812</span>]: [<span class="number">0x7fe86e800000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">32812</span>]: [<span class="number">0x7fe86e800038</span>]    <span class="number">0x600003edb0c0</span>  __NSArrayI</span><br><span class="line">objc[<span class="number">32812</span>]: [<span class="number">0x7fe86e800040</span>]    <span class="number">0x6000008dd680</span>  __NSSetI</span><br><span class="line">objc[<span class="number">32812</span>]: [<span class="number">0x7fe86e800048</span>]  ################  POOL <span class="number">0x7fe86e800048</span></span><br><span class="line">objc[<span class="number">32812</span>]: [<span class="number">0x7fe86e800050</span>]  ################  POOL <span class="number">0x7fe86e800050</span></span><br><span class="line">objc[<span class="number">32812</span>]: ##############</span><br></pre></td></tr></table></figure>

<p>进一步说明了，</p>
<ul>
<li><p>调用push方法会将一个<code>POOL_BOUNDARY</code>入栈，并且返回其存放的内存地址</p>
</li>
<li><p>调用pop方法时传入一个<code>POOL_BOUNDARY</code>的内存地址，会从最后一个入栈的对象开始发送<code>release</code>消息，直到遇到这个<code>POOL_BOUNDARY</code></p>
</li>
</ul>
<h2 id="开头的问题"><a href="#开头的问题" class="headerlink" title="开头的问题"></a>开头的问题</h2><p>现在我们回过头看文章开头的问题，应该很好回答了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSString</span> *string_weak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景一</span></span><br><span class="line"><span class="comment">//    NSString *str =  [NSString stringWithFormat:@"https://ityongzhen.github.io/"];</span></span><br><span class="line"><span class="comment">//    string_weak = str;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景二</span></span><br><span class="line"><span class="comment">//    @autoreleasepool &#123;</span></span><br><span class="line"><span class="comment">//        NSString *str =  [NSString stringWithFormat:@"https://ityongzhen.github.io/"];</span></span><br><span class="line"><span class="comment">//        string_weak = str;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 场景三</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        str =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"https://ityongzhen.github.io/"</span>];</span><br><span class="line">        string_weak = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="输出结果如下："><a href="#输出结果如下：" class="headerlink" title="输出结果如下："></a>输出结果如下：</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line">iOS定时器[<span class="number">24714</span>:<span class="number">332118</span>] <span class="built_in">string</span>: https:<span class="comment">//ityongzhen.github.io/ -[ViewController viewDidLoad]</span></span><br><span class="line">iOS定时器[<span class="number">24714</span>:<span class="number">332118</span>] <span class="built_in">string</span>: https:<span class="comment">//ityongzhen.github.io/ -[ViewController viewWillAppear:]</span></span><br><span class="line">iOS定时器[<span class="number">24714</span>:<span class="number">332118</span>] <span class="built_in">string</span>: (<span class="literal">null</span>) -[ViewController viewDidAppear:]</span><br><span class="line"></span><br><span class="line">场景二</span><br><span class="line">iOS定时器[<span class="number">24676</span>:<span class="number">331168</span>] <span class="built_in">string</span>: (<span class="literal">null</span>) -[ViewController viewDidLoad]</span><br><span class="line">iOS定时器[<span class="number">24676</span>:<span class="number">331168</span>] <span class="built_in">string</span>: (<span class="literal">null</span>) -[ViewController viewWillAppear:]</span><br><span class="line">iOS定时器[<span class="number">24676</span>:<span class="number">331168</span>] <span class="built_in">string</span>: (<span class="literal">null</span>) -[ViewController viewDidAppear:]</span><br><span class="line"></span><br><span class="line">场景三</span><br><span class="line">iOS定时器[<span class="number">24505</span>:<span class="number">328544</span>] <span class="built_in">string</span>: https:<span class="comment">//ityongzhen.github.io/ -[ViewController viewDidLoad]</span></span><br><span class="line">iOS定时器[<span class="number">24505</span>:<span class="number">328544</span>] <span class="built_in">string</span>: (<span class="literal">null</span>) -[ViewController viewWillAppear:]</span><br><span class="line">iOS定时器[<span class="number">24505</span>:<span class="number">328544</span>] <span class="built_in">string</span>: (<span class="literal">null</span>) -[ViewController viewDidAppear:]</span><br></pre></td></tr></table></figure>

<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>  当使用 <code>[NSString stringWithFormat:@&quot;https://ityongzhen.github.io/&quot;]</code> 创建一个对象时，这个对象的引用计数为 1 ，并且这个对象被系统自动添加到了当前的 autoreleasepool 中。当使用局部变量 str 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。因为在 ARC 下 <code>NSString *str</code>本质上就是 <code>__strong NSString *str</code> 。所以在 <code>viewDidLoad</code> 方法返回前，这个对象是一直存在的，且引用计数为 2 。而当<code>viewDidLoad</code> 方法返回时，局部变量 <code>str</code> 被回收，指向了 nil 。因此，其所指向对象的引用计数 -1 ，变成了 1 。</p>
<p>而在 <code>viewWillAppear</code> 方法中，我们仍然可以打印出这个对象的值，在<code>viewDidAppear</code>方法中，这个值为空，这个就要牵扯到RunLoop的知识了。<a href="https://juejin.im/post/5d04c88d5188255e1305ca09" target="_blank" rel="noopener">详解RunLoop之源码分析</a>一文讲述了RunLoop的底层，这里说一下，我们的iOS处理事件是以RunLoop一直循环执行的。<code>viewDidLoad</code>和<code>viewWillAppear</code>在同一个RunLoop循环中，所以在 <code>viewWillAppear</code> 方法中，我们仍然可以打印出这个对象的值，但是<code>viewDidLoad</code>的时候，那个RunLoop循环已经执行完了，这个对象才被彻底的释放。</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>当通过 <code>[NSString stringWithFormat:@&quot;https://ityongzhen.github.io/&quot;]</code> 创建一个对象时，这个对象的引用计数为 1 。而当使用局部变量 str 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。而出了当前作用域时，局部变量 str 变成了 nil ，所以其所指向对象的引用计数变成 1 。另外，我们知道当出了 <code>@autoreleasepool {}</code>的作用域时，当前 <code>autoreleasepool</code> 被 drain ，其中的 autoreleased 对象被 release 。所以这个对象的引用计数变成了 0 ，对象最终被释放</p>
<h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>当出了 <code>@autoreleasepool {}</code> 的作用域时，其中的 <code>autoreleased</code> 对象被 release ，对象的引用计数变成 1 。当出了局部变量 str 的作用域，即 <code>viewDidLoad</code> 方法返回时，str 指向了 nil ，其所指向对象的引用计数变成 0 ，对象最终被释放</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>前面说了<strong>注意<code>str</code>的长度不能太短</strong>是为什么呢？</p>
<p>是因为如果<code>str</code>过短。例如</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSString</span> *string_weak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景一</span></span><br><span class="line"><span class="comment">//    NSString *str =  [NSString stringWithFormat:@"abc"];</span></span><br><span class="line"><span class="comment">//    string_weak = str;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景二</span></span><br><span class="line"><span class="comment">//    @autoreleasepool &#123;</span></span><br><span class="line"><span class="comment">//        NSString *str =  [NSString stringWithFormat:@"abc"];</span></span><br><span class="line"><span class="comment">//        string_weak = str;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // 场景三</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        str =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line">        string_weak = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string: %@ %s"</span>, string_weak,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line">iOS定时器[<span class="number">24714</span>:<span class="number">332118</span>] <span class="built_in">string</span>: abc -[ViewController viewDidLoad]</span><br><span class="line">iOS定时器[<span class="number">24714</span>:<span class="number">332118</span>] <span class="built_in">string</span>: abc -[ViewController viewWillAppear:]</span><br><span class="line">iOS定时器[<span class="number">24714</span>:<span class="number">332118</span>] <span class="built_in">string</span>: abc -[ViewController viewDidAppear:]</span><br><span class="line"></span><br><span class="line">场景二</span><br><span class="line">iOS定时器[<span class="number">24676</span>:<span class="number">331168</span>] <span class="built_in">string</span>: abc -[ViewController viewDidLoad]</span><br><span class="line">iOS定时器[<span class="number">24676</span>:<span class="number">331168</span>] <span class="built_in">string</span>: abc -[ViewController viewWillAppear:]</span><br><span class="line">iOS定时器[<span class="number">24676</span>:<span class="number">331168</span>] <span class="built_in">string</span>: abc -[ViewController viewDidAppear:]</span><br><span class="line"></span><br><span class="line">场景三</span><br><span class="line">iOS定时器[<span class="number">24505</span>:<span class="number">328544</span>] <span class="built_in">string</span>: abc -[ViewController viewDidLoad]</span><br><span class="line">iOS定时器[<span class="number">24505</span>:<span class="number">328544</span>] <span class="built_in">string</span>: abc -[ViewController viewWillAppear:]</span><br><span class="line">iOS定时器[<span class="number">24505</span>:<span class="number">328544</span>] <span class="built_in">string</span>: abc -[ViewController viewDidAppear:]</span><br></pre></td></tr></table></figure>

<p>这是因为，字符串的<code>abc</code>采用的是Tagged Pointer技术，不是一个标准的OC对象。不存在说再堆上开辟空间存储对象什么的。关于Tagged Pointer可以参考这篇文章<a href="https://juejin.im/post/5d5a47f051882521610014a4" target="_blank" rel="noopener">iOS中的引用计数</a>,这里不做赘述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></p>
</li>
<li><p>调用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管理的</p>
</li>
<li><p>每个<code>AutoreleasePoolPage</code>对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放<code>autorelease</code>对象的地址</p>
</li>
<li><p>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</p>
</li>
<li><p>调用<code>push</code>方法会将一个<code>POOL_BOUNDARY</code>入栈，并且返回其存放的内存地址</p>
</li>
<li><p>调用<code>pop</code>方法时传入一个<code>POOL_BOUNDARY</code>的内存地址，会从最后一个入栈的对象开始发送<code>release</code>消息，直到遇到这个<code>POOL_BOUNDARY</code></p>
</li>
<li><p><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域 </p>
</li>
<li><p>iOS在主线程的<code>Runloop</code>中注册了2个<code>Observer</code></p>
<ul>
<li>第1个<code>Observer</code>监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>
<li>第2个<code>Observer</code><ul>
<li>监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li>
<li>监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>在当次RunLoop将要结束的时候，调用<code>objc_autoreleasePoolPop()</code></p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a></p>
<p><a href="https://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="noopener">Objective-C Autorelease Pool 的实现原理</a></p>
<p><a href="https://juejin.im/post/5d04c88d5188255e1305ca09" target="_blank" rel="noopener">详解RunLoop之源码分析</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
<p><a href="https://juejin.im/post/5d5a47f051882521610014a4" target="_blank" rel="noopener">iOS中的引用计数</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>从iOS中的引用计数说起</title>
    <url>/%E4%BB%8EiOS%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E8%AF%B4%E8%B5%B7.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/iOS中的引用计数.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>维基百科中这么定义<a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="noopener">引用计数</a></p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法。</p>
</blockquote>
<blockquote>
<p>当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。</p>
</blockquote>
<h2 id="在iOS中，使用引用计数来管理OC对象的内存"><a href="#在iOS中，使用引用计数来管理OC对象的内存" class="headerlink" title="在iOS中，使用引用计数来管理OC对象的内存"></a>在iOS中，使用引用计数来管理OC对象的内存</h2><ul>
<li><p>一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</p>
</li>
<li><p>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</p>
</li>
<li><p>内存管理的经验总结</p>
<ul>
<li>当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它</li>
<li>想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1</li>
</ul>
</li>
<li><p>可以通过以下私有函数来查看自动释放池的情况</p>
<ul>
<li><code>extern void _objc_autoreleasePoolPrint(void)</code>;</li>
</ul>
</li>
</ul>
<h2 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h2><p>在<a href="https://juejin.im/post/5d3be844f265da1bcd381fe3" target="_blank" rel="noopener">详解iOS中的Runtime</a>一文中，对isa进行了详解。</p>
<p>这里进行简单概述</p>
<p>从arm64架构开始，苹果对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">define ISA_BITFIELD                                                      \</span><br><span class="line">     <span class="built_in">uint</span>ptr_t nonpointer        : <span class="number">1</span>;   <span class="comment">//指针是否优化过                                   \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t has_assoc         : <span class="number">1</span>;   <span class="comment">//是否有设置过关联对象，如果没有，释放时会更快                                   \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t has_cxx_dtor      : <span class="number">1</span>; 	 <span class="comment">//是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快                                     \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t shiftcls          : <span class="number">33</span>; <span class="comment">//存储着Class、Meta-Class对象的内存地址信息 \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t magic             : <span class="number">6</span>;  <span class="comment">//用于在调试时分辨对象是否未完成初始化                                     \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">//是否有被弱引用指向过，如果没有，释放时会更快                                     \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t deallocating      : <span class="number">1</span>;  <span class="comment">//对象是否正在释放                                     \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">//引用计数器是否过大无法存储在isa中                                     \</span></span><br><span class="line">     <span class="built_in">uint</span>ptr_t extra_rc          : <span class="number">19</span> <span class="comment">//里面存储的值是引用计数器减1</span></span><br></pre></td></tr></table></figure>

<h3 id="isa中不同的位域代表不同的含义。"><a href="#isa中不同的位域代表不同的含义。" class="headerlink" title="isa中不同的位域代表不同的含义。"></a>isa中不同的位域代表不同的含义。</h3><ul>
<li><p>nonpointer</p>
<ul>
<li>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1，代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li><p>has_assoc</p>
<ul>
<li>是否有设置过关联对象，如果没有，释放时会更快</li>
</ul>
</li>
<li><p>has_cxx_dtor</p>
<ul>
<li>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</li>
</ul>
</li>
<li><p>shiftcls</p>
<ul>
<li>存储着Class、Meta-Class对象的内存地址信息</li>
</ul>
</li>
<li><p>magic</p>
<ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li><p>weakly_referenced</p>
<ul>
<li>是否有被弱引用指向过，如果没有，释放时会更快</li>
</ul>
</li>
<li><p>deallocating</p>
<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li><p>extra_rc</p>
<ul>
<li>里面存储的值是引用计数器减1</li>
</ul>
</li>
<li><p>has_sidetable_rc</p>
<ul>
<li>引用计数器是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li>
</ul>
</li>
</ul>
<h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>再开始之前，先看这个代码</p>
<blockquote>
<p>NSNumber *num = @(20);</p>
</blockquote>
<p>我们只有一个需要存储20这个数据，按照正常的技术方案，在64位CPU下，应该先去创建NSNumber对象，其值是20，然后再有个指向该地址的指针<code>num</code>。这样做存在什么问题呢？</p>
<ul>
<li><p>内存浪费</p>
<ul>
<li>由于OC中的内存对齐，在64位下，创建一个对象至少16字节，再加上一个指针8个字节，总共24字节，也就是说，为了存储这个20而需要24字节，对内存方面是极大的浪费。</li>
</ul>
</li>
<li><p>性能浪费</p>
<ul>
<li>为了存储和访问一个 NSNumber 对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失</li>
</ul>
</li>
</ul>
<h3 id="Tagged-Pointer技术"><a href="#Tagged-Pointer技术" class="headerlink" title="Tagged Pointer技术"></a>Tagged Pointer技术</h3><p>为了解决这个问题，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p>
<ul>
<li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储</p>
</li>
<li><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值</p>
</li>
<li><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中</p>
</li>
<li><p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</p>
</li>
<li><p><code>objc_msgSend</code>能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销</p>
</li>
<li><p>如何判断一个指针是否为Tagged Pointer？</p>
<ul>
<li>最低有效位是1 (objc4-750之后)</li>
<li>之前的版本(objc4-723以前)(iOS平台，最高有效位是1（第64bit）,Mac平台，最低有效位是1)</li>
</ul>
</li>
</ul>
<p>关于Tagged Pointer，想深入了解的，可以参照<a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">深入理解 Tagged Pointer</a>，就不在这赘述了。需要注意的是，之前的版本，变量的值直接存储在指针中，很容易的可以读取出来，例如<code>0xb000000000000012</code> 然而现在的版本中，苹果对这个指针做了一些编码处理，不能直接看出来是Tagged Pointer，例如<code>0x30a972fb5e339e15</code>然而它依然是Tagged Pointer，因为可以根据源码可知，是根据把它转为二进制之后最后一位是否为1来确定是否为Tagged Pointer。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK 1UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用计数的存储"><a href="#引用计数的存储" class="headerlink" title="引用计数的存储"></a>引用计数的存储</h2><p>在64bit中，引用计数可以直接存储在优化过的isa指针中，也可能存储在SideTable类中,那<code>SideTable</code>中有什么呢？</p>
<p><code>SideTable</code>的结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;<span class="comment">//refcnts是一个存放着对象引用计数的散列表</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line"></span><br><span class="line">   	...还有很多代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>RefcountMap refcnts</code>中存放着对象引用计数的散列表</p>
<h2 id="获取引用计数"><a href="#获取引用计数" class="headerlink" title="获取引用计数"></a>获取引用计数</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用计数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rootRetainCount</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TaggedPointer不是一个普通的对象，不需要做引用计数的一些操作</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123; <span class="comment">//优化过的isa</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc; <span class="comment">// 这里进行了+1操作</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            <span class="comment">//能来到这里，说明引用计数不是存储在isa中，而是存储在sidetable中</span></span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sidetable_getExtraRC_nolock</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>]; <span class="comment">// this 就是key  根据这个key取出value</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; <span class="comment">// 取出的值 经过位运算之后返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sidetable_retainCount()</code>方法的逻辑就是先从 <code>SideTable</code> 的静态方法获取当前实例对应的 <code>SideTable</code> 对象，其 <code>refcnts</code> 属性就是之前说的存储引用计数的散列表，然后在引用计数表中用迭代器查找当前实例对应的键值对，获取引用计数值，并在此基础上 +1 并将结果返回。这也就是为什么之前中说引用计数表存储的值为实际引用计数减一。</p>
<p>需要注意的是为什么这里把键值对的值做了向右移位操作<code>（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）</code></p>
<h2 id="引用计数的增删"><a href="#引用计数的增删" class="headerlink" title="引用计数的增删"></a>引用计数的增删</h2><p>在MRC 环境下可以使用 retain 和 release 方法对引用计数进行加一减一操作，它们分别调用了<code>_objc_rootRetain(id obj)</code> 和 <code>_objc_rootRelease(id obj)</code> 函数，不过后两者在 ARC 环境下也可使用。最后这两个函数又会调用 objc_object 的下面两个方法：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">inline</span> <span class="variable">id</span> </span><br><span class="line"><span class="variable">objc_object</span>::<span class="function"><span class="title">rootRetain</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title"><span class="built_in">assert</span></span>(<span class="variable">!UseGC</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="title">isTaggedPointer</span>()) <span class="variable">return</span> (<span class="variable">id</span>)<span class="variable">this</span>;</span></span><br><span class="line"><span class="function">    <span class="variable">return</span> <span class="title">sidetable_retain</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="variable">inline</span> <span class="variable">bool</span> </span></span><br><span class="line"><span class="function"><span class="variable">objc_object</span>::<span class="title">rootRelease</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title"><span class="built_in">assert</span></span>(<span class="variable">!UseGC</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="title">isTaggedPointer</span>()) <span class="variable">return</span> <span class="variable"><span class="literal">false</span></span>;</span></span><br><span class="line"><span class="function">    <span class="variable">return</span> <span class="title">sidetable_release</span>(<span class="variable"><span class="literal">true</span></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>就是先看释放支持isTaggedPointer，然后再操作 SideTable 中的 refcnts 属性，这与获取引用计数策略类似。sidetable_retain() 将 引用计数加一后返回对象，sidetable_release() 返回是否要执行 dealloc 方法：</p>
<h3 id="引用计数的增加"><a href="#引用计数的增加" class="headerlink" title="引用计数的增加"></a><code>引用计数的增加</code></h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::root<span class="constructor">Retain(<span class="params">bool</span> <span class="params">tryRetain</span>, <span class="params">bool</span> <span class="params">handleOverflow</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">TaggedPointer()</span>) return (id)this;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = <span class="constructor">LoadExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            <span class="constructor">ClearExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain<span class="operator"> &amp;&amp; </span>sideTableLocked) sidetable<span class="constructor">_unlock()</span>;</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) return sidetable<span class="constructor">_tryRetain()</span> ? (id)this : nil;</span><br><span class="line">            <span class="keyword">else</span> return sidetable<span class="constructor">_retain()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain<span class="operator"> &amp;&amp; </span>newisa.deallocating)) &#123;</span><br><span class="line">            <span class="constructor">ClearExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain<span class="operator"> &amp;&amp; </span>sideTableLocked) sidetable<span class="constructor">_unlock()</span>;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                <span class="constructor">ClearExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">                return root<span class="constructor">Retain_overflow(<span class="params">tryRetain</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain<span class="operator"> &amp;&amp; </span>!sideTableLocked) sidetable<span class="constructor">_lock()</span>;</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!<span class="constructor">StoreExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>, <span class="params">oldisa</span>.<span class="params">bits</span>, <span class="params">newisa</span>.<span class="params">bits</span>)</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable<span class="constructor">_addExtraRC_nolock(RC_HALF)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain<span class="operator"> &amp;&amp; </span>sideTableLocked)) sidetable<span class="constructor">_unlock()</span>;</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sidetable_retain</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; <span class="keyword">table</span> = SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">table</span>.lock();</span><br><span class="line">    size_t&amp; refcntStorage = <span class="keyword">table</span>.refcnts[this];</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span>.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用计数的减少"><a href="#引用计数的减少" class="headerlink" title="引用计数的减少"></a>引用计数的减少</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE bool </span><br><span class="line">objc_object:<span class="type"></span>:rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line"> retry:<span class="type"></span></span><br><span class="line"><span class="type">    do </span>&#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!<span class="keyword">new</span><span class="type">isa</span>.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);<span class="comment">//引用计数减少</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = subc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don't ClearExclusive()</span></span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> underflow:<span class="type"></span></span><br><span class="line"><span class="type">    </span>// <span class="keyword">new</span><span class="type">isa</span>.extra_rc-- underflowed: <span class="type">borrow from side table or deallocate</span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type">    </span>// abandon <span class="keyword">new</span><span class="type">isa</span> to undo the decrement</span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">    ...还有很多代码</span><br></pre></td></tr></table></figure>


<ul>
<li>函数<code>sidetable_release</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;<span class="comment">// 来到这里，说明引用计数为0，调用dealloc释放</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">深入理解 Tagged Pointer</a></p>
<p><a href="https://juejin.im/post/5d3be844f265da1bcd381fe3" target="_blank" rel="noopener">详解iOS中的Runtime</a></p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS中三种定时器(`NSTimer`、`CADisplayLink`、`dispatch_source_t`)</title>
    <url>/iOS%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8(%60NSTimer%60%E3%80%81%60CADisplayLink%60%E3%80%81%60dispatch_source_t%60).html/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS中定时器的使用还是很常见的。那么iOS中有几种定时器，平时又怎么使用呢？</p>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>在详解RunLoop之源码分析一文中，简单描述了NStimer和RunLoop的关系</p>
<blockquote>
<p>默认情况下，NSTimer计时器，会被UIScrollView 打断，会影响计时器的使用。原因就是滚动时候，RunLoop切换到了UITrackingRunLoopMode模式下，但计时器在NSDefaultRunLoopMode下，所以就停止了。解决办法就是设置NSRunLoopCommonModes。特别注意的是：NSRunLoopCommonModes并不是一个真的模式，它只是一个标记.如果设置了NSRunLoopCommonModes timer能在_commonModes数组中存放的模式下工作。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面两个定时器的使用是等价的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>

<p>上面两个方法的等价的，区别是第二张，需要自己手动加到RunLoop中，否则不生效。苹果中关于NSTimer的源码是不开源的，但是我们可以参考<a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep源码地址</a>中的源码</p>
<h3 id="scheduledTimerWithTimeInterval"><a href="#scheduledTimerWithTimeInterval" class="headerlink" title="scheduledTimerWithTimeInterval"></a>scheduledTimerWithTimeInterval</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">+</span> <span class="string">(NSTimer*)</span> <span class="attr">scheduledTimerWithTimeInterval:</span> <span class="string">(NSTimeInterval)ti</span></span><br><span class="line">				     <span class="attr">target:</span> <span class="string">(id)object</span></span><br><span class="line">				   <span class="attr">selector:</span> <span class="string">(SEL)selector</span></span><br><span class="line">				   <span class="attr">userInfo:</span> <span class="string">(id)info</span></span><br><span class="line">				    <span class="attr">repeats:</span> <span class="string">(BOOL)f</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="string">id</span> <span class="string">t</span> <span class="string">=</span> <span class="string">[[self</span> <span class="string">alloc]</span> <span class="attr">initWithFireDate:</span> <span class="string">nil</span></span><br><span class="line">			       <span class="attr">interval:</span> <span class="string">ti</span></span><br><span class="line">				 <span class="attr">target:</span> <span class="string">object</span></span><br><span class="line">			       <span class="attr">selector:</span> <span class="string">selector</span></span><br><span class="line">			       <span class="attr">userInfo:</span> <span class="string">info</span></span><br><span class="line">				<span class="attr">repeats:</span> <span class="string">f];</span></span><br><span class="line">  <span class="string">[[NSRunLoop</span> <span class="string">currentRunLoop]</span> <span class="attr">addTimer: t forMode:</span> <span class="string">NSDefaultRunLoopMode];</span></span><br><span class="line">  <span class="string">RELEASE(t);</span></span><br><span class="line">  <span class="string">return</span> <span class="string">t;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="和-timerWithTimeInterval"><a href="#和-timerWithTimeInterval" class="headerlink" title="和 timerWithTimeInterval"></a>和 timerWithTimeInterval</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">+</span> <span class="string">(NSTimer*)</span> <span class="attr">timerWithTimeInterval:</span> <span class="string">(NSTimeInterval)ti</span></span><br><span class="line">			    <span class="attr">target:</span> <span class="string">(id)object</span></span><br><span class="line">			  <span class="attr">selector:</span> <span class="string">(SEL)selector</span></span><br><span class="line">			  <span class="attr">userInfo:</span> <span class="string">(id)info</span></span><br><span class="line">			   <span class="attr">repeats:</span> <span class="string">(BOOL)f</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">AUTORELEASE([[self</span> <span class="string">alloc]</span> <span class="attr">initWithFireDate:</span> <span class="string">nil</span></span><br><span class="line">					   <span class="attr">interval:</span> <span class="string">ti</span></span><br><span class="line">					     <span class="attr">target:</span> <span class="string">object</span></span><br><span class="line">					   <span class="attr">selector:</span> <span class="string">selector</span></span><br><span class="line">					   <span class="attr">userInfo:</span> <span class="string">info</span></span><br><span class="line">					    <span class="attr">repeats:</span> <span class="string">f]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面的源码可知，这两种方式，调用的定时器是一样的，但是第一种会自动添加到RunLoop中，不需要我们来处理了。</p>
<p>但是上面两种都会导致循环引用。原因也很好理解，控制器持有定时器，定时器的target指向当前控制器，所以就循环引用了。</p>
<h2 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h2><p><strong>__weak 不能解除循环引用</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target: weakSelf selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p><code>__weak</code> 和<code>block</code> 能解除循环引用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        [weakSelf test];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>上面的代码中是可以解除循环引用的，然后真正起作用的，是block。和timer并没有加什么关系，详细可以看<a href="https://ityongzhen.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E7%9A%84block.html">深入理解iOS的block</a>一文，有详细说明。</p>
<p>那么问题来了，要怎么解除循环引用呢？</p>
<p><strong>invalidate解除循环引用</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	self.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(test) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillDisappear:</span>(BOOL)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillDisappear:</span>animated];</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码中，在控制器即将消失的时候，调用<code>[self.timer invalidate]</code>;能解除循环引用。但是，在开发中一般不这样用。因为，页面跳转了就会调用<code>viewWillDisappear</code>,然后有时候业务逻辑很复杂，此时并不想取消定时器。更多的时候想让定时器和控制器的生命绑定在一起，那我们可否这么写呢</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    <span class="comment">// 写在这里没用</span></span><br><span class="line"><span class="comment">//   [self.timer invalidate];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是不行的，因为已经循环引用了，在<code>dealloc</code>里面调用<code>[self.timer invalidate]</code>，那这代码永远不会执行。</p>
<ul>
<li><code>NSProxy</code>解除循环引用</li>
</ul>
<p><code>NSProxy</code>是不继承自<code>NSObject</code>的。专门用来做这个事的。</p>
<p><code>NSProxy</code>的效率很高，因为不经过<code>Runtime</code>的，消息发送，消息动态解析，去缓存中查找等流程，直接通过消息转发。关于<code>Runtime</code>的详细分析，可以参考详解iOS中的<code>Runtime</code></p>
<p>API如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class	isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)alloc;</span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone <span class="built_in">NS_AUTOMATED_REFCOUNT_UNAVAILABLE</span>;</span><br><span class="line">+ (Class)<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel <span class="built_in">NS_SWIFT_UNAVAILABLE</span>(<span class="string">"NSInvocation and related APIs not available"</span>);</span><br><span class="line">- (<span class="keyword">void</span>)dealloc;</span><br><span class="line">- (<span class="keyword">void</span>)finalize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *description;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *debugDescription;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)allowsWeakReference <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="built_in">BOOL</span>)retainWeakReference <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - (id)forwardingTargetForSelector:(SEL)aSelector;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>例如isKindOfClass和isMemberOfClass等等，都是直接走消息转发</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (BOOL) <span class="string">isKindOfClass:</span> (Class)aClass</span><br><span class="line">&#123;</span><br><span class="line">  NSMethodSignature	*sig;</span><br><span class="line">  NSInvocation		*inv;</span><br><span class="line">  BOOL			ret;</span><br><span class="line"></span><br><span class="line">  sig = [self <span class="string">methodSignatureForSelector:</span> _cmd];</span><br><span class="line">  inv = [NSInvocation <span class="string">invocationWithMethodSignature:</span> sig];</span><br><span class="line">  [inv <span class="string">setSelector:</span> _cmd];</span><br><span class="line">  [inv <span class="string">setArgument:</span> &amp;aClass <span class="string">atIndex:</span> <span class="number">2</span>];</span><br><span class="line">  [self <span class="string">forwardInvocation:</span> inv];</span><br><span class="line">  [inv <span class="string">getReturnValue:</span> &amp;ret];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL) <span class="string">isMemberOfClass:</span> (Class)aClass</span><br><span class="line">&#123;</span><br><span class="line">  NSMethodSignature	*sig;</span><br><span class="line">  NSInvocation		*inv;</span><br><span class="line">  BOOL			ret;</span><br><span class="line"></span><br><span class="line">  sig = [self <span class="string">methodSignatureForSelector:</span> _cmd];</span><br><span class="line">  inv = [NSInvocation <span class="string">invocationWithMethodSignature:</span> sig];</span><br><span class="line">  [inv <span class="string">setSelector:</span> _cmd];</span><br><span class="line">  [inv <span class="string">setArgument:</span> &amp;aClass <span class="string">atIndex:</span> <span class="number">2</span>];</span><br><span class="line">  [self <span class="string">forwardInvocation:</span> inv];</span><br><span class="line">  [inv <span class="string">getReturnValue:</span> &amp;ret];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建类<code>YZProxy</code>继承自<code>NSProxy</code>,具体代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZProxy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span></span><br><span class="line">    YZProxy *proxy = [YZProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">使用的时候，如下就可以了。</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[YZProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h2><p>除了NSTimer之外，还可以使用CADisplayLink定时器</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	 <span class="comment">// 调用频率和屏幕的刷新帧率一致，60FPS</span></span><br><span class="line">    <span class="keyword">self</span>.link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test)];</span><br><span class="line">    [<span class="keyword">self</span>.link addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop]  forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>CADisplayLink</code>和<code>NSTimer</code>一样也会导致循环引用，解决办法和前面的<code>NSTimer</code>一样。区别就是<code>CADisplayLink</code>并没有类似<code>NSTimer</code>中的<code>block</code>方法<code>：+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code></p>
<h3 id="dispatch-source-t"><a href="#dispatch-source-t" class="headerlink" title="dispatch_source_t"></a>dispatch_source_t</h3><p>前面说了定时器<code>NSTimer</code>和<code>CADisplayLink</code>,但是，他们都是和<code>RunLoop</code>相关的，所以，从详解RunLoop之源码分析中我们知道，我们的计时器设置是每1秒执行一次，假设<code>RunLoop</code>执行完一圈耗时0.3秒，当执行0.8秒的时候，开始下一圈的<code>RunLoop</code>，当执行完之后，已经是1.1秒了。所以，这两种计时器不够精确。当然了，实际上RunLoop每一圈的耗时远远小于0.3，这里只是为了方便说明问题而举例。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_source_t GCDtimer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">    [<span class="keyword">self</span> GCDTest];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)GCDTest</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主队列</span></span><br><span class="line">    <span class="comment">//    dispatch_queue_t queue = dispatch_get_main_queue();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"timer"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置时间</span></span><br><span class="line">    uint64_t start = <span class="number">2.0</span>; <span class="comment">// 2秒后开始执行</span></span><br><span class="line">    uint64_t interval = <span class="number">1.0</span>; <span class="comment">// 每隔1秒执行</span></span><br><span class="line">    dispatch_source_set_timer(timer,</span><br><span class="line">                              dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">                              interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    <span class="comment">//    dispatch_source_set_event_handler(timer, ^&#123;</span></span><br><span class="line">    <span class="comment">//        NSLog(@"1111");</span></span><br><span class="line">    <span class="comment">//    &#125;);</span></span><br><span class="line">    dispatch_source_set_event_handler_f(timer, timerFire);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.GCDtimer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> timerFire(<span class="keyword">void</span> *param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2222 - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="两种设置时间方式"><a href="#两种设置时间方式" class="headerlink" title="两种设置时间方式"></a>两种设置时间方式</h3><p>主要注意的是,<code>dispatch_source_set_timer</code>需要一个参数<code>dispatch_time_t,而dispatch_time_t</code>的创建有两种</p>
<ul>
<li>dispatch_time(dispatch_time_t when, int64_t delta)</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">第一个参数是从什么时间开始,一般直接传 DISPATCH_TIME_NOW; 表示从现在开始</span><br><span class="line">第二个参数表示具体的时间长度(不能直接传 <span class="built_in">int</span> 或 <span class="built_in">float</span>), 可以写成这种形式 (<span class="built_in">int</span>64_t)<span class="number">2</span>* NSEC_PER_SEC</span><br><span class="line">        </span><br><span class="line">        #define NSEC_PER_SEC <span class="number">1000000000</span>ull  表示每秒有<span class="number">1000000000</span>纳秒</span><br><span class="line">        #define NSEC_PER_MSEC <span class="number">1000000</span>ull    表示每毫秒有<span class="number">1000000</span>纳秒</span><br><span class="line">        #define USEC_PER_SEC <span class="number">1000000</span>ull     表示每秒有<span class="number">1000000</span>微秒</span><br><span class="line">        #define NSEC_PER_USEC <span class="number">1000</span>ull       表示每微秒有<span class="number">1000</span>纳秒</span><br><span class="line">        </span><br><span class="line">  注意 delta 的单位是纳秒! </span><br><span class="line"> <span class="number">1</span>秒可以写成是 <span class="number">1</span>* NSEC_PER_SEC 或者 <span class="number">1000</span>* NSEC_PER_MSEC 或者 USEC_PER_SEC* NSEC_PER_USEC</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dispatch_time_t
dispatch_time(dispatch_time_t when, int64_t delta);
dispatch_walltime(const struct timespec *_Nullable when, int64_t delta)</code></li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">第一个参数是一个结构体, 创建的是一个绝对的时间点,比如 <span class="number">2016</span>年<span class="number">10</span>月<span class="number">10</span>日<span class="number">8</span>点<span class="number">30</span>分<span class="number">30</span>秒, 如果你不需要自某一个特定的时刻开始,可以传 NUll,表示自动获取当前时区的当前时间作为开始时刻,。</span><br><span class="line">第二参数意义同第一个函数</span><br><span class="line"></span><br><span class="line">dispatch_time_t</span><br><span class="line">dispatch_walltime(<span class="keyword">const</span> struct timespec *_Nullable when, <span class="built_in">int</span>64_t delta);</span><br></pre></td></tr></table></figure>

<h3 id="这两种方式的区别是："><a href="#这两种方式的区别是：" class="headerlink" title="这两种方式的区别是："></a>这两种方式的区别是：</h3><blockquote>
<p>例如: 从现在开始,1小时之后是触发某个事件</p>
</blockquote>
<blockquote>
<p>使用第一个函数创建的是一个相对的时间,第一个参数开始时间参考的是当前系统的时钟,当 device 进入休眠之后,系统的时钟也会进入休眠状态, 第一个函数同样被挂起; 假如 device 在第一个函数开始执行后10分钟进入了休眠状态,那么这个函数同时也会停止执行,当你再次唤醒 device 之后,该函数同时被唤醒,但是事件的触发就变成了从唤醒 device 的时刻开始,1小时之后触发某个事件</p>
</blockquote>
<blockquote>
<p>而第二个函数则不同,他创建的是一个绝对的时间点,一旦创建就表示从这个时间点开始,1小时之后触发事件,假如 device 休眠了10分钟,当再次唤醒 device 的时候,计算时间间隔的时间起点还是 开始时就设置的那个时间点, 而不会受到 device 是否进入休眠影响</p>
</blockquote>
<p>这种方式可以更加精确地使用定时器，因为是直接跟内核挂钩的，跟<code>RunLoop</code>没有关系，所以也不会有常见的<code>RunLoop</code>模式的改变而导致定时器的暂停等问题。如果我们需要对定时器的精度要求很高的话，可以考虑<code>dispatch_source_t</code>去实现</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>关于iOS中的13种加锁方案</title>
    <url>/%E5%85%B3%E4%BA%8EiOS%E4%B8%AD%E7%9A%8413%E7%A7%8D%E5%8A%A0%E9%94%81%E6%96%B9%E6%A1%88.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E5%85%B3%E4%BA%8EiOS%E4%B8%AD%E7%9A%8413%E7%A7%8D%E5%8A%A0%E9%94%81%E6%96%B9%E6%A1%88.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS中有很多锁，那么平时使用过程中到底怎么使用呢？本文分享13种加锁方案。本文较长总共一万字。文中代码在<a href="https://github.com/ITyongzhen/iOS-ManyLocks" target="_blank" rel="noopener">github</a>上。</p>
<ul>
<li><code>OSSpinLock</code>自旋锁</li>
<li><code>os_unfair_lock</code>互斥锁</li>
<li><code>pthread_mutex</code>递归锁</li>
<li><code>pthread_mutex</code>条件锁</li>
<li><code>dispatch_semaphore</code>信号量</li>
<li><code>dispatch_queue(DISPATCH_QUEUE_SERIAL)</code></li>
<li><code>NSLock</code></li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSCondition</code></li>
<li><code>NSConditionLock</code></li>
<li><code>@synchronized</code></li>
<li><code>dispatch_barrier_async</code>栅栏</li>
<li><code>dispatch_group</code>调度组</li>
</ul>
<p>性能对比：借用ibireme大神的一张图片 </p>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200530102412.png" alt=""></p>
<p>可以看到除了 <code>OSSpinLock</code> 外，<code>dispatch_semaphore</code> 和 <code>pthread_mutex</code> 性能是最高的。现在苹果在新系统中已经优化了 <code>pthread_mutex</code>的性能，所以它看上去和 <code>OSSpinLock</code> 差距并没有那么大了</p>
<p>GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍</p>
<p><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep源码地址</a></p>
<p>虽然<a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep</a>不是苹果官方源码，但还是具有一定的参考价值</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>wikipedia中关于<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%97%8B%E9%94%81" target="_blank" rel="noopener">自旋锁</a>的描述</p>
<blockquote>
<p>自旋锁是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>
</blockquote>
<blockquote>
<p>自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此操作系统的实现在很多地方往往用自旋锁。Windows操作系统提供的轻型读写锁（SRW Lock）内部就用了自旋锁。显然，单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。</p>
</blockquote>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>wikipedia中关于<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81" target="_blank" rel="noopener">互斥锁</a>的描述</p>
<blockquote>
<p>互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
</blockquote>
<p>需要此机制的资源的例子有：旗标、队列、计数器、中断处理程序等用于在多条并行运行的代码间传递数据、同步状态等的资源。维护这些资源的同步、一致和完整是很困难的，因为一条线程可能在任何一个时刻被暂停（休眠）或者恢复（唤醒）。</p>
<p>例如：一段代码（甲）正在分步修改一块数据。这时，另一条线程（乙）由于一些原因被唤醒。如果乙此时去读取甲正在修改的数据，而甲碰巧还没有完成整个修改过程，这个时候这块数据的状态就处在极大的不确定状态中，读取到的数据当然也是有问题的。更严重的情况是乙也往这块地方写数据，这样的一来，后果将变得不可收拾。因此，多个线程间共享的数据必须被保护。达到这个目的的方法，就是确保同一时间只有一个临界区域处于运行状态，而其他的临界区域，无论是读是写，都必须被挂起并且不能获得运行机会。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>wikipedia中关于<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81" target="_blank" rel="noopener">互斥锁</a>的描述</p>
<blockquote>
<p>读写锁是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁。多读者锁，“push lock”) 用于解决读写问题。读操作可并发重入，写操作是互斥的。</p>
</blockquote>
<blockquote>
<p>读写锁通常用互斥锁、条件变量、信号量实现。</p>
</blockquote>
<p>读写锁可以有不同的操作模式优先级：</p>
<ul>
<li>读操作优先：允许最大并发，但写操作可能饿死。</li>
<li>写操作优先：一旦所有已经开始的读操作完成，等待的写操作立即获得锁。内部实现需要两把互斥锁。</li>
<li>未指定优先级</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>wikipedia中关于<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F" target="_blank" rel="noopener">信号量</a>的描述</p>
<blockquote>
<p>信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p>
</blockquote>
<blockquote>
<p>semaphore对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。</p>
</blockquote>
<blockquote>
<p>信号量的概念是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用经典的存钱-取钱案例。假设我们账号里面有100元，每次存钱都存10元，每次取钱都取20元。存5次，取5次。那么就是应该最终剩下50元才对。如果我们把存在和取钱在不同的线程中访问的时候，如果不加锁，就很可能导致问题。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 存钱、取钱演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)moneyTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.money = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> __saveMoney];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> __drawMoney];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 存钱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> oldMoney = <span class="keyword">self</span>.money;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldMoney += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.money = oldMoney;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"存10元，还剩%d元 - %@"</span>, oldMoney, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 取钱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> oldMoney = <span class="keyword">self</span>.money;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldMoney -= <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">self</span>.money = oldMoney;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"取20元，还剩%d元 - %@"</span>, oldMoney, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249636</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600001b4f540</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249637</span>] 取<span class="number">20</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600001b79840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249636</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600001b4f540</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249636</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600001b4f540</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249637</span>] 取<span class="number">20</span>元，还剩<span class="number">100</span>元 - &lt;NSThread: <span class="number">0x600001b79840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249637</span>] 取<span class="number">20</span>元，还剩<span class="number">90</span>元 - &lt;NSThread: <span class="number">0x600001b79840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249636</span>] 存<span class="number">10</span>元，还剩<span class="number">100</span>元 - &lt;NSThread: <span class="number">0x600001b4f540</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249637</span>] 取<span class="number">20</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600001b79840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249636</span>] 存<span class="number">10</span>元，还剩<span class="number">90</span>元 - &lt;NSThread: <span class="number">0x600001b4f540</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">21005</span>:<span class="number">249637</span>] 取<span class="number">20</span>元，还剩<span class="number">70</span>元 - &lt;NSThread: <span class="number">0x600001b79840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>从结果上来看，明显不是预期的那样</p>
<p>这是因为，正常情况下，来存钱取消，存10元之后，还剩下110元，然后取钱20元，剩余90元没问题。但是我们是不同线程同时操作的时候，可能导致的情况是，正在存钱的是，来取钱了。也就是10元还没存进去，就去取钱。取钱之后先去获取当前的钱数，因为10元正在存呢，还没存完，取钱的时候，当前是100元，然后取出20元的过程中，刚才的10元存进去了，然后20元也取出来了。给出结果是100-20 = 80 元，然后实际上应该 100+10-20 = 90 元。这样的话，就导致了数据的紊乱。</p>
<h3 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h3><p>解决这种问题，就需要线程锁了。当存钱的时候，先去加锁，然后存完了，再放开锁。取钱也是一样，这样就保证数据的一致性。</p>
<h2 id="OSSpinLock自旋锁"><a href="#OSSpinLock自旋锁" class="headerlink" title="OSSpinLock自旋锁"></a><code>OSSpinLock</code>自旋锁</h2><ul>
<li><code>OSSpinLock</code>叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</li>
<li>目前已经不再安全，可能会出现优先级反转问题</li>
<li>需要导入头文件<code>#import &lt;libkern/OSAtomic.h&gt;</code></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="comment">//尝试加锁(如果不需要等待，就直接加锁，返回true。如果需要等待，就不加锁，返回false)</span></span><br><span class="line">BOOL res = <span class="constructor">OSSpinLockTry(<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="constructor">OSSpinLockLock(<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="constructor">OSSpinLockUnlock(<span class="params">lock</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>YZOSSpinLock</code>继承<code>YZBaseLock</code>，在每次存钱，取钱之前进行加锁，在每次存钱，取钱之后进行解锁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZOSSpinLock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZOSSpinLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) OSSpinLock moneyLock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZOSSpinLock</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.moneyLock = OS_SPINLOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265962</span>] 取<span class="number">20</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600003add800</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265962</span>] 取<span class="number">20</span>元，还剩<span class="number">60</span>元 - &lt;NSThread: <span class="number">0x600003add800</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265962</span>] 取<span class="number">20</span>元，还剩<span class="number">40</span>元 - &lt;NSThread: <span class="number">0x600003add800</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265962</span>] 取<span class="number">20</span>元，还剩<span class="number">20</span>元 - &lt;NSThread: <span class="number">0x600003add800</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265962</span>] 取<span class="number">20</span>元，还剩<span class="number">0</span>元 - &lt;NSThread: <span class="number">0x600003add800</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265961</span>] 存<span class="number">10</span>元，还剩<span class="number">10</span>元 - &lt;NSThread: <span class="number">0x600003aecd00</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265961</span>] 存<span class="number">10</span>元，还剩<span class="number">20</span>元 - &lt;NSThread: <span class="number">0x600003aecd00</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265961</span>] 存<span class="number">10</span>元，还剩<span class="number">30</span>元 - &lt;NSThread: <span class="number">0x600003aecd00</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265961</span>] 存<span class="number">10</span>元，还剩<span class="number">40</span>元 - &lt;NSThread: <span class="number">0x600003aecd00</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">22496</span>:<span class="number">265961</span>] 存<span class="number">10</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600003aecd00</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>由输出可知，能保证线程安全，数据没有错乱。但是<code>OSSpinLock</code>已经不再安全了。</p>
<h3 id="汇编跟踪"><a href="#汇编跟踪" class="headerlink" title="汇编跟踪"></a>汇编跟踪</h3><p>在加锁的地方打断点，第二次进来的是，已经加锁了，这时候看加锁的汇编代码</p>
<blockquote>
<p>Debug-&gt;Debug Worlflow-&gt;Always Show Disassembly</p>
</blockquote>
<h3 id="为什么OSSpinLock不再安全"><a href="#为什么OSSpinLock不再安全" class="headerlink" title="为什么OSSpinLock不再安全"></a>为什么<code>OSSpinLock</code>不再安全</h3><p>关于为什么<code>OSSpinLock</code>不再安全可以参考这篇文章<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<p>这里摘要主要内容</p>
<blockquote>
<p>如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock，这就是优先级反转。这并不只是理论上的问题，开发者已经遇到很多次这个问题，于是苹果工程师停用了 OSSpinLock。</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。</li>
</ul>
<h2 id="os-unfair-lock互斥锁"><a href="#os-unfair-lock互斥锁" class="headerlink" title="os_unfair_lock互斥锁"></a><code>os_unfair_lock</code>互斥锁</h2><p><code>os_unfair_lock</code>用于取代不安全的OSSpinLock ，从iOS10开始才支持<br>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</p>
<p>需要导入头文件<code>#import &lt;os/lock.h&gt;</code></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"><span class="comment">//尝试加锁(如果不需要等待，就直接加锁，返回true。如果需要等待，就不加锁，返回false)</span></span><br><span class="line">BOOL res = os<span class="constructor">_unfair_lock_trylock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">os<span class="constructor">_unfair_lock_lock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">os<span class="constructor">_unfair_lock_unlock(&amp;<span class="params">lock</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>YZUnfairLock</code>继承<code>YZBaseLock</code>，在每次存钱，取钱之前进行加锁，在每次存钱，取钱之后进行解锁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZUnfairLock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;os/lock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZUnfairLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>) os_unfair_lock moneyLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZUnfairLock</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.moneyLock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    os_unfair_lock_lock(&amp;_moneyLock);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    </span><br><span class="line">    os_unfair_lock_unlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    os_unfair_lock_lock(&amp;_moneyLock);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    </span><br><span class="line">    os_unfair_lock_unlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="汇编跟踪-1"><a href="#汇编跟踪-1" class="headerlink" title="汇编跟踪"></a>汇编跟踪</h3><p>在加锁的地方打断点，第二次进来的是，已经加锁了，这时候看加锁的汇编代码</p>
<blockquote>
<p>Debug-&gt;Debug Worlflow-&gt;Always Show Disassembly</p>
</blockquote>
<p>断点跟踪进去，会发现最终到<code>syscall</code>的时候，断点失效了。这是因为syscall调用了系统内核的函数，使得线程进入休眠状态，不再占用CPU资源。所以可以看出<code>os_unfair_lock</code>是互斥锁。</p>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200603101247.png" alt=""></p>
<h2 id="pthread-mutex互斥锁"><a href="#pthread-mutex互斥锁" class="headerlink" title="pthread_mutex互斥锁"></a><code>pthread_mutex</code>互斥锁</h2><ul>
<li>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态</li>
<li>需要导入头文件#import &lt;pthread.h&gt;</li>
</ul>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_DEFAULT)</span>;</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread<span class="constructor">_mutex_init(<span class="params">mutex</span>, &amp;<span class="params">attr</span>)</span>;</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread<span class="constructor">_mutexattr_destroy(&amp;<span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其中锁的类型有四种</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_NORMAL		0   <span class="comment">//一般的锁</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_ERRORCHECK	1	<span class="comment">// 错误检查</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_RECURSIVE		2  <span class="comment">//递归锁</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_NORMAL  <span class="comment">//默认</span></span></span><br></pre></td></tr></table></figure>

<p>当类型是<code>PTHREAD_MUTEX_DEFAULT</code>的时候，相当于<code>null</code></p>
<p>例如上面的使用可以直接等价于</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_init(<span class="params">mutex</span>, NULL)</span>; <span class="comment">//传空，相当于PTHREAD_MUTEX_DEFAULT</span></span><br></pre></td></tr></table></figure>

<p><code>YZMutexLock</code>继承<code>YZBaseLock</code>，在每次存钱，取钱之前进行加锁，在每次存钱，取钱之后进行解锁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZMutexLock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZMutexLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t moneyMutexLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZMutexLock</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 初始化锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param mutex 锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)__initMutexLock:(pthread_mutex_t *)mutex&#123;</span><br><span class="line">    <span class="comment">// 静态初始化</span></span><br><span class="line">    <span class="comment">//            pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    pthread_mutexattr_t attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">    <span class="comment">// 销毁属性</span></span><br><span class="line">    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 上面五行相当于下面一行</span></span><br><span class="line">    <span class="comment">//pthread_mutex_init(mutex, NULL); //传空，相当于PTHREAD_MUTEX_DEFAULT</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> __initMutexLock:&amp;_moneyMutexLock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_moneyMutexLock);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    </span><br><span class="line">     pthread_mutex_unlock(&amp;_moneyMutexLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">     pthread_mutex_lock(&amp;_moneyMutexLock);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    </span><br><span class="line">     pthread_mutex_unlock(&amp;_moneyMutexLock);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//delloc时候，需要销毁锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;_moneyMutexLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>看到输出也是没问题的。线程是安全的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">130</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">90</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">70</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">30</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">40</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pthread-mutex递归锁"><a href="#pthread-mutex递归锁" class="headerlink" title="pthread_mutex递归锁"></a><code>pthread_mutex</code>递归锁</h2><ul>
<li>mutex除了有”互斥锁”，还有递归锁</li>
<li>需要导入头文件#import &lt;pthread.h&gt;</li>
</ul>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread<span class="constructor">_mutex_init(<span class="params">mutex</span>, &amp;<span class="params">attr</span>)</span>;</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread<span class="constructor">_mutexattr_destroy(&amp;<span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其中锁的类型有四种</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_NORMAL		0   <span class="comment">//一般的锁</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_ERRORCHECK	1	<span class="comment">// 错误检查</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_RECURSIVE		2  <span class="comment">//递归锁</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_NORMAL  <span class="comment">//默认</span></span></span><br></pre></td></tr></table></figure>

<p>eg:</p>
<p><code>YZMutexRecursiveLock</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行递归加锁</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZMutexRecursiveLock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZMutexRecursiveLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t MutexLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZMutexRecursiveLock</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 初始化锁</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param mutex 锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)__initMutexLock:(pthread_mutex_t *)mutex&#123;</span><br><span class="line">    <span class="comment">// 递归锁：允许同一个线程对一把锁进行重复加锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    pthread_mutexattr_t attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">    <span class="comment">// 销毁属性</span></span><br><span class="line">    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest&#123;</span><br><span class="line">    <span class="comment">// 第一次进来直接加锁，第二次进来，已经加锁了。还能递归继续加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;_MutexLock);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"加锁 %s"</span>,__func__);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        [<span class="keyword">self</span> otherTest];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"解锁 %s"</span>,__func__);</span><br><span class="line">    pthread_mutex_unlock(&amp;_MutexLock);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> __initMutexLock:&amp;_MutexLock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//delloc时候，需要销毁锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;_MutexLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZMutexRecursiveLock alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 加锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 加锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 加锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 加锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 加锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 加锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 解锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 解锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 解锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 解锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 解锁 -[YZMutexRecursiveLock otherTest]</span><br><span class="line">iOS-LockDemo[<span class="number">7358</span>:<span class="number">129676</span>] 解锁 -[YZMutexRecursiveLock otherTest]</span><br></pre></td></tr></table></figure>

<p>由结果可知，连续加锁五次，是因为每次都递归加锁。然后解锁时候，层层解锁。</p>
<h2 id="pthread-mutex条件锁"><a href="#pthread-mutex条件锁" class="headerlink" title="pthread_mutex条件锁"></a><code>pthread_mutex</code>条件锁</h2><p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200603101518.png" alt=""></p>
<ul>
<li>mutex除了有”互斥锁”，”递归锁”，还有递归锁</li>
<li>需要导入头文件#import &lt;pthread.h&gt;</li>
</ul>
<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p>为了演示条件锁的作用，就用生产者消费者来展示效果，关于生产者消费者的设计模式，可以看我之前的文章<a href="https://ityongzhen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%BA%8C)%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85.html/">iOS设计模式之(二)生产者-消费者</a>，那篇文章中用的是信号量实现的。这篇文章用<code>pthread_mutex</code>条件锁来实现。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>有三个属性</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t mutex; <span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_cond_t cond; <span class="comment">//条件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data; <span class="comment">//数据源</span></span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread<span class="constructor">_mutex_init(&amp;<span class="params">_mutex</span>, &amp;<span class="params">attr</span>)</span>;</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread<span class="constructor">_mutexattr_destroy(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 初始化条件</span></span><br><span class="line">pthread<span class="constructor">_cond_init(&amp;<span class="params">_cond</span>, NULL)</span>;</span><br><span class="line">        </span><br><span class="line">self.data = <span class="literal">[NSM<span class="identifier">utableArray</span> <span class="identifier">array</span>]</span>;</span><br></pre></td></tr></table></figure>



<p>eg:</p>
<p><code>YZMutexCondLock</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  YZMutexCondLock.m</span></span><br><span class="line"><span class="comment">//  iOS-LockDemo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by eagle on 2018/8/13.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018 yongzhen. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZMutexCondLock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZMutexCondLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t mutex; <span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_cond_t cond; <span class="comment">//条件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data; <span class="comment">//数据源</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZMutexCondLock</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化属性</span></span><br><span class="line">        pthread_mutexattr_t attr;</span><br><span class="line">        pthread_mutexattr_init(&amp;attr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">        <span class="comment">// 销毁属性</span></span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化条件</span></span><br><span class="line">        pthread_cond_init(&amp;_cond, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">    </span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者-消费者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据为空就等待（进入休眠，放开mutex锁，被唤醒后，会再次对mutex加锁）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"__remove - 等待"</span>);</span><br><span class="line">        pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line">    pthread_cond_signal(&amp;_cond);</span><br><span class="line">    <span class="comment">// 激活所有等待该条件的线程</span></span><br><span class="line">    <span class="comment">//    pthread_cond_broadcast(&amp;_cond);</span></span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZMutexCondLock alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">31.643902</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">26733</span>:<span class="number">229374</span>] __remove - 等待</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">32.648587</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">26733</span>:<span class="number">229375</span>] 添加了元素</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">09</span>:<span class="number">32.648894</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">26733</span>:<span class="number">229374</span>] 删除了元素</span><br></pre></td></tr></table></figure>

<p>由结果可知，打印完<code>__remove - 等待</code>之后，等待了一秒钟，添加元素之后，放开锁，才去删除元素。</p>
<h2 id="NSLock锁"><a href="#NSLock锁" class="headerlink" title="NSLock锁"></a>NSLock锁</h2><ul>
<li><code>NSLock</code>是对<code>mutex</code>普通锁的封装</li>
</ul>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p><code>NSLocking</code>协议有加锁<code>lock</code>和解锁<code>unlock</code>，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>NSLock准守这个协议，锁可以直接使用，另外，还有<code>tryLock</code>和<code>lockBeforeDate</code></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">lock</span>; <span class="comment">//加锁</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">unlock</span>; <span class="comment">//解锁</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">tryLock</span>; <span class="comment">//尝试加锁，如果加锁失败，就返回NO,加锁成功就返回YES</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">lockBeforeDate</span><span class="selector-pseudo">:(NSDate</span> *)<span class="selector-tag">limit</span>; <span class="comment">//在给定的时间内尝试加锁，加锁成功就返回YES,如果过了时间还没加上锁，就返回NO。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><p><code>YZNSLock</code>继承<code>YZBaseLock</code>，在每次存钱，取钱之前进行加锁，在每次存钱，取钱之后进行解锁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZNSLock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZNSLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZNSLock</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.lock =[[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">130</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">100</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">60</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">40</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>由输出可知，能保证线程安全，数据没有错乱。</p>
<h3 id="NSLock是对mutex普通锁的封装"><a href="#NSLock是对mutex普通锁的封装" class="headerlink" title="NSLock是对mutex普通锁的封装"></a><code>NSLock</code>是对<code>mutex</code>普通锁的封装</h3><p>如果想证明<code>NSLock</code>是对<code>mutex</code>普通锁的封装有两种方式</p>
<ul>
<li>汇编分析<ul>
<li>汇编分析来说，可以打断点跟进去，最终会发现调用了<code>mutex</code>，因为，lock是调用的msgSend,汇编代码比较复杂，读者有兴趣可自行验证。</li>
</ul>
</li>
<li><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep</a><ul>
<li><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep</a>源码的NSLock.m中如下代码</li>
</ul>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">+ (void) initialize</span><br><span class="line">&#123;</span><br><span class="line">  static BOOL	beenHere = NO;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beenHere<span class="operator"> == </span>NO)</span><br><span class="line">    &#123;</span><br><span class="line">      beenHere = YES;</span><br><span class="line">      pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr_normal</span>)</span>;</span><br><span class="line">      pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr_normal</span>, PTHREAD_MUTEX_NORMAL)</span>;</span><br><span class="line">      pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr_reporting</span>)</span>;</span><br><span class="line">      pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr_reporting</span>, PTHREAD_MUTEX_ERRORCHECK)</span>;</span><br><span class="line">      pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr_recursive</span>)</span>;</span><br><span class="line">      pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr_recursive</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br><span class="line">      </span><br><span class="line"><span class="operator">      ... </span>其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="NSRecursiveLock锁"><a href="#NSRecursiveLock锁" class="headerlink" title="NSRecursiveLock锁"></a>NSRecursiveLock锁</h2><ul>
<li>NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致</li>
</ul>
<h3 id="api-1"><a href="#api-1" class="headerlink" title="api"></a>api</h3><p><code>NSLocking</code>协议有加锁<code>lock</code>和解锁<code>unlock</code>，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>NSRecursiveLock准守这个协议，可以直接使用，另外，还有<code>tryLock</code>和<code>lockBeforeDate</code></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">lock</span>; <span class="comment">//加锁</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">unlock</span>; <span class="comment">//解锁</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">tryLock</span>; <span class="comment">//尝试加锁，如果加锁失败，就返回NO,加锁成功就返回YES</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">lockBeforeDate</span><span class="selector-pseudo">:(NSDate</span> *)<span class="selector-tag">limit</span>; <span class="comment">//在给定的时间内尝试加锁，加锁成功就返回YES,如果过了时间还没加上锁，就返回NO。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h3><p><code>YZNSRecursiveLock</code>继承<code>YZBaseLock</code>，在每次存钱，取钱之前进行加锁，在每次存钱，取钱之后进行解锁。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZNSRecursiveLock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZNSRecursiveLock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSRecursiveLock</span> *lock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZNSRecursiveLock</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.lock =[[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">130</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">100</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">60</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397287</span>] 取<span class="number">20</span>元，还剩<span class="number">40</span>元 - &lt;NSThread: <span class="number">0x600000ae66c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">39175</span>:<span class="number">397286</span>] 存<span class="number">10</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600000af2740</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>由输出可知，能保证线程安全，数据没有错乱。</p>
<h3 id="YZNSRecursiveLock是对mutex递归锁的封装"><a href="#YZNSRecursiveLock是对mutex递归锁的封装" class="headerlink" title="YZNSRecursiveLock是对mutex递归锁的封装"></a><code>YZNSRecursiveLock</code>是对<code>mutex</code>递归锁的封装</h3><p>如果想证明<code>NSRecursiveLock</code>是对<code>mutex</code>普通锁的封装有两种方式</p>
<ul>
<li>汇编分析<ul>
<li>汇编分析来说，可以打断点跟进去，最终会发现调用了<code>mutex</code>，因为，lock是调用的msgSend,汇编代码比较复杂，读者有兴趣可自行验证。</li>
</ul>
</li>
<li><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep</a><ul>
<li><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep</a>源码的NSLock.m中的NSRecursiveLock有如下代码</li>
</ul>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NSRecursiveLock初始化</span></span><br><span class="line">- (id) init</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (nil != (self = <span class="literal">[<span class="identifier">super</span> <span class="identifier">init</span>]</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != pthread<span class="constructor">_mutex_init(&amp;<span class="params">_mutex</span>, &amp;<span class="params">attr_recursive</span>)</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="constructor">DESTROY(<span class="params">self</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attr_recursive初始化</span></span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr_recursive</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr_recursive</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="NSCondition条件锁"><a href="#NSCondition条件锁" class="headerlink" title="NSCondition条件锁"></a><code>NSCondition</code>条件锁</h2><ul>
<li>NSCondition是对mutex和cond的封装</li>
</ul>
<h3 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h3><h4 id="生产者消费者-1"><a href="#生产者消费者-1" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p>同上面的<code>YZMutexCondLock</code>一样使用生产者消费者模式</p>
<h4 id="api-2"><a href="#api-2" class="headerlink" title="api"></a>api</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">wait</span>; <span class="comment">//等待</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">waitUntilDate</span><span class="selector-pseudo">:(NSDate</span> *)<span class="selector-tag">limit</span>; <span class="comment">//在给定时间之前等待</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">signal</span>;   <span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">broadcast</span>;  <span class="comment">// 激活所有等待该条件的线程</span></span><br></pre></td></tr></table></figure>

<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>初始化</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line"> <span class="keyword">self</span>.condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br></pre></td></tr></table></figure>



<p>eg:</p>
<p><code>YZNSCondition</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZNSCondition.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZNSCondition</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSCondition</span> *condition;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZNSCondition</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">    </span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者-消费者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.condition lock];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据为空就等待（进入休眠，放开锁，被唤醒后，会再次对mutex加锁）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"__remove - 等待"</span>);</span><br><span class="line">        [<span class="keyword">self</span>.condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.condition lock];</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line">    [<span class="keyword">self</span>.condition signal];</span><br><span class="line">    <span class="comment">// 激活所有等待该条件的线程</span></span><br><span class="line">    <span class="comment">//     [self.condition broadcast];</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZNSCondition alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">31.643902</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">26733</span>:<span class="number">229374</span>] __remove - 等待</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">32.648587</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">26733</span>:<span class="number">229375</span>] 添加了元素</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">32.648894</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">26733</span>:<span class="number">229374</span>] 删除了元素</span><br></pre></td></tr></table></figure>

<p>由结果可知，打印完<code>__remove - 等待</code>之后，等待了一秒钟，添加元素之后，放开锁，才去删除元素。</p>
<h2 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h2><p>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>主要有如下几个API，顾名思义，一看名字就懂了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure>

<h3 id="使用-8"><a href="#使用-8" class="headerlink" title="使用"></a>使用</h3><p>初始化</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当条件为2的时候，加锁</span></span><br><span class="line">[lock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当条件为3的时候，解锁</span></span><br><span class="line"> [lock unlockWithCondition:<span class="number">3</span>];</span><br></pre></td></tr></table></figure>


<p>eg:</p>
<p><code>YZNSConditionLock</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZNSConditionLock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZNSConditionLock</span>()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZNSConditionLock</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//主线程中</span></span><br><span class="line">    <span class="built_in">NSConditionLock</span> *lock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1解锁成功"</span>);</span><br><span class="line">        [lock unlockWithCondition:<span class="number">3</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lockWhenCondition:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2解锁成功"</span>);</span><br><span class="line">        [lock unlockWithCondition:<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程3</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lockWhenCondition:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程3"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程3解锁成功"</span>);</span><br><span class="line">        [lock unlockWithCondition:<span class="number">4</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程4</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lockWhenCondition:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程4"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程4解锁成功"</span>);</span><br><span class="line">        [lock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZNSConditionLock alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">07.850783</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143479</span>] 线程<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">10.854390</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143479</span>] 线程<span class="number">2</span>解锁成功</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">10.854703</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143478</span>] 线程<span class="number">4</span></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">12.856226</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143478</span>] 线程<span class="number">4</span>解锁成功</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">12.856487</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143476</span>] 线程<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">14.860596</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143476</span>] 线程<span class="number">1</span>解锁成功</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">14.860791</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143477</span>] 线程<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">17.864072</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">11810</span>:<span class="number">143477</span>] 线程<span class="number">3</span>解锁成功</span><br></pre></td></tr></table></figure>

<p>由结果可知，NSConditionLock完全能够通过条件值进行加锁解锁。</p>
<h2 id="dispatch-semaphore信号量"><a href="#dispatch-semaphore信号量" class="headerlink" title="dispatch_semaphore信号量"></a><code>dispatch_semaphore</code>信号量</h2><ul>
<li>semaphore叫做”信号量”</li>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>
<li>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</li>
</ul>
<p>关于信号量详细可以参考<a href="https://www.jianshu.com/p/24ffa819379c" target="_blank" rel="noopener"><code>GCD信号量-dispatch_semaphore_t</code></a> 以及对信号量实际应用,结合RunLoop做成卡顿监控的<a href="https://ityongzhen.github.io/iOS%E4%BD%BF%E7%94%A8RunLoop%E7%9B%91%E6%8E%A7%E7%BA%BF%E4%B8%8A%E5%8D%A1%E9%A1%BF.html">iOS使用RunLoop监控线上卡顿</a></p>
<h3 id="信号量原理"><a href="#信号量原理" class="headerlink" title="信号量原理"></a>信号量原理</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_create(<span class="params">long</span> <span class="params">value</span>)</span>; <span class="comment">// 创建信号量</span></span><br><span class="line">dispatch<span class="constructor">_semaphore_signal(<span class="params">dispatch_semaphore_t</span> <span class="params">deem</span>)</span>; <span class="comment">// 发送信号量</span></span><br><span class="line">dispatch<span class="constructor">_semaphore_wait(<span class="params">dispatch_semaphore_t</span> <span class="params">dsema</span>, <span class="params">dispatch_time_t</span> <span class="params">timeout</span>)</span>; <span class="comment">// 等待信号量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>dispatch_semaphore_create(long value)</code>和GCD的group等用法一致，这个函数是创建一个<code>dispatch_semaphore_</code>类型的信号量，并且创建的时候需要指定信号量的大小。</p>
</blockquote>
<blockquote>
<p><code>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</code> 等待信号量。如果信号量值为0，那么该函数就会一直等待，也就是不返回（相当于阻塞当前线程），直到该函数等待的信号量的值大于等于1，该函数会对信号量的值进行减1操作，然后返回。</p>
</blockquote>
<blockquote>
<p><code>dispatch_semaphore_signal(dispatch_semaphore_t deem)</code> 发送信号量。该函数会对信号量的值进行加1操作。</p>
</blockquote>
<blockquote>
<p>通常等待信号量和发送信号量的函数是成对出现的。并发执行任务时候，在当前任务执行之前，用<code>dispatch_semaphore_wait</code>函数进行等待（阻塞），直到上一个任务执行完毕后且通过<code>dispatch_semaphore_signal</code>函数发送信号量（使信号量的值加1），<code>dispatch_semaphore_wait</code>函数收到信号量之后判断信号量的值大于等于1，会再对信号量的值减1，然后当前任务可以执行，执行完毕当前任务后，再通过<code>dispatch_semaphore_signal</code>函数发送信号量（使信号量的值加1），通知执行下一个任务……如此一来，通过信号量，就达到了并发队列中的任务同步执行的要求。</p>
</blockquote>
<h3 id="使用-9"><a href="#使用-9" class="headerlink" title="使用"></a>使用</h3><p>先看加锁，解锁的使用，初始化先设置1，然后每次取钱，存钱之前，都调用<code>dispatch_semaphore_wait</code>,取钱，存钱之后调用<code>dispatch_semaphore_signal</code></p>
<p>eg:</p>
<p><code>YZSemaphore</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZSemaphore.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZSemaphore</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_semaphore_t moneySemaphore;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZSemaphore</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.moneySemaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_wait(<span class="keyword">self</span>.moneySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.moneySemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_wait(<span class="keyword">self</span>.moneySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.moneySemaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部调用的时候，</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZSemaphore alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock moneyTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171371</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600001ca9840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171369</span>] 取<span class="number">20</span>元，还剩<span class="number">90</span>元 - &lt;NSThread: <span class="number">0x600001c960c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171371</span>] 存<span class="number">10</span>元，还剩<span class="number">100</span>元 - &lt;NSThread: <span class="number">0x600001ca9840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171369</span>] 取<span class="number">20</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600001c960c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171371</span>] 存<span class="number">10</span>元，还剩<span class="number">90</span>元 - &lt;NSThread: <span class="number">0x600001ca9840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171369</span>] 取<span class="number">20</span>元，还剩<span class="number">70</span>元 - &lt;NSThread: <span class="number">0x600001c960c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171371</span>] 存<span class="number">10</span>元，还剩<span class="number">80</span>元 - &lt;NSThread: <span class="number">0x600001ca9840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171369</span>] 取<span class="number">20</span>元，还剩<span class="number">60</span>元 - &lt;NSThread: <span class="number">0x600001c960c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171371</span>] 存<span class="number">10</span>元，还剩<span class="number">70</span>元 - &lt;NSThread: <span class="number">0x600001ca9840</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">13500</span>:<span class="number">171369</span>] 取<span class="number">20</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600001c960c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>有结果可知，能保证多线程数据的安全读写。</p>
<h3 id="使用二"><a href="#使用二" class="headerlink" title="使用二"></a>使用二</h3><p>信号量还可以控制线程数量，例如初始化的时候，设置最多3条线程</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZSemaphore.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZSemaphore</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_semaphore_t semaphore;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZSemaphore</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore = dispatch_semaphore_create(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>] start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程10、7、6、9、8</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">    <span class="comment">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">    dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让信号量的值+1</span></span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>调用<code>otherTest</code>的输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">56.489121</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180654</span>] test - &lt;NSThread: <span class="number">0x600003a938c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">56.492100</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180655</span>] test - &lt;NSThread: <span class="number">0x600003a93900</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">56.492281</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180656</span>] test - &lt;NSThread: <span class="number">0x600003a93940</span>&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">58.497578</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180657</span>] test - &lt;NSThread: <span class="number">0x600003a93980</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">58.499225</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180658</span>] test - &lt;NSThread: <span class="number">0x600003a8e640</span>&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">58.549633</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180659</span>] test - &lt;NSThread: <span class="number">0x600003a93a00</span>&gt;&#123;number = <span class="number">8</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">00.499672</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180660</span>] test - &lt;NSThread: <span class="number">0x600003aa6cc0</span>&gt;&#123;number = <span class="number">9</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">00.499799</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180661</span>] test - &lt;NSThread: <span class="number">0x600003aa6ec0</span>&gt;&#123;number = <span class="number">10</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">00.550353</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180662</span>] test - &lt;NSThread: <span class="number">0x600003aa6d80</span>&gt;&#123;number = <span class="number">11</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">02.501379</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">14002</span>:<span class="number">180663</span>] test - &lt;NSThread: <span class="number">0x600003aa6f00</span>&gt;&#123;number = <span class="number">12</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>由结果可知，每次最多三条线程执行。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li>@synchronized是对mutex递归锁的封装</li>
<li>源码查看：objc4中的objc-sync.mm文件</li>
<li>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</li>
</ul>
<p>详细了解可以参考 <a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p>
<h3 id="使用-10"><a href="#使用-10" class="headerlink" title="使用"></a>使用</h3><p>@synchronized 使用起来很简单</p>
<p>还使用前面的存钱取票的例子，类YZSynchronized继承自YZBaseLock，代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZSynchronized.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZSynchronized</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZSynchronized</span></span></span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>调用之后</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">120</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">130</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">110</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">90</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">70</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45095</span>] 取<span class="number">20</span>元，还剩<span class="number">30</span>元 - &lt;NSThread: <span class="number">0x600003e84880</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">40</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">iOS-LockDemo[<span class="number">2573</span>:<span class="number">45093</span>] 存<span class="number">10</span>元，还剩<span class="number">50</span>元 - &lt;NSThread: <span class="number">0x600003ebbb80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>可知，多线程的数据没有发生错乱</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>从<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a>中的objc-sync.mm中可知</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> objc<span class="constructor">_sync_enter(<span class="params">id</span> <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        <span class="keyword">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.lock<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            <span class="constructor">_objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objc<span class="constructor">_sync_nil()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="built_in">int</span> objc<span class="constructor">_sync_exit(<span class="params">id</span> <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">bool</span> okay = data-&gt;mutex.<span class="keyword">try</span><span class="constructor">Unlock()</span>;</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">recursive_mutex_t</span> = recursive_mutex_tt&lt;LOCKDEBUG&gt;;</span><br></pre></td></tr></table></figure>

<p>可知@synchronized是对mutex递归锁的封装。因为是递归锁，可以递归加锁，读者有兴趣自行验证。</p>
<h2 id="pthread-rwlock读写锁"><a href="#pthread-rwlock读写锁" class="headerlink" title="pthread_rwlock读写锁"></a><code>pthread_rwlock</code>读写锁</h2><blockquote>
<p>读写锁是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁。多读者锁，“push lock”) 用于解决读写问题。读操作可并发重入，写操作是互斥的。</p>
</blockquote>
<ul>
<li>需要导入头文件#import &lt;pthread.h&gt;</li>
</ul>
<h4 id="使用-11"><a href="#使用-11" class="headerlink" title="使用"></a>使用</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread<span class="constructor">_rwlock_init(&amp;<span class="params">lock</span>, NULL)</span>;</span><br><span class="line"><span class="comment">// 读-加锁</span></span><br><span class="line">pthread<span class="constructor">_rwlock_rdlock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">// 读-尝试加锁</span></span><br><span class="line">pthread<span class="constructor">_rwlock_tryrdlock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">// 写-加锁</span></span><br><span class="line">pthread<span class="constructor">_rwlock_wrlock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">// 写-尝试加锁</span></span><br><span class="line">pthread<span class="constructor">_rwlock_trywrlock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread<span class="constructor">_rwlock_unlock(&amp;<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">pthread<span class="constructor">_rwlock_destroy(&amp;<span class="params">lock</span>)</span>;</span><br></pre></td></tr></table></figure>



<p>eg:</p>
<p><code>YZRwlock</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试，每次读，或者写的之前进行加锁，并sleep 1秒钟，之后解锁，如下所示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZRwlock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZRwlock</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_rwlock_t lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZRwlock</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_rwlock_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZRwlock alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">45.753659</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248359</span>] -[YZRwlock write]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">46.758460</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248356</span>] -[YZRwlock write]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">47.763705</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248358</span>] -[YZRwlock write]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">48.767980</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248381</span>] -[YZRwlock write]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">49.772241</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248382</span>] -[YZRwlock write]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">50.777547</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248383</span>] -[YZRwlock write]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">51.779544</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248359</span>] -[YZRwlock read]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">51.779544</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248356</span>] -[YZRwlock read]</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">51.779546</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">25457</span>:<span class="number">248358</span>] -[YZRwlock read]</span><br></pre></td></tr></table></figure>

<p>由结果可知，打印完<code>write</code>之后，方法每次都是一个一个执行的，而<code>read</code>是可以同时执行的，也就是说达到了多读单写的功能。被称为读写锁。</p>
<h2 id="dispatch-barrier-async异步栅栏"><a href="#dispatch-barrier-async异步栅栏" class="headerlink" title="dispatch_barrier_async异步栅栏"></a><code>dispatch_barrier_async</code>异步栅栏</h2><ul>
<li>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_cretate</code>创建的</li>
<li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</li>
</ul>
<h3 id="使用-12"><a href="#使用-12" class="headerlink" title="使用"></a>使用</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="built_in">self</span>.<span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"rw_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line">dispatch_async(<span class="built_in">self</span>.<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">       </span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line">dispatch_barrier_async(<span class="built_in">self</span>.<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">       </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>eg:</p>
<p><code>YZBarrier</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZBarrier.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZBarrier</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZBarrier</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">"rw_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="comment">// 写</span></span><br><span class="line">        dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="comment">// 读</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="comment">// 读</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"read"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"write"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZBarrier alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">45.867990</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324146</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">46.871969</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324146</span>] write</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">47.876419</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324146</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">47.876419</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324148</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">47.876450</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324145</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">48.880739</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324145</span>] write</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">49.885434</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324145</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">49.885435</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324146</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">49.885442</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324148</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">50.889361</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324148</span>] write</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">51.894104</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324148</span>] read</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">51.894104</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">30046</span>:<span class="number">324146</span>] read</span><br></pre></td></tr></table></figure>

<p>由结果可知，打印完<code>write</code>之后，方法每次都是一个一个执行的，而<code>read</code>是可以同时执行的，但是遇到写的操作，就会把其他读或者写都会暂停，也就是说起到了栅栏的作用。</p>
<h2 id="dispatch-group-t调度组"><a href="#dispatch-group-t调度组" class="headerlink" title="dispatch_group_t调度组"></a><code>dispatch_group_t</code>调度组</h2><p>前面说了这么多关于锁的使用，其实调度组也能达到类似栅栏的效果。</p>
<h3 id="api-3"><a href="#api-3" class="headerlink" title="api"></a>api</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建调度组</span></span><br><span class="line">dispatch_group_t group = dispatch<span class="constructor">_group_create()</span>;</span><br><span class="line"><span class="comment">//2.队列</span></span><br><span class="line">dispatch_queue_t queue = dispatch<span class="constructor">_get_global_queue(0, 0)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.调度组监听队列 标记开始本次执行</span></span><br><span class="line">dispatch<span class="constructor">_group_enter(<span class="params">group</span>)</span>;</span><br><span class="line"><span class="comment">//标记本次请求完成</span></span><br><span class="line">dispatch<span class="constructor">_group_leave(<span class="params">group</span>)</span>;</span><br><span class="line">          </span><br><span class="line"><span class="comment">//4,调度组都完成了</span></span><br><span class="line">dispatch<span class="constructor">_group_notify(<span class="params">group</span>, <span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line"><span class="comment">//执行刷新UI等操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>eg:</p>
<p><code>YZDispatchGroup</code>继承<code>YZBaseLock</code>，<code>otherTest</code>里面进行测试,假设的场景是，需要在子线程下载两个图片,sleep()模拟耗时操作，都下载完成之后，回到主线程刷新UI.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZDispatchGroup.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZDispatchGroup</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.创建调度组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="comment">//2.队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.调度组监听队列 标记开始本次执行</span></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       [<span class="keyword">self</span> downLoadImage1];</span><br><span class="line">        <span class="comment">//标记本次请求完成</span></span><br><span class="line">          dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调度组监听队列 标记开始本次执行</span></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> downLoadImage2];</span><br><span class="line">        <span class="comment">//标记本次请求完成</span></span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4,调度组都完成了</span></span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//执行完test1和test2之后，在进行请求test3</span></span><br><span class="line">         [<span class="keyword">self</span> reloadUI];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)downLoadImage1 &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s--%@"</span>,__func__,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)downLoadImage2 &#123;</span><br><span class="line">     sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s--%@"</span>,__func__,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)reloadUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s--%@"</span>,__func__,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZBaseLock *lock = <span class="comment">[<span class="comment">[YZBarrier alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[lock otherTest]</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">08</span>:<span class="number">35.651955</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">3353</span>:<span class="number">49583</span>] -[YZDispatchGroup downLoadImage1]--&lt;NSThread: <span class="number">0x6000033ed380</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">08</span>:<span class="number">36.648922</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">3353</span>:<span class="number">49584</span>] -[YZDispatchGroup downLoadImage2]--&lt;NSThread: <span class="number">0x6000033e0000</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">08</span>:<span class="number">36.649179</span>+<span class="number">0800</span> iOS-LockDemo[<span class="number">3353</span>:<span class="number">49521</span>] -[YZDispatchGroup reloadUI]--&lt;NSThread: <span class="number">0x6000033865c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>由结果可知，子线程耗时操作，现在图片时候，主线程刷新UI不执行的，等两个图片都下载完成，才回到主线程刷新UI.</p>
<h3 id="dispatch-group有两个需要注意的地方"><a href="#dispatch-group有两个需要注意的地方" class="headerlink" title="dispatch_group有两个需要注意的地方"></a><code>dispatch_group</code>有两个需要注意的地方</h3><ul>
<li>dispatch_group_enter必须在dispatch_group_leave之前出现</li>
<li>dispatch_group_enter和dispatch_group_leave必须成对出现</li>
</ul>
<h2 id="自旋锁，互斥锁的选择"><a href="#自旋锁，互斥锁的选择" class="headerlink" title="自旋锁，互斥锁的选择"></a>自旋锁，互斥锁的选择</h2><p>前面这么多锁，那么到底平时开发中怎么选择呢？其实主要参考如下标准来选择。</p>
<h3 id="什么情况使用自旋锁比较划算？"><a href="#什么情况使用自旋锁比较划算？" class="headerlink" title="什么情况使用自旋锁比较划算？"></a>什么情况使用自旋锁比较划算？</h3><ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li>CPU资源不紧张</li>
<li>多核处理器</li>
</ul>
<h3 id="什么情况使用互斥锁比较划算？"><a href="#什么情况使用互斥锁比较划算？" class="headerlink" title="什么情况使用互斥锁比较划算？"></a>什么情况使用互斥锁比较划算？</h3><ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ITyongzhen/iOS-ManyLocks" target="_blank" rel="noopener">本文资料下载github</a></p>
<p><a href="https://mjtsai.com/blog/2015/12/16/osspinlock-is-unsafe/" target="_blank" rel="noopener">OSSpinLock Is Unsafe</a></p>
<p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<p><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep源码地址</a></p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
<p><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>详解iOS中的Runtime</title>
    <url>/%E8%AF%A6%E8%A7%A3iOS%E4%B8%AD%E7%9A%84Runtime.html/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>本文较长，分为以下几个部分</p>
<ul>
<li>isa</li>
<li>class结构</li>
<li>Type Encoding</li>
<li><code>cache_t</code></li>
<li>方法调用</li>
<li>消息机制的三个阶段</li>
<li>消息发送</li>
<li>动态解析</li>
<li>消息转发</li>
<li>源码分析</li>
</ul>
<p>什么是runtime</p>
<p>苹果官方说法</p>
<blockquote>
<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime.<br>（尽量将决定放到运行的时候，而不是在编译和链接过程）</p>
</blockquote>
<h3 id="版本和平台"><a href="#版本和平台" class="headerlink" title="版本和平台"></a>版本和平台</h3><p>runtime是有个两个版本的: legacy 、 modern<br>在Objective-C 1.0使用的是legacy，在2.0使用的是modern。这里简单介绍下区别：</p>
<ul>
<li>在legacy runtime，如果你改变了实例变量的设计，需要重新编译它的子类。支持 32bit的OS X 程序</li>
<li>在modern runtime，如果你改变了实例变量的设计，不需要重新编译它的子类。支持iphone程序和OS X10.5之后的64bit程序</li>
</ul>
<p>现在一般来说runtime都是指modern</p>
<h2 id="isa详解"><a href="#isa详解" class="headerlink" title="isa详解"></a>isa详解</h2><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>要想学习Runtime，首先要了解它底层的一些常用数据结构，比如isa指针</p>
<p>在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址</p>
<p>从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。</p>
<p>查看<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a>可以看到关于isa结构。官方的源码是不能编译的。我自己编译了一份可以运行的源码在<a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos/tree/master/objc4-750-master" target="_blank" rel="noopener">github</a>上。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="regexp">//</span> defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在runtime723版本以前，直接把结构体放在isa里面了。750版本之后，抽成宏了，展开宏<code>ISA_BITFIELD</code> 在<code>__arm64__</code>架构下 如下所示</p>
<p>下面的代码对isa_t中的结构体进行了位域声明，地址从<code>nonpointer</code>起到<code>extra_rc</code>结束，从低到高进行排列。位域也是对结构体内存布局进行了一个声明，通过下面的结构体成员变量可以直接操作某个地址。位域总共占8字节，所有的位域加在一起正好是64位。</p>
<p>小提示：<code>union</code>中<code>bits</code>可以操作整个内存区，而位域只能操作对应的位。</p>
<p>eg: 一个对象的地址是<code>0x7faf1b580450</code> 转换成二进制<code>11111111010111100011011010110000000010001010000</code>,然后根据不同位置，去匹配不同的含义</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> define ISA_BITFIELD                                                      \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t nonpointer        : <span class="number">1</span>;   <span class="comment">//指针是否优化过                                   \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_assoc         : <span class="number">1</span>;   <span class="comment">//是否有设置过关联对象，如果没有，释放时会更快                                   \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_cxx_dtor      : <span class="number">1</span>; 	 <span class="comment">//是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快                                     \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t shiftcls          : <span class="number">33</span>; <span class="comment">//存储着Class、Meta-Class对象的内存地址信息 \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t magic             : <span class="number">6</span>;  <span class="comment">//用于在调试时分辨对象是否未完成初始化                                     \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">//是否有被弱引用指向过，如果没有，释放时会更快                                     \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t deallocating      : <span class="number">1</span>;  <span class="comment">//对象是否正在释放                                     \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">//引用计数器是否过大无法存储在isa中                                     \</span></span><br><span class="line">      <span class="built_in">uint</span>ptr_t extra_rc          : <span class="number">19</span> <span class="comment">//里面存储的值是引用计数器减1</span></span><br><span class="line">#   	define RC_ONE   (<span class="number">1</span>ULL&lt;&lt;<span class="number">45</span>)</span><br><span class="line">#   	define RC_HALF  (<span class="number">1</span>ULL&lt;&lt;<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h3 id="isa中不同的位域代表不同的含义。"><a href="#isa中不同的位域代表不同的含义。" class="headerlink" title="isa中不同的位域代表不同的含义。"></a>isa中不同的位域代表不同的含义。</h3><ul>
<li><p>nonpointer</p>
<ul>
<li>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1，代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li><p>has_assoc</p>
<ul>
<li>是否有设置过关联对象，如果没有，释放时会更快</li>
</ul>
</li>
<li><p>has_cxx_dtor</p>
<ul>
<li>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</li>
</ul>
</li>
<li><p>shiftcls</p>
<ul>
<li>存储着Class、Meta-Class对象的内存地址信息</li>
</ul>
</li>
<li><p>magic</p>
<ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li><p>weakly_referenced</p>
<ul>
<li>是否有被弱引用指向过，如果没有，释放时会更快</li>
</ul>
</li>
<li><p>deallocating</p>
<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li><p>extra_rc</p>
<ul>
<li>里面存储的值是引用计数器减1</li>
</ul>
</li>
<li><p>has_sidetable_rc</p>
<ul>
<li>引用计数器是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li>
</ul>
</li>
</ul>
<p>eg: 查看<code>objc_runtime-new.mm</code>文件中有如下代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void *objc<span class="constructor">_destructInstance(<span class="params">id</span> <span class="params">obj</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">//是否有C++的析构函数</span></span><br><span class="line">        <span class="built_in">bool</span> cxx = obj-&gt;has<span class="constructor">CxxDtor()</span>;</span><br><span class="line">        <span class="comment">//是否有设置过关联对象</span></span><br><span class="line">        <span class="built_in">bool</span> assoc = obj-&gt;has<span class="constructor">AssociatedObjects()</span>;</span><br><span class="line">        <span class="comment">//有C++的析构函数，就去销毁</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object<span class="constructor">_cxxDestruct(<span class="params">obj</span>)</span>;</span><br><span class="line">         <span class="comment">//有设置过关联对象，就去移除管理对象</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) <span class="constructor">_object_remove_assocations(<span class="params">obj</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        obj-&gt;clear<span class="constructor">Deallocating()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，释放时候，会先判断是否有设置过关联对象，如果没有，释放时会更快。<br>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快。其他的弱引用，nonpointer等，读者可自行看源码。</p>
<p>关Tagged Pointer技术，深入研究的话，可以参考唐巧博客<a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">深入理解Tagged Pointer</a></p>
<h2 id="class结构"><a href="#class结构" class="headerlink" title="class结构"></a>class结构</h2><p>用一幅图来表示</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202d8611c393?w=913&h=428&f=png&s=160446" alt=""></p>
<h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><p>查看源码(只保留了主要代码)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;    <span class="comment">//方法缓存</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// 用于获取具体的类的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说结构体<code>objc_class</code>里面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;    <span class="comment">//方法缓存</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// 用于获取具体的类的信息&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a><code>class_rw_t</code></h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202d8cb48997?w=870&h=251&f=png&s=52952" alt=""></p>
<p>根据bits可以得到<code>class_rw_t</code>，<code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</p>
<p>eg:方法列表methods中存放着很多一维数组<code>method_list_t</code>,而每一个<code>method_list_t</code>中存放这<code>method_t</code>,<code>method_t</code>中是对应方法的imp指针，名字。类型等方法信息,在<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3iOS%E4%B8%AD%E5%88%86%E7%B1%BBCateogry.html">详解iOS中分类Cateogry</a>一文中，我们知道，每个分类编译完成之后都会生成一个<code>_category_t</code>,对应着<code>method_list_t</code>。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"></span><br><span class="line"><span class="title">class_rw_t</span> *<span class="class"><span class="keyword">data</span>() &#123; </span></span><br><span class="line"><span class="class">   <span class="title">return</span> <span class="title">bits</span>.<span class="title">data</span>();</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">class_rw_t</span>* <span class="class"><span class="keyword">data</span>() &#123;</span></span><br><span class="line"><span class="class">   <span class="title">return</span> (<span class="title">class_rw_t</span> *)(<span class="title">bits</span> &amp; <span class="type">FAST_DATA_MASK</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>由代码可知 <code>bits &amp; FAST_DATA_MASK</code>可获得<code>class_rw_t</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods; <span class="comment">//方法列表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties; <span class="comment">//属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols; <span class="comment">// 协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体<code>method_array_t</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">method_array_t</span> :</span> </span><br><span class="line">    <span class="keyword">public</span> list_array_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_array_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>&gt; Super;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">method_list_t</span> **beginCategoryMethodLists() &#123;</span><br><span class="line">        <span class="keyword">return</span> beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_list_t</span> **endCategoryMethodLists(Class cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> duplicate() &#123;</span><br><span class="line">        <span class="keyword">return</span> Super::duplicate&lt;<span class="keyword">method_array_t</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a><code>method_t</code></h3><p><code>method_t</code>是对方法、函数的封装</p>
<ul>
<li>IMP<ul>
<li>IMP代表函数的具体实现</li>
</ul>
</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">// <span class="type">IMP</span>代表函数的具体实现</span><br><span class="line">typedef id _Nullable (*<span class="type">IMP</span>)(id _Nonnull, <span class="type">SEL</span> _Nonnull, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SEL</p>
<ul>
<li>SEL代表方法、函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</li>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>types包含了函数返回值、参数编码的字符串</p>
<ul>
<li>返回值 参数1    参数2    ……    参数n</li>
<li>eg: <code>v16@0:8</code>代表，返回值void类型，第一个参数是id类型，第二个参数是SEL类型。后面会详细说明。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name; <span class="comment">//函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">//编码(返回值类型，参数类型)</span></span><br><span class="line">    MethodListIMP imp; <span class="comment">//指向函数的指针(函数地址)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建两个不同的类，并定义两个相同的方法，通过@selector()获取SEL并打印。可以发现SEL都是同一个对象，地址都是相同的。由此证明，不同类的相同SEL是同一个对象。</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">TestObject </span>: NSObject</span><br><span class="line">- (void)testMethod;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">TestObject2 </span>: NSObject</span><br><span class="line">- (void)testMethod;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestObject实现文件</span></span><br><span class="line"><span class="variable">@implementation</span> TestObject</span><br><span class="line">- (void)testMethod &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"TestObject testMethod %p"</span>, <span class="variable">@selector</span>(testMethod));</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestObject2实现文件也一样</span></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">TestObject</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">testMethod</span> &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"TestObject testMethod %p"</span>, <span class="variable">@selector</span>(testMethod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="selector-tag">TestObject</span> <span class="selector-tag">testMethod</span> <span class="selector-tag">0x100000f81</span></span><br><span class="line"><span class="selector-tag">TestObject2</span> <span class="selector-tag">testMethod</span> <span class="selector-tag">0x100000f81</span></span><br></pre></td></tr></table></figure>


<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a><code>class_ro_t</code></h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202d8cc20f9b?w=879&h=217&f=png&s=54481" alt=""></p>
<p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;<span class="comment">//instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name; <span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">//方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols; <span class="comment">//协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars; <span class="comment">//成员变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Type-Encoding"><a href="#Type-Encoding" class="headerlink" title="Type Encoding"></a>Type Encoding</h2><p>前面说了，<code>v16@0:8</code>代表，返回值void类型，第一个参数是id类型，第二个参数是SEL类型。这里详细说明</p>
<p>iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码，链接为 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings
</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202d97dfc415?w=880&h=368&f=png&s=60370" alt=""></p>
<p>eg: 我们有如下函数</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_msgSend(<span class="keyword">id</span> receiver, SEL selector)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找缓存</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以用<code>v16@0:8</code>表示</p>
<ul>
<li>其中返回值void类型，第一个参数是id类型，第二个参数是SEL类型。</li>
<li>另外第一个数字16代表总共16个字节，0代表第一个参数从第0个字节开始，8代表第二个参数从第8个字节开始。</li>
<li>其实也可以简写为<code>v@:</code>，这在后面讲到消息转发的时候会用到。</li>
</ul>
<p>再如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="literal">[<span class="identifier">super</span> <span class="identifier">viewDidLoad</span>]</span>;</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    Method <span class="keyword">method</span> = <span class="keyword">class</span><span class="constructor">_getClassMethod([<span class="params">self</span> <span class="params">class</span>], @<span class="params">selector</span>(<span class="params">test</span>)</span>);</span><br><span class="line">    const <span class="built_in">char</span> *str = <span class="keyword">method</span><span class="constructor">_getTypeEncoding(<span class="params">method</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    Method method2 = <span class="keyword">class</span><span class="constructor">_getClassMethod([<span class="params">self</span> <span class="params">class</span>], @<span class="params">selector</span>(<span class="params">testWithNum</span>:)</span>);</span><br><span class="line">    const <span class="built_in">char</span> *str2 = <span class="keyword">method</span><span class="constructor">_getTypeEncoding(<span class="params">method2</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"test的类型 = %s "</span>,<span class="params">str</span>)</span>;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"testWithNum: = %s "</span>,<span class="params">str2</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v16@0:8 </span></span><br><span class="line">+(void)test&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i20@0:8i16</span></span><br><span class="line">+(<span class="built_in">int</span>)testWithNum:(<span class="built_in">int</span>)num&#123;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<blockquote>
<p>RuntimeDemo[28247:303205] test的类型 = v16@0:8<br>RuntimeDemo[28247:303205] testWithNum: = i20@0:8i16</p>
</blockquote>
<p>对于方法<code>testWithNum</code>来说</p>
<ul>
<li>i表示返回值是int类型，20是参数总共20字节</li>
<li>@表示第一个参数是id类型，0表示第一个参数从第0个字节开始 </li>
<li>:表示第二个参数是SEL类型。8表示第二个参数从第8个字节开始。</li>
<li>i表示第三个参数是int类型，16表示第三个参数从第16个字节开始</li>
<li>第三个参数从第16个字节开始，是Int类型，占用4字节。总共20字节</li>
</ul>
<p>@encode</p>
<h2 id="方法缓存cache-t"><a href="#方法缓存cache-t" class="headerlink" title="方法缓存cache_t"></a>方法缓存<code>cache_t</code></h2><p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202d97beb789?w=855&h=235&f=png&s=56387" alt=""></p>
<p>前面讲了Class内部结构,其中有个方法缓存<code>cache_t</code>，用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">//散列表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask; <span class="comment">//散列表的长度 -1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied; <span class="comment">//已经缓存的方法数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>散列表数组<code>_buckets</code>中存放着<code>bucket_t</code>,<code>bucket_t</code>的结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">     MethodCacheIMP _imp; <span class="comment">//函数的内存地址</span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;   <span class="comment">//SEL作为Key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="散列表cache-t查找原理"><a href="#散列表cache-t查找原理" class="headerlink" title="散列表cache_t查找原理"></a>散列表<code>cache_t</code>查找原理</h3><p>在<code>cache_t</code>中如何查找方法，其实对于其他散列表也是通用的。</p>
<p>在文件<code>objc-cache.mm</code>中找到<code>bucket_t * cache_t::find(cache_key_t k, id receiver)</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 散列表中查找方法缓存</span></span><br><span class="line"><span class="keyword">bucket_t</span> * <span class="keyword">cache_t</span>::<span class="built_in">find</span>(<span class="keyword">cache_key_t</span> k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = mask();</span><br><span class="line">    <span class="keyword">mask_t</span> <span class="built_in">begin</span> = cache_hash(k, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != <span class="built_in">begin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，根据<code>key</code>和散列表长度减1 <code>mask</code> 计算出下标 <code>key &amp; mask</code>，取出的值如果key和当初传进来的Key相同，就说明找到了。否则，就不是自己要找的方法，就有了hash冲突，把i的值加1，继续计算。如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算下标</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_hash</span><span class="params">(<span class="keyword">cache_key_t</span> key, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(key &amp; mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//hash冲突的时候</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cache-t的扩容"><a href="#cache-t的扩容" class="headerlink" title="cache_t的扩容"></a><code>cache_t</code>的扩容</h3><p>当方法缓存太多的时候，超过了容量的3/4s时候，就需要扩容了。扩容是，把原来的容量增加为2倍</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void cache<span class="constructor">_fill_nolock(Class <span class="params">cls</span>, SEL <span class="params">sel</span>, IMP <span class="params">imp</span>, <span class="params">id</span> <span class="params">receiver</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">			...</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;is<span class="constructor">ConstantEmptyCache()</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity<span class="operator"> / </span><span class="number">4</span><span class="operator"> * </span><span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 来到这里说明，超过了3/4,需要扩容</span></span><br><span class="line">        cache-&gt;expand<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  		 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体扩容代码为</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache_t的扩容</span></span><br><span class="line">void cache_t:<span class="type"></span>:expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity = capacity();</span><br><span class="line">    <span class="comment">// 扩容为原来的2倍</span></span><br><span class="line">    uint32_t <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity ? oldCapacity*<span class="number">2</span> : <span class="type">INIT_CACHE_SIZE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uint32_t)(mask_t)<span class="keyword">new</span><span class="type">Capacity</span> != <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can't grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>我们经常写的OC方法调用，究竟是怎么个调用流程，怎么找到方法的呢？</p>
<p>我们如下代码</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *per = <span class="comment">[<span class="comment">[Person alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[per test]</span>;</span><br></pre></td></tr></table></figure>

<p>执行指令</p>
<blockquote>
<p>clang -rewrite-objc main.m -o main.cpp</p>
</blockquote>
<p>生成cpp文件，对应上面的代码为</p>
<figure class="highlight hy"><table><tr><td class="code"><pre><span class="line">((<span class="name">void</span> (<span class="name"><span class="builtin-name">*</span></span>)(<span class="name"><span class="builtin-name">id</span></span>, SEL))(<span class="name">void</span> *)objc_msgSend)((<span class="name"><span class="builtin-name">id</span></span>)per, sel_registerName(<span class="string">"test"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>简化为</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">objc_msgSend</span>)(per, sel_registerName(<span class="string">"test"</span>));</span><br></pre></td></tr></table></figure>


<p>其中，per称为消息接收者(receiver), test称为消息名称，也就是说，OC中方法的调用其实都是转换为objc_msgSend函数的调用</p>
<h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><h3 id="三大阶段"><a href="#三大阶段" class="headerlink" title="三大阶段"></a>三大阶段</h3><p>OC中的方法调用，其实都是转换为<code>objc_msgSend</code>函数的调用</p>
<p>objc_msgSend的执行流程可以分为3大阶段</p>
<ul>
<li><p>消息发送</p>
</li>
<li><p>动态方法解析</p>
</li>
<li><p>消息转发</p>
</li>
</ul>
<p>运行时期，调用方法流程为</p>
<p>实例对象中存放 isa 指针以及实例变量，有 isa 指针可以找到实例对象所属的类对象 (类也是对象，面向对象中一切都是对象)，类中存放着实例方法列表，在这个方法列表中 SEL 作为 key，IMP 作为 value。 在编译时期，根据方法名字会生成一个唯一标识，这个标识就是 SEL。IMP 其实就是函数指针 指向了最终的函数实现。整个 Runtime 的核心就是 objc_msgSend 函数，通过给类发送 SEL 以传递消息，找到匹配的 IMP 再获取最终的实现</p>
<p>类中的 <code>super_class</code> 指针可以追溯整个继承链。向一个对象发送消息时，Runtime 会根据实例对象的 isa 指针找到其所属的类，并自底向上直至根类(NSObject)中 去寻找 SEL 所对应的方法，找到后就运行整个方法。</p>
<p>用一张经典的图来表示就是</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202d97f29bae?w=587&h=589&f=png&s=103456" alt=""></p>
<p>类中的 super_class 指针可以追溯整个继承链。向一个对象发送消息时，Runtime 会根据实例对象的 isa 指针找到其所属的类，并自底向上直至根类(NSObject)中 去寻找 SEL 所对应的方法，找到后就运行整个方法。</p>
<p>metaClass是元类，也有 isa 指针、super_class 指针。其中保存了类方法列表。</p>
<h3 id="跟读源码顺序"><a href="#跟读源码顺序" class="headerlink" title="跟读源码顺序"></a>跟读源码顺序</h3><p><code>objc-msg-arm64.s</code>里面都是汇编</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">objc-msg-arm64.s</span><br><span class="line">ENTRY _objc_msgSend</span><br><span class="line">b.le	LNilOrTagged</span><br><span class="line">CacheLookup NORMAL</span><br><span class="line"><span class="function">.<span class="keyword">macro</span> <span class="title">CacheLookup</span></span></span><br><span class="line"><span class="function">.<span class="keyword">macro</span> <span class="title">CheckMiss</span></span></span><br><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line"><span class="function">.<span class="keyword">macro</span> <span class="title">MethodTableLookup</span></span></span><br><span class="line">__class_lookupMethodAndLoadCache3</span><br></pre></td></tr></table></figure>

<p><code>objc-runtime-new.mm</code></p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">objc-runtime-<span class="keyword">new</span>.mm</span><br><span class="line"><span class="number">_</span><span class="keyword">class</span><span class="number">_</span>lookupMethodAndLoadCache<span class="number">3</span></span><br><span class="line">lookUpImpOrForward</span><br><span class="line">getMethodNoSuper<span class="number">_n</span>olock、search<span class="number">_m</span>ethod<span class="number">_</span>list、log<span class="number">_</span>and<span class="number">_f</span>ill<span class="number">_</span>cache</span><br><span class="line">cache<span class="number">_</span>getImp、log<span class="number">_</span>and<span class="number">_f</span>ill<span class="number">_</span>cache、getMethodNoSuper<span class="number">_n</span>olock、log<span class="number">_</span>and<span class="number">_f</span>ill<span class="number">_</span>cache</span><br><span class="line"><span class="number">_</span><span class="keyword">class</span><span class="number">_</span>resolveInstanceMethod</span><br><span class="line"><span class="number">_</span>objc<span class="number">_m</span>sgForward<span class="number">_</span>impcache</span><br></pre></td></tr></table></figure>


<p>一直跟到 <code>__forwarding__</code>的时候，已经不开源的了。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">objc-msg-arm64.s</span></span><br><span class="line"><span class="attr">STATIC_ENTRY</span> <span class="string">__objc_msgForward_impcache</span></span><br><span class="line"><span class="attr">ENTRY</span> <span class="string">__objc_msgForward</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Core</span> <span class="string">Foundation</span></span><br><span class="line"><span class="attr">__forwarding__（不开源</span></span><br></pre></td></tr></table></figure>

<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="_objc_msgSend"></a><code>_objc_msgSend</code></h3><p>先来看 <code>objc-msg-arm64.s</code></p>
<p>主要代码为</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//1.进入objcmsgSend</span></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line">    <span class="comment">// x0 recevier</span></span><br><span class="line">    <span class="comment">// 消息接收者  消息名称</span></span><br><span class="line">	cmp	p0, #<span class="number">0</span>			<span class="comment">// nil check and tagged pointer check</span></span><br><span class="line"><span class="selector-id">#if</span> SUPPORT_TAGGED_POINTERS</span><br><span class="line">    <span class="comment">//2.isa 优化</span></span><br><span class="line">	<span class="selector-tag">b</span><span class="selector-class">.le</span>	LNilOrTagged		<span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">	<span class="selector-tag">b</span><span class="selector-class">.eq</span>	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	ldr	p13, [x0]		<span class="comment">// p13 = isa</span></span><br><span class="line">	GetClassFromIsa_p16 p13		<span class="comment">// p16 = class</span></span><br><span class="line">LGetIsaDone: <span class="comment">// 3.isa优化完成</span></span><br><span class="line">	CacheLookup NORMAL		<span class="comment">//4.执行 CacheLookup NORMAL // calls imp or objc_msgSend_uncached</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#if</span> SUPPORT_TAGGED_POINTERS</span><br><span class="line">LNilOrTagged:</span><br><span class="line">	<span class="selector-tag">b</span><span class="selector-class">.eq</span>	LReturnZero		<span class="comment">// nil check</span></span><br><span class="line"></span><br><span class="line">...省略很多代码</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.macro</span> MethodTableLookup</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// push frame</span></span><br><span class="line">	SignLR</span><br><span class="line">	stp	fp, lr, [sp, #-<span class="number">16</span>]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	...省略很多代码</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// receiver and selector already in x0 and x1</span></span><br><span class="line">	mov	x2, x16</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3 <span class="comment">//方法为_class_lookupMethodAndLoadCache3调用的汇编语言</span></span><br><span class="line"></span><br><span class="line">	...省略很多代码</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">	<span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line">	<span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line">	</span><br><span class="line">	MethodTableLookup <span class="comment">//查找IMP</span></span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgLookup_uncached</span><br><span class="line">	UNWIND __objc_msgLookup_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">	<span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line">	<span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line">	</span><br><span class="line">	MethodTableLookup</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgLookup_uncached</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY _cache_getImp</span><br><span class="line"></span><br><span class="line">	GetClassFromIsa_p16 p0</span><br><span class="line">	CacheLookup GETIMP</span><br><span class="line">	...省略很多代码</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出方法查找 IMP 的工作交给了 OC 中的 _class_lookupMethodAndLoadCache3 函数，并将 IMP 返回（从 r11 挪到 rax）。最后在 objc_msgSend 中调用 IMP。</p>
<p>汇编代码比较晦涩难懂，因此这里将函数的实现反汇编成C语言的伪代码：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">objc_msgSend的C语言版本伪代码实现.</span></span><br><span class="line"><span class="comment">receiver: 是调用方法的对象</span></span><br><span class="line"><span class="comment">op: 是要调用的方法名称字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">id  <span class="built_in">objc_msgSend</span>(id receiver, SEL op, ...)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1............................ 对象空值判断。</span></span><br><span class="line">    <span class="comment">//如果传入的对象是nil则直接返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (receiver == nil)</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2............................ 获取或者构造对象的isa数据。</span></span><br><span class="line">    void *isa = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="comment">//如果对象的地址最高位为0则表明是普通的OC对象，否则就是Tagged Pointer类型的对象</span></span><br><span class="line">    <span class="keyword">if</span> ((receiver &amp; <span class="number">0x8000000000000000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="type">objc_object</span>  *ocobj = (<span class="keyword">struct</span> <span class="type">objc_object</span>*) receiver;</span><br><span class="line">        isa = ocobj-&gt;isa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//Tagged Pointer类型的对象中没有直接保存isa数据，所以需要特殊处理来查找对应的isa数据。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果对象地址的最高4位为0xF, 那么表示是一个用户自定义扩展的Tagged Pointer类型对象</span></span><br><span class="line">        <span class="keyword">if</span> (((NSUInteger) receiver) &gt;= <span class="number">0xf000000000000000</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//自定义扩展的Tagged Pointer类型对象中的52-59位保存的是一个全局扩展Tagged Pointer类数组的索引值。</span></span><br><span class="line">            int  classidx = (receiver &amp; <span class="number">0xFF0000000000000</span>) &gt;&gt; <span class="number">52</span></span><br><span class="line">            isa =  objc_debug_taggedpointer_ext_classes[classidx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//系统自带的Tagged Pointer类型对象中的60-63位保存的是一个全局Tagged Pointer类数组的索引值。</span></span><br><span class="line">            int classidx = ((NSUInteger) receiver) &gt;&gt; <span class="number">60</span>;</span><br><span class="line">            isa  =  objc_debug_taggedpointer_classes[classidx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//因为内存地址对齐的原因和虚拟内存空间的约束原因，</span></span><br><span class="line">   <span class="comment">//以及isa定义的原因需要将isa与上0xffffffff8才能得到对象所属的Class对象。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">objc_class</span>  *cls = (<span class="keyword">struct</span> <span class="type">objc_class</span> *)(isa &amp; <span class="number">0xffffffff8</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//3............................ 遍历缓存哈希桶并查找缓存中的方法实现。</span></span><br><span class="line">    IMP  imp = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="comment">//cmd与cache中的mask进行与计算得到哈希桶中的索引，来查找方法是否已经放入缓存cache哈希桶中。</span></span><br><span class="line">    int index =  <span class="keyword">cls</span>-&gt;cache.mask &amp; op;</span><br><span class="line">    <span class="keyword">while</span> (true) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果缓存哈希桶中命中了对应的方法实现，则保存到imp中并退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">cls</span>-&gt;cache.buckets[index].key == op) &#123;</span><br><span class="line">              imp = <span class="keyword">cls</span>-&gt;cache.buckets[index].imp;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法实现并没有被缓存，并且对应的桶的数据是空的就退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">cls</span>-&gt;cache.buckets[index].key == <span class="built_in">NULL</span>) &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果哈希桶中对应的项已经被占用但是又不是要执行的方法，则通过开地址法来继续寻找缓存该方法的桶。</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="keyword">cls</span>-&gt;cache.mask;  <span class="comment">//从尾部寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            index--;   <span class="comment">//索引减1继续寻找。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/*end while*/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//4............................ 执行方法实现或方法未命中缓存处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (imp != <span class="built_in">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">imp</span>(receiver, op,  ...); <span class="comment">//这里的... 是指传递给objc_msgSend的OC方法中的参数。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">objc_msgSend_uncached</span>(receiver, op, cls, ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  方法未命中缓存处理函数：objc_msgSend_uncached的C语言版本伪代码实现，这个函数也是用汇编语言编写。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">id <span class="built_in">objc_msgSend_uncached</span>(id receiver, SEL op, struct objc_class *cls)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//这个函数很简单就是直接调用了_class_lookupMethodAndLoadCache3 来查找方法并缓存到struct objc_class中的cache中，最后再返回IMP类型。</span></span><br><span class="line">  IMP  imp =   <span class="built_in">_class_lookupMethodAndLoadCache3</span>(receiver, op, cls);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">imp</span>(receiver, op, ....);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="消息发送阶段"><a href="#消息发送阶段" class="headerlink" title="消息发送阶段"></a>消息发送阶段</h2><p>前面跟到<code>_class_lookupMethodAndLoadCache3</code>之后，后面就不是汇编了，是C语言的实现</p>
<ul>
<li>runtime的消息发送阶段，首先判断receiver是否为空，如果为空就直接返回</li>
<li>如果不为空，从receiverClass的缓存中，查找方法，如果找到了，就调用方法</li>
<li>如果没找到，就从receiverClass的<code>class_rw_t</code>中查找方法(分为二分查找和线性查找，两种),如果找到了，就结束查找，缓存一份到自己缓存中，调用方法</li>
<li>如果没找到，就去父类的缓存中查找，如果找到了，就就结束查找，缓存一份到自己缓存中，调用方法</li>
<li>如果没找到，就从父类的<code>class_rw_t</code>中查找方法,如果找到了，就结束查找，缓存一份到自己缓存中，调用方法</li>
<li>如果没找到，就看是否还有父类，如果有，就继续查父类的缓存，方法列表</li>
<li>如果没有父类，说明消息发送阶段结束，那么就进入第二阶段，动态方法解析阶段。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202df83d016f?w=830&h=399&f=png&s=108439" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="keyword">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码在<code>lookUpImpOrForward</code>里面，下面的代码,增加了注释</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class <span class="keyword">cls</span>, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil<span class="comment">;</span></span><br><span class="line">    bool triedResolver = NO<span class="comment">; //是否动态解析过的标记</span></span><br><span class="line">    runtimeLock.assertUnlocked()<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(<span class="keyword">cls</span>, sel)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock()<span class="comment">;</span></span><br><span class="line">    checkIsKnownClass(<span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(<span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !<span class="keyword">cls</span>-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock()<span class="comment">;</span></span><br><span class="line">        _class_initialize (_class_getNonMetaClass(<span class="keyword">cls</span>, inst))<span class="comment">;</span></span><br><span class="line">        runtimeLock.lock()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里先查缓存，虽然前面汇编里面已经查过了。但是有可能动态添加，导致缓存有更新</span></span><br><span class="line">    imp = cache_getImp(<span class="keyword">cls</span>, sel)<span class="comment">;</span></span><br><span class="line">    <span class="comment">//如果查到了，就直接跳转到最后</span></span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done<span class="comment">;</span></span><br><span class="line">    <span class="comment">//来到这里，说明缓存没有</span></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line">    &#123; <span class="comment">// 查找方法列表</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(<span class="keyword">cls</span>, sel)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(<span class="keyword">cls</span>, meth-&gt;imp, sel, inst, <span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">            imp = meth-&gt;imp<span class="comment">;</span></span><br><span class="line">            <span class="comment">//如果查到了，就直接跳转到最后</span></span><br><span class="line">            <span class="keyword">goto</span> done<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">    &#123; <span class="comment">//查找父类的缓存和方法列表</span></span><br><span class="line">        unsigned attempts = unreasonableClassCount()<span class="comment">;</span></span><br><span class="line">        <span class="comment">// for循环层层向上找</span></span><br><span class="line">        <span class="keyword">for</span> (Class curClass = <span class="keyword">cls</span>-&gt;superclass<span class="comment">;</span></span><br><span class="line">             curClass != nil<span class="comment">;</span></span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            <span class="comment">// 父类缓存</span></span><br><span class="line">            imp = cache_getImp(curClass, sel)<span class="comment">;</span></span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类缓存有，也要缓存一份到自己的缓存中</span></span><br><span class="line">                    log_and_fill_cache(<span class="keyword">cls</span>, imp, sel, inst, curClass)<span class="comment">;</span></span><br><span class="line">                    <span class="comment">//跳转到最后</span></span><br><span class="line">                    <span class="keyword">goto</span> done<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span><span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list. 查找父类方法列表</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel)<span class="comment">;</span></span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                <span class="comment">/// 如果父类方法列表有，也要缓存一份到自己的缓存中</span></span><br><span class="line">                log_and_fill_cache(<span class="keyword">cls</span>, meth-&gt;imp, sel, inst, curClass)<span class="comment">;</span></span><br><span class="line">                imp = meth-&gt;imp<span class="comment">;</span></span><br><span class="line">                <span class="comment">//如果查到了，就跳转到最后</span></span><br><span class="line">                <span class="keyword">goto</span> done<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来到这里，进入第二阶段，动态方法解析阶段,而且要求没有动态解析过</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock()<span class="comment">;</span></span><br><span class="line">        _class_resolveMethod(<span class="keyword">cls</span>, sel, inst)<span class="comment">;</span></span><br><span class="line">        runtimeLock.lock()<span class="comment">;</span></span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES<span class="comment">; //动态解析过，标记设为YES</span></span><br><span class="line">        <span class="comment">// 回到查找缓存的地方开始查找，缓存中没有加过，这次去查找，可以再方法列表中查到</span></span><br><span class="line">        <span class="keyword">goto</span> retry<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来到这里，说明进入第三阶段，消息转发阶段</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache<span class="comment">;</span></span><br><span class="line">    cache_fill(<span class="keyword">cls</span>, sel, imp, inst)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock()<span class="comment">;</span></span><br><span class="line">    <span class="comment">// 返回方法地址</span></span><br><span class="line">    <span class="keyword">return</span> imp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>前面的消息发送阶段，没有找到，就来到动态方法解析阶段</p>
<p>头文件中定义两个方法</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">- (<span class="name">void</span>)test<span class="comment">;</span></span><br><span class="line">- (<span class="name">void</span>)run<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>只实现test</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(void)</span>test&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog<span class="params">(@<span class="string">"%s"</span>,__func__)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Person</span> *per = <span class="comment">[<span class="comment">[Person alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[per run]</span>;</span><br></pre></td></tr></table></figure>

<p>由前面的消息发送阶段知道，去查缓存，查方法列表，查父类等等，这些操作之后，都没有找到这个方法的实现，如果后面不做处理，必然抛出异常</p>
<p>报错方法找不到</p>
<blockquote>
<p>Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[Person run]: unrecognized selector sent to instance 0x100f436c0’</p>
</blockquote>
<p>如果要处理的话，消息发送阶段处理不了。那么就来到第二阶段，动态解析阶段。这个阶段的处理，从前面的源码可知</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态方法解析</span></span><br><span class="line">void _class_resolveMethod(Class <span class="keyword">cls</span>, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">cls</span>-&gt;isMetaClass()) &#123; <span class="comment">//如果不是元类对象</span></span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveInstanceMethod(<span class="keyword">cls</span>, sel, inst)<span class="comment">;</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 是元类对象</span></span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(<span class="keyword">cls</span>, sel, inst)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(<span class="keyword">cls</span>, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(<span class="keyword">cls</span>, sel, inst)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统默认的<code>resolveClassMethod</code>和<code>resolveInstanceMethod</code>默认返回NO</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在动态解析阶段，重写<code>resolveInstanceMethod</code>并添加方法的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (sel == <span class="meta">@selector(run)</span>) &#123;</span><br><span class="line">             <span class="comment">// 获取其他方法 实例方法，或者类方法都可以</span></span><br><span class="line">            Method method = class_getInstanceMethod(self, <span class="meta">@selector(test)</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 动态添加test方法的实现</span></span><br><span class="line">            class_addMethod(self, sel,</span><br><span class="line">                            method_getImplementation(method),</span><br><span class="line">                            method_getTypeEncoding(method));</span><br><span class="line">			<span class="comment">//等价于下面的</span></span><br><span class="line">			<span class="comment">// class_addMethod(self, sel,</span></span><br><span class="line">                         method_getImplementation(method),</span><br><span class="line">                         <span class="string">"v@:"</span>);</span><br><span class="line">				</span><br><span class="line">            <span class="comment">// 返回YES代表有动态添加方法  其实这里返回NO，也是可以的，返回YES只是增加了一些打印</span></span><br><span class="line">            <span class="keyword">return</span> NO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码中，因为<code>-(void)test</code>无参无返回值，函数类型为<code>v@:</code>，所以，上面的<code>method_getTypeEncoding(method)</code>可以换成<code>&quot;v@:&quot;</code>也是没问题的。</p>
<p>这样的话，就相当于，调用run的时候，实际上调用的是test。由源码可知，动态解析完之后，回到查找缓存的地方开始查找，缓存中没有加过，这次去查找，可以再方法列表中查到。这样就可以正确执行了。输出结果为</p>
<blockquote>
<p>objc-test[6681:75992] -[Person test]</p>
</blockquote>
<p>直接运行源码，如下图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202e44698b78?w=1580&h=778&f=png&s=767693" alt=""></p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>如果前面消息发送和动态解析阶段，对方法都没有处理，我们还有最后一个阶段，消息转发阶段来处理。从源码的<code>imp = (IMP)_objc_msgForward_impcache;</code>可以看出，<code>_objc_msgForward_impcache</code>的代码是在汇编里面</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">STATIC_ENTRY <span class="variable">__objc_msgForward_impcache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No stret specialization.</span></span><br><span class="line">b	<span class="variable">__objc_msgForward</span></span><br><span class="line"></span><br><span class="line">END_ENTRY <span class="variable">__objc_msgForward_impcache</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">ENTRY <span class="variable">__objc_msgForward</span></span><br><span class="line"></span><br><span class="line">adrp	x17, <span class="variable">__objc_forward_handler</span>@PAGE</span><br><span class="line"><span class="comment">// 这里进去之后，不开源了</span></span><br><span class="line">ldr	p17, [x17, <span class="variable">__objc_forward_handler</span>@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line">... 还有很多代码</span><br></pre></td></tr></table></figure>


<p>跟到 <code>___forwarding___</code>之后就不开源了</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">objc-test[<span class="number">15568</span>:<span class="number">163497</span>] *** Terminating app due to uncaught exception <span class="string">'NSInvalidArgumentException'</span>, reason: <span class="string">'-[Person run]: unrecognized selector sent to instance 0x100f039f0'</span></span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">	<span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff307de063</span> __exceptionPreprocess + <span class="number">250</span></span><br><span class="line">	<span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x000000010038ec9f</span> objc_exception_throw + <span class="number">47</span></span><br><span class="line">	<span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff308671bd</span> -[NSObject(NSObject) __retain_OA] + <span class="number">0</span></span><br><span class="line">	<span class="number">3</span>   CoreFoundation                      <span class="number">0x00007fff307844b4</span> ___forwarding___ + <span class="number">1427</span></span><br><span class="line">	<span class="number">4</span>   CoreFoundation                      <span class="number">0x00007fff30783e98</span> _CF_forwarding_prep_0 + <span class="number">120</span></span><br><span class="line">	<span class="number">5</span>   objc-test                           <span class="number">0x0000000100000e11</span> main + <span class="number">97</span></span><br><span class="line">	<span class="number">6</span>   libdyld.dylib                       <span class="number">0x00007fff672e93f9</span> start + <span class="number">1</span></span><br><span class="line">	<span class="number">7</span>   ???                                 <span class="number">0x0000000000000001</span> <span class="number">0x0</span> + <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure>

<p>在上述调用栈中，发现了在 Core Foundation 中会调用<code>___forwarding___</code>。根据资料也可以了解到，在 <code>objc_setForwardHandler</code> 时会传入 <code>__CF_forwarding_prep_0</code> 和 <code>___forwarding_prep_1___</code> 两个参数，而这两个指针都会调用<code>____forwarding___</code>。这个函数中，也交代了消息转发的逻辑</p>
<p>接下来怎么办呢？可以通过汇编调试，或逆向来进一步分析后续的实现。</p>
<blockquote>
<p>站在前人的代码上，能看的更远             —鲁迅.尼古拉斯</p>
</blockquote>
<h3 id="forwarding-的实现"><a href="#forwarding-的实现" class="headerlink" title="___forwarding___的实现"></a><code>___forwarding___</code>的实现</h3><p>国外有大神复原了<code>___forwarding___</code>的实现，具体可参考<a href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled" target="_blank" rel="noopener">Hmmm, What’s that Selector?</a></p>
<p>需要注意的是，复原了<code>___forwarding___</code>的实现是伪代码。具体代码我已经放在了<a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos/tree/master/objc4-750-master" target="_blank" rel="noopener">github</a>上。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> 伪代码</span><br><span class="line"><span class="comment">// 两个参数：前者为被转发消息的栈指针 IMP ，后者为是否返回结构体</span></span><br><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">    <span class="keyword">id</span> receiver = *(<span class="keyword">id</span> *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">    <span class="comment">// 进入 备援接收 主要步骤</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        <span class="comment">// 获得方法签名</span></span><br><span class="line">        <span class="keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        <span class="comment">// 判断返回类型是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStret == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 僵尸对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(receiverClass);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *zombiePrefix = <span class="string">"_NSZombie_"</span>;</span><br><span class="line">    size_t prefixLen = strlen(zombiePrefix); <span class="comment">// 0xa</span></span><br><span class="line">    <span class="keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelError,</span><br><span class="line">              <span class="string">@"*** -[%s %s]: message sent to deallocated instance %p"</span>,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">    <span class="comment">// 进入消息转发系统</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(methodSignatureForSelector:))) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        <span class="comment">// 判断返回类型是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">                <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">                      <span class="string">@"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s."</span>,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? <span class="string">""</span> : not,</span><br><span class="line">                      isStret ? <span class="string">""</span> : not);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardInvocation:))) &#123;</span><br><span class="line">                <span class="comment">// 传入消息的全部细节信息</span></span><br><span class="line">                <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line">                </span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">                      <span class="string">@"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message"</span>,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SEL *registeredSel = sel_getUid(selName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// selector 是否已经在 Runtime 注册过</span></span><br><span class="line">    <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort"</span>,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125;  <span class="comment">// doesNotRecognizeSelector，主动抛出异常</span></span><br><span class="line">    <span class="comment">// 表明未能得到处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass,<span class="keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort"</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The point of no return.</span></span><br><span class="line">    kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>消息转发阶段，先判断<code>forwardingTargetForSelector</code>的返回值，如果有值，就向这个返回值发送消息。也就是<code>objc_msgSend(返回值, SEL)</code>。</li>
<li>如果返回为nil,就调用<code>methodSignatureForSelector</code>方法，如果有值，就调用<code>forwardInvocation</code>，其中的参数是一个 NSInvocation 对象，并将消息全部属性记录下来。 NSInvocation 对象包括了选择子、target 以及其他参数。其中的实现仅仅是改变了 target 指向，使消息保证能够调用。倘若发现本类无法处理，则继续想父类进行查找。直至 NSObject 。</li>
<li>如果<code>methodSignatureForSelector</code>方法返回nil,就调用<code>doesNotRecognizeSelector:</code>方法</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/27/16c3202e79fbcca6?w=825&h=383&f=png&s=59990" alt=""></p>
<p>上面都是源码分析，那下面代码验证</p>
<p>在源码中<code>forwardingTargetForSelector</code>系统默认返回nil 。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息转发实例一"><a href="#消息转发实例一" class="headerlink" title="消息转发实例一"></a>消息转发实例一</h3><p>我们有类<code>Person</code>只定义了方法<code>- (void)run;</code>但是没有实现，另外有类<code>Car</code>，实现了方法<code>- (void)run;</code></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Car </span>: NSObject</span><br><span class="line">- (void)run;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import <span class="string">"Car.h"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Car</span><br><span class="line">- (void)run&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>


<p>在person中，重写<code>forwardingTargetForSelector</code>让返回<code>Car</code>对象</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">forwardingTargetForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span>&#123;</span><br><span class="line">    <span class="selector-tag">if</span> (aSelector == <span class="variable">@selector</span>(run)) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-attr">[[Car alloc]</span> <span class="selector-tag">init</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *per = <span class="comment">[<span class="comment">[Person alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[per run]</span>;</span><br></pre></td></tr></table></figure>


<p>输出<code>objc-test[16694:174917] -[Car run]</code></p>
<p>验证了前面说的，<code>forwardingTargetForSelector</code>返回值不为空的话，就向这个返回值发送消息，也就是 <code>objc_msgSend(返回值, SEL)</code></p>
<h3 id="消息转发实例二"><a href="#消息转发实例二" class="headerlink" title="消息转发实例二"></a>消息转发实例二</h3><p>如果前面的<code>forwardingTargetForSelector</code>返回为空， 就会调用 <code>methodSignatureForSelector</code> 获取方法签名后再调用 <code>forwardInvocation</code></p>
<pre><code>// 方法签名：返回值类型、参数类型
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    if (aSelector == @selector(run)) {
       return [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];
    }
     return [super methodSignatureForSelector:aSelector];
}

// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数
//        anInvocation.target 方法调用者
//        anInvocation.selector 方法名
//        [anInvocation getArgument:NULL atIndex:0]
- (void)forwardInvocation:(NSInvocation *)anInvocation
{

   [anInvocation invokeWithTarget:[[Car alloc] init]];
}</code></pre><p>依然可以调用到<code>-[Car run]</code></p>
<p><strong>注意点1</strong></p>
<p>消息转发的<code>forwardingTargetForSelector</code>和<code>methodSignatureForSelector</code>以及<code>forwardInvocation</code>不仅支持实例方法，还支持类方法。不过系统没有提示，需要写成实例方法，然后把前面的<code>-</code>改成<code>+</code>即可。</p>
<p><strong>注意点2</strong><br>只能向运行时动态创建的类添加ivars，不能向已经存在的类添加ivars</p>
<p>这是因为在编译时只读结构体class_ro_t就会被确定，在运行时是不可更改的。ro结构体中有一个字段是instanceSize，表示当前类在创建对象时需要多少空间，后面的创建都根据这个size分配类的内存。<br>如果对一个已经存在的类增加一个参数，改变了ivars的结构，这样在访问改变之前创建的对象时，就会出现问题。</p>
<h2 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h2><h3 id="资料下载-1"><a href="#资料下载-1" class="headerlink" title="资料下载"></a>资料下载</h3><p><a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos/tree/master/objc4-750-master" target="_blank" rel="noopener">github</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a></p>
<p><a href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled" target="_blank" rel="noopener">Hmmm, What’s that Selector?</a></p>
<p><a href="https://github.com/DeveloperErenLiu/RuntimePDF" target="_blank" rel="noopener">RuntimePDF</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
<p><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">Objective-C Runtime</a></p>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">Objective-C 消息发送与转发机制原理</a></p>
<p><a href="https://www.desgard.com/iOS-Source-Probe/Objective-C/Runtime/objc_msgSend%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B.html" target="_blank" rel="noopener">objc_msgSend消息传递学习笔记</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解iOS的block</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E7%9A%84block.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E7%9A%84block.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在文章之前，先抛出如下问题。</p>
<ul>
<li>block的原理是怎样的？本质是什么？</li>
<li><code>__block</code>的作用是什么？有什么使用注意点？</li>
<li>block的属性修饰词为什么是copy？使用block有哪些使用注意？</li>
<li>block一旦没有进行copy操作，就不会在堆上</li>
<li>block在修改NSMutableArray，需不需要添加__block？</li>
</ul>
<p>如果现在不是很熟悉，希望看完这篇文章，能有个新的认识。</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>本文主要从如下几个方面讲解block</p>
<ul>
<li>block的基本使用</li>
<li>block在内存中的布局</li>
<li>block对变量的捕获分析</li>
<li>MRC和ARC的对比</li>
<li><code>__block</code>的分析</li>
<li>block中内存管理问题</li>
<li>block导致的循环引用问题</li>
</ul>
<h3 id="什么是block"><a href="#什么是block" class="headerlink" title="什么是block"></a>什么是block</h3><p>先介绍一下什么是闭包。在 wikipedia 上，<a href="https://en.wikipedia.org/wiki/Closure_(computer_science):" target="_blank" rel="noopener">闭包</a>的定义是</p>
<blockquote>
<p>In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.</p>
</blockquote>
<p>翻译过来表达就是</p>
<blockquote>
<p>闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量(有时候也称作自由变量）。</p>
</blockquote>
<ul>
<li>block 实际上就是 Objective-C 语言对于闭包的实现。</li>
</ul>
<h2 id="block的基本使用"><a href="#block的基本使用" class="headerlink" title="block的基本使用"></a>block的基本使用</h2><ul>
<li><p>block本质上也是一个OC对象，它内部也有个isa指针</p>
</li>
<li><p>block是封装了函数调用以及函数调用环境的OC对象</p>
</li>
<li><p>block的底层结构如下图</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09240311d9088?w=445&h=419&f=png&s=62836" alt="block的底层结构"></p>
<h3 id="无参无返回值的定义和使用"><a href="#无参无返回值的定义和使用" class="headerlink" title="无参无返回值的定义和使用"></a>无参无返回值的定义和使用</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参无返回值 定义 和使用</span></span><br><span class="line"><span class="keyword">void</span> (^MyBlockOne)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"无参无返回值"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">MyBlockOne();</span><br></pre></td></tr></table></figure>

<h3 id="无参有返回值的定义和使用"><a href="#无参有返回值的定义和使用" class="headerlink" title="无参有返回值的定义和使用"></a>无参有返回值的定义和使用</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参有返回值</span></span><br><span class="line"><span class="keyword">int</span> (^MyBlockTwo)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"无参有返回值"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">int</span> res = MyBlockTwo();</span><br></pre></td></tr></table></figure>

<h3 id="有参无返回值的定义和使用"><a href="#有参无返回值的定义和使用" class="headerlink" title="有参无返回值的定义和使用"></a>有参无返回值的定义和使用</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参无返回值 定义</span></span><br><span class="line">void (^MyBlockThree)(<span class="built_in">int</span> a) = ^(<span class="built_in">int</span> a)&#123;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"有参无返回值 a = %d"</span>,<span class="params">a</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="constructor">MyBlockThree(10)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="有参有返回值的定义和使用"><a href="#有参有返回值的定义和使用" class="headerlink" title="有参有返回值的定义和使用"></a>有参有返回值的定义和使用</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参有返回值</span></span><br><span class="line"><span class="built_in">int</span> (^MyBlockFour)(<span class="built_in">int</span> a) = ^(<span class="built_in">int</span> a)&#123;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"有参有返回值 a = %d"</span>,<span class="params">a</span>)</span>;</span><br><span class="line">    return a<span class="operator"> * </span><span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="constructor">MyBlockFour(4)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="typedef-定义Block"><a href="#typedef-定义Block" class="headerlink" title="typedef 定义Block"></a>typedef 定义Block</h3><p>实际开发中，经常需要把block作为一个属性，我们可以定义一个block</p>
<p>eg:定义一个有参有返回值的block</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> (^MyBlock)(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br></pre></td></tr></table></figure>

<p>定义属性的时候,如下即可持有这个block</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic,copy) MyBlock myBlockOne;</span><br></pre></td></tr></table></figure>

<p>block实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.myBlockOne = ^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">self.myBlockOne(<span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="block-类型和数据结构"><a href="#block-类型和数据结构" class="headerlink" title="block 类型和数据结构"></a>block 类型和数据结构</h2><h3 id="block-数据结构分析"><a href="#block-数据结构分析" class="headerlink" title="block 数据结构分析"></a>block 数据结构分析</h3><h4 id="生成cpp文件"><a href="#生成cpp文件" class="headerlink" title="生成cpp文件"></a>生成cpp文件</h4><p>如下代码</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) =  ^&#123;</span><br><span class="line">     <span class="type">NSLog</span>(@<span class="string">"age is %d"</span>,age);</span><br><span class="line"> &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>打开终端，cd到当前目录下</li>
</ul>
<blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m </p>
</blockquote>
<p>生成<code>main.cpp</code></p>
<h4 id="block-结构分析"><a href="#block-结构分析" class="headerlink" title="block 结构分析"></a>block 结构分析</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">int age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的定义</span></span><br><span class="line">void <span class="comment">(*block)(void) = ((void (*)</span>())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"><span class="comment">// block的调用</span></span><br><span class="line">((void <span class="comment">(*)(__block_impl *)</span>)((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure>

<p>上面的代码删除掉一些强制转换的代码就就剩下如下所示</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">						__main_block_func_0, </span><br><span class="line">						&amp;__main_block_desc_0_DATA, </span><br><span class="line">						age</span><br><span class="line">						);</span><br><span class="line">// <span class="keyword">block</span>的调用</span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>);</span><br></pre></td></tr></table></figure>

<p>看出block的本质就是一个结构体对象，结构体<code>__main_block_impl_0</code>代码如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">    <span class="comment">//构造函数(类似于OC中的init方法) _age是外面传入的</span></span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">int</span> <span class="params">_age</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : age(_age) &#123;</span><br><span class="line">    <span class="comment">//isa指向_NSConcreteStackBlock 说明这个block就是_NSConcreteStackBlock类型的</span></span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体中第一个是<code>struct __block_impl impl;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">      <span class="keyword">void</span> *isa;</span><br><span class="line">      <span class="keyword">int</span> Flags;</span><br><span class="line">      <span class="keyword">int</span> Reserved;</span><br><span class="line">      <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>结构体中第二个是<code>__main_block_desc_0;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size; <span class="comment">// 结构体__main_block_impl_0 占用的内存大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体中第三个是<code>age</code></p>
<p>也就是捕获的局部变量 <code>age</code></p>
<p><code>__main_block_func_0</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//封装了block执行逻辑的函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_x4_920c4yq936b63mvtj4wmb32m0000gn_T_main_7f3f1b_mi_0,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>用一幅图来表示<br><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09240319606d9?w=1545&h=708&f=png&s=234333" alt=""></p>
<h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><p>其实上面的代码我们已经看得出来变量捕获了，这里继续详细分析一下</p>
<table>
<thead>
<tr>
<th align="left">变量类型</th>
<th align="center">捕获到block内部</th>
<th align="right">访问方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">局部变量 auto</td>
<td align="center">√</td>
<td align="right">值传递</td>
</tr>
<tr>
<td align="left">局部变量 static</td>
<td align="center">√</td>
<td align="right">指针传递</td>
</tr>
<tr>
<td align="left">全局变量</td>
<td align="center">×</td>
<td align="right">直接访问</td>
</tr>
</tbody></table>
<h4 id="局部变量auto-自动变量"><a href="#局部变量auto-自动变量" class="headerlink" title="局部变量auto(自动变量)"></a>局部变量auto(自动变量)</h4><ul>
<li>我们平时写的局部变量，默认就有 auto(自动变量，离开作用域就销毁)</li>
</ul>
<h5 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h5><p>例如下面的代码</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) =  ^&#123;</span><br><span class="line">     <span class="type">NSLog</span>(@<span class="string">"age is %d"</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">25</span>;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span> <span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) =  ^&#123;</span><br><span class="line">     <span class="type">NSLog</span>(@<span class="string">"age is %d"</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">25</span>;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure>

<p>输出 </p>
<blockquote>
<p>20</p>
</blockquote>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m </p>
</blockquote>
<p>生成<code>main.cpp</code></p>
<p>如图所示<br><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c0924031be5084?w=1014&h=624&f=png&s=163353" alt=""></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">int age = <span class="number">20</span><span class="comment">;</span></span><br><span class="line">void (<span class="name">*block</span>)(<span class="name">void</span>) = ((<span class="name">void</span> (<span class="name">*</span>)())<span class="symbol">&amp;__main_block_impl_0</span>((<span class="name">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">age = 25;</span><br><span class="line"></span><br><span class="line">((void (*)(<span class="name">__block_impl</span> *))((__block_impl *)block)-&gt;FuncPtr)((<span class="name">__block_impl</span> *)block);</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 *blockStruct = (<span class="name">__bridge</span> struct __main_block_impl_0 *)block;</span><br><span class="line"></span><br><span class="line">NSLog((NSString *)<span class="symbol">&amp;__NSConstantStringImpl__var_folders_x4_920c4yq936b63mvtj4wmb32m0000gn_T_main_d36452_mi_5</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>



<p>可以知道，直接把age的值 20传到了结构体<code>__main_block_impl_0</code>中，后面再修改<code>age = 25</code>并不能改变block里面的值</p>
<h4 id="局部变量-static"><a href="#局部变量-static" class="headerlink" title="局部变量 static"></a>局部变量 static</h4><p>static修饰的局部变量，不会被销毁</p>
<h5 id="运行代码-1"><a href="#运行代码-1" class="headerlink" title="运行代码"></a>运行代码</h5><p>eg</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">height</span>  = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) =  ^&#123;</span><br><span class="line">     NSLog(@<span class="string">"age is %d height = %d"</span>,age,<span class="built_in">height</span>);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">height</span> = <span class="number">35</span>;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">age <span class="keyword">is</span> <span class="number">20</span> height = <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>可以看得出来，block外部修改height的值，依然能影响block内部的值</p>
<h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m </p>
</blockquote>
<p>生成<code>main.cpp</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c0924031b78e23?w=1986&h=1160&f=png&s=343604" alt=""></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">height</span> = __cself-&gt;<span class="built_in">height</span>; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_x4_920c4yq936b63mvtj4wmb32m0000gn_T_main_3146e1_mi_4,age,(*<span class="built_in">height</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;<span class="built_in">height</span>));</span><br><span class="line">        age = <span class="number">25</span>;</span><br><span class="line">        <span class="built_in">height</span> = <span class="number">35</span>;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure>


<p>如图所示，<code>age</code>是直接值传递，<code>height</code>传递的是<code>*height</code> 也就是说直接把内存地址传进去进行修改了。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><h5 id="运行代码-2"><a href="#运行代码-2" class="headerlink" title="运行代码"></a>运行代码</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age1 = <span class="number">11</span>;</span><br><span class="line">static <span class="built_in">int</span> height1 = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="keyword">const</span> char * argv[]) &#123;</span><br><span class="line">    @<span class="built_in">auto</span>releasepool &#123;</span><br><span class="line">        <span class="built_in">void</span> (^block)(<span class="built_in">void</span>) =  ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"age1 is %d height1 = %d"</span>,age1,height1);</span><br><span class="line">        &#125;;</span><br><span class="line">        age1 = <span class="number">25</span>;</span><br><span class="line">        height1 = <span class="number">35</span>;</span><br><span class="line">        block();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">age1 <span class="keyword">is</span> <span class="number">25</span> height1 = <span class="number">35</span></span><br></pre></td></tr></table></figure>

<h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m </p>
</blockquote>
<p>生成<code>main.cpp</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c0924031a1a372?w=1824&h=1362&f=png&s=435962" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_x4_920c4yq936b63mvtj4wmb32m0000gn_T_main_4e8c40_mi_4,age1,height1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">        age1 = <span class="number">25</span>;</span><br><span class="line">        height1 = <span class="number">35</span>;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从cpp文件可以看出来，并没有捕获全局变量age1和height1,访问的时候，是直接去访问的，根本不需要捕获</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table>
<thead>
<tr>
<th align="left">变量类型</th>
<th align="center">捕获到block内部</th>
<th align="right">访问方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">局部变量 auto</td>
<td align="center">√</td>
<td align="right">值传递</td>
</tr>
<tr>
<td align="left">局部变量 static</td>
<td align="center">√</td>
<td align="right">指针传递</td>
</tr>
<tr>
<td align="left">全局变量</td>
<td align="center">×</td>
<td align="right">直接访问</td>
</tr>
</tbody></table>
<ul>
<li>auto修饰的局部变量，是值传递</li>
<li>static修饰的局部变量，是指针传递</li>
</ul>
<p>其实也很好理解，因为auto修饰的局部变量，离开作用域就销毁了。那如果是指针传递的话，可能导致访问的时候，该变量已经销毁了。程序就会出问题。而全局变量本来就是在哪里都可以访问的，所以无需捕获。</p>
<h3 id="block类型"><a href="#block类型" class="headerlink" title="block类型"></a>block类型</h3><h4 id="block也是一个OC对象"><a href="#block也是一个OC对象" class="headerlink" title="block也是一个OC对象"></a>block也是一个OC对象</h4><p>在进行分析block类型之前，先明确一个概念，那就是block中有isa指针的，block是一个OC对象，例如下面的代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void (^block)(void) =  ^&#123;</span><br><span class="line">      <span class="constructor">NSLog(@<span class="string">"123"</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"block.class = %@"</span>,[<span class="params">block</span> <span class="params">class</span>])</span>;</span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"block.class.superclass = %@"</span>,[[<span class="params">block</span> <span class="params">class</span>] <span class="params">superclass</span>])</span>;</span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"block.class.superclass.superclass = %@"</span>,[[[<span class="params">block</span> <span class="params">class</span>] <span class="params">superclass</span>] <span class="params">superclass</span>])</span>;</span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"block.class.superclass.superclass.superclass = %@"</span>,[[[[<span class="params">block</span> <span class="params">class</span>] <span class="params">superclass</span>] <span class="params">superclass</span>] <span class="params">superclass</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">iOS-block[<span class="number">18429</span>:<span class="number">234959</span>] block<span class="selector-class">.class</span> = __NSGlobalBlock__</span><br><span class="line">iOS-block[<span class="number">18429</span>:<span class="number">234959</span>] block<span class="selector-class">.class</span><span class="selector-class">.superclass</span> = __NSGlobalBlock</span><br><span class="line">iOS-block[<span class="number">18429</span>:<span class="number">234959</span>] block<span class="selector-class">.class</span><span class="selector-class">.superclass</span><span class="selector-class">.superclass</span> = NSBlock</span><br><span class="line">iOS-block[<span class="number">18429</span>:<span class="number">234959</span>] block<span class="selector-class">.class</span><span class="selector-class">.superclass</span><span class="selector-class">.superclass</span><span class="selector-class">.superclass</span> = NSObject</span><br></pre></td></tr></table></figure>

<p>说明了上面代码中的block的类型是<code>__NSGlobalBlock</code>，继承关系可以表示为<code>__NSGlobalBlock__ : __NSGlobalBlock : NSBlock  : NSObject</code></p>
<h4 id="block有3种类型"><a href="#block有3种类型" class="headerlink" title="block有3种类型"></a>block有3种类型</h4><p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>
<ul>
<li><code>__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）</code></li>
<li><code>__NSStackBlock__ （ _NSConcreteStackBlock ）</code></li>
<li><code>__NSMallocBlock__ （ _NSConcreteMallocBlock ）</code></li>
</ul>
<p>其中三种不同的类型和环境对应如下</p>
<table>
<thead>
<tr>
<th align="left">block类型</th>
<th align="center">环境</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>__NSGlobalBlock__</code></td>
<td align="center">没有访问auto变量</td>
</tr>
<tr>
<td align="left"><code>__NSStackBlock__</code></td>
<td align="center">访问了auto变量</td>
</tr>
<tr>
<td align="left"><code>__NSMallocBlock__</code></td>
<td align="center"><code>__NSStackBlock__</code>调用了copy</td>
</tr>
</tbody></table>
<p>其在内存中的分配如下对应</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c0924036237a71?w=816&h=552&f=png&s=150452" alt=""></p>
<h4 id="运行代码查看"><a href="#运行代码查看" class="headerlink" title="运行代码查看"></a>运行代码查看</h4><h5 id="MRC下"><a href="#MRC下" class="headerlink" title="MRC下"></a>MRC下</h5><p><strong>注意，以下代码在MRC下测试</strong></p>
<p><strong>注意，以下代码在MRC下测试</strong></p>
<p><strong>注意，以下代码在MRC下测试</strong></p>
<p>因为ARC的时候，编译器做了很多的优化，往往看不到本质,</p>
<ul>
<li>改为MRC方法： <code>Build Settings</code> 里面的<code>Automatic Reference Counting</code>改为NO</li>
</ul>
<p>如下图所示</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09240e346ed71?w=1580&h=1198&f=png&s=267196" alt=""></p>
<p>用代码来表示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) =  ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"123"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"没有访问auto block.class = %@"</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">auto <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) =  ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"a = %d"</span>,a);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"访问了auto block1.class = %@"</span>,[block1 <span class="keyword">class</span>]);</span><br><span class="line">               </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"访问量auto 并且copy block1-copy.class = %@"</span>,[[block1 <span class="keyword">class</span>] <span class="keyword">copy</span>]);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OS-block[<span class="number">23542</span>:<span class="number">349513</span>] 没有访问<span class="keyword">auto</span> block<span class="class">.<span class="keyword">class</span> = __<span class="title">NSGlobalBlock__</span></span></span><br><span class="line"><span class="class"><span class="title">iOS</span>-<span class="title">block</span>[23542:</span><span class="number">349513</span>] 访问了<span class="keyword">auto</span> block1<span class="class">.<span class="keyword">class</span> = __<span class="title">NSStackBlock__</span></span></span><br><span class="line"><span class="class"><span class="title">iOS</span>-<span class="title">block</span>[23542:</span><span class="number">349513</span>] 访问量<span class="keyword">auto</span> 并且copy block1-copy<span class="class">.<span class="keyword">class</span> = __<span class="title">NSStackBlock__</span></span></span><br></pre></td></tr></table></figure>

<p>可以看出和上面说的</p>
<table>
<thead>
<tr>
<th align="left">block类型</th>
<th align="center">环境</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>__NSGlobalBlock__</code></td>
<td align="center">没有访问auto变量</td>
</tr>
<tr>
<td align="left"><code>__NSStackBlock__</code></td>
<td align="center">访问了auto变量</td>
</tr>
<tr>
<td align="left"><code>__NSMallocBlock__</code></td>
<td align="center"><code>__NSStackBlock__</code>调用了copy</td>
</tr>
</tbody></table>
<p>是一致的</p>
<h5 id="ARC下"><a href="#ARC下" class="headerlink" title="ARC下"></a>ARC下</h5><p>在ARC下，上面的代码输出结果为下面所示，因为编译器做了copy</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">iOS-block[<span class="number">24197</span>:<span class="number">358752</span>] 没有访问<span class="keyword">auto</span> block<span class="class">.<span class="keyword">class</span> = __<span class="title">NSGlobalBlock__</span></span></span><br><span class="line"><span class="class"><span class="title">iOS</span>-<span class="title">block</span>[24197:</span><span class="number">358752</span>] 访问了<span class="keyword">auto</span> block1<span class="class">.<span class="keyword">class</span> = __<span class="title">NSMallocBlock__</span></span></span><br><span class="line"><span class="class"><span class="title">iOS</span>-<span class="title">block</span>[24197:</span><span class="number">358752</span>] 访问量<span class="keyword">auto</span> 并且copy block1-copy<span class="class">.<span class="keyword">class</span> = __<span class="title">NSMallocBlock__</span></span></span><br></pre></td></tr></table></figure>

<h3 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a>block的copy</h3><p>前面说了在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，具体来说比如以下情况</p>
<h4 id="copy的情况"><a href="#copy的情况" class="headerlink" title="copy的情况"></a>copy的情况</h4><ul>
<li>block作为函数返回值时</li>
<li>将block赋值给__strong指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ul>
<h5 id="block作为函数返回值时"><a href="#block作为函数返回值时" class="headerlink" title="block作为函数返回值时"></a>block作为函数返回值时</h5><p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092417f50345c?w=1210&h=564&f=png&s=215096" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为Block的函数</span></span><br><span class="line">YZBlock myblock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--------- %d"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YZBlock Block = myblock();</span><br><span class="line">Block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" [Block class] = %@"</span>, [Block <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-block[<span class="number">25857</span>:<span class="number">385868</span>] --------- <span class="number">6</span></span><br><span class="line">iOS-block[<span class="number">25857</span>:<span class="number">385868</span>]  [Block <span class="keyword">class</span>] = <span class="symbol">__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<p>上述代码如果再MRC下输出<code>__NSStackBlock__</code>，在ARC下，自动copy，所以是<code>__NSMallocBlock__</code></p>
<h5 id="将block赋值给-strong指针时"><a href="#将block赋值给-strong指针时" class="headerlink" title="将block赋值给__strong指针时"></a>将block赋值给<code>__strong</code>指针时</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义Block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">YZBlock Block2 = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"abc %d"</span>,b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" [Block2 class] = %@"</span>, [Block2 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-block[<span class="number">26072</span>:<span class="number">389164</span>]  [Block2 <span class="keyword">class</span>] = <span class="symbol">__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<p>上述代码如果再MRC下输出<code>__NSStackBlock__</code>，在ARC下，自动copy，所以是<code>__NSMallocBlock__</code></p>
<h5 id="block作为Cocoa-API中方法名含有usingBlock的方法参数时"><a href="#block作为Cocoa-API中方法名含有usingBlock的方法参数时" class="headerlink" title="block作为Cocoa API中方法名含有usingBlock的方法参数时"></a>block作为Cocoa API中方法名含有usingBlock的方法参数时</h5><p>eg:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NSArray *<span class="built_in">array</span> = @[@<span class="number">1</span>,@<span class="number">4</span>,@<span class="number">5</span>];</span><br><span class="line">[<span class="built_in">array</span> enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            <span class="comment">// code</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h5 id="block作为GCD-API的方法参数时"><a href="#block作为GCD-API的方法参数时" class="headerlink" title="block作为GCD API的方法参数时"></a>block作为GCD API的方法参数时</h5><p>eg</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">static</span> <span class="selector-tag">dispatch_once_t</span> <span class="selector-tag">onceToken</span>;</span><br><span class="line"><span class="selector-tag">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            </span><br><span class="line">&#125;);    </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line"><span class="selector-tag">dispatch_after</span>(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//code to be executed after a specified delay</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="MRC下block属性的建议写法"><a href="#MRC下block属性的建议写法" class="headerlink" title="MRC下block属性的建议写法"></a>MRC下block属性的建议写法</h4><ul>
<li>@property (copy, nonatomic) void (^block)(void);</li>
</ul>
<h4 id="ARC下block属性的建议写法"><a href="#ARC下block属性的建议写法" class="headerlink" title="ARC下block属性的建议写法"></a>ARC下block属性的建议写法</h4><ul>
<li>@property (strong, nonatomic) void (^block)(void);</li>
<li>@property (copy, nonatomic) void (^block)(void);</li>
</ul>
<h2 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h2><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p>首先看一个简单的例子<br>定义一个类 <code>YZPerson</code>,里面只有一个<code>dealloc</code>方法</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic ,assign) int age;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> YZPerson</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>

<p>如下代码使用</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@<span class="string">"-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想必大家都能知道会输出什么,没错，就是person先销毁，然后打印<code>-----</code> 因为person是在大括号内，当大括号执行完之后，person 就销毁了。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">iOS-block<span class="selector-attr">[1376:15527]</span> -<span class="selector-attr">[YZPerson dealloc]</span></span><br><span class="line">iOS-block<span class="selector-attr">[1376:15527]</span> -----</span><br></pre></td></tr></table></figure>



<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>上面的例子，是不是挺简单，那下面这个呢，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        YZBlock block;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            block = ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, person.age);</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@"block.class = %@"</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block销毁"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下结果，输出可知当 block为<code>__NSMallocBlock__</code>类型时候，block可以保住person的命的，因为person离开大括号之后没有销毁，当block销毁，person才销毁</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">iOS</span>-<span class="keyword">block[3186:35811] </span><span class="keyword">block.class </span>= __NSMallocBlock__</span><br><span class="line"><span class="symbol">iOS</span>-<span class="keyword">block[3186:35811] </span><span class="keyword">block销毁</span></span><br><span class="line"><span class="keyword">iOS-block[3186:35811] </span>-[YZPerson dealloc]</span><br></pre></td></tr></table></figure>

<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>终端执行这行指令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code>把<code>main.m</code>生成<code>main.cpp</code><br>可以 看到如下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  YZPerson *person;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, YZPerson <span class="operator">*</span><span class="params">_person</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显就是这个block里面包含 <code>YZPerson *person</code>。</p>
<h3 id="MRC下-block引用实例对象"><a href="#MRC下-block引用实例对象" class="headerlink" title="MRC下 block引用实例对象"></a>MRC下 block引用实例对象</h3><p>上面的例子，是不是挺简单，那如果是MRC下呢</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        YZBlock block;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            block = ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, person.age);</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block.class = %@"</span>,[block <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MRC下，需要手动释放</span></span><br><span class="line">            [person release];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block销毁"</span>);</span><br><span class="line">        <span class="comment">// MRC下，需要手动释放</span></span><br><span class="line">		 [block release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">iOS-<span class="built_in">block</span>[<span class="number">3114</span>:<span class="number">34894</span>] <span class="built_in">block</span>.class = __NSStackBlock__</span><br><span class="line">iOS-<span class="built_in">block</span>[<span class="number">3114</span>:<span class="number">34894</span>] -[YZPerson dealloc]</span><br><span class="line">iOS-<span class="built_in">block</span>[<span class="number">3114</span>:<span class="number">34894</span>] <span class="built_in">block</span>销毁</span><br></pre></td></tr></table></figure>

<p>和上面的对比，区别就是，还没有执行<code>NSLog(@&quot;block销毁&quot;);</code>的时候，<code>[YZPerson dealloc]</code>已经执行了。也就是说，person 离开大括号，就销毁了。</p>
<p>输出可知当 block为<code>__NSStackBlock__</code>类型时候，block不可以保住person的命的</p>
<h3 id="MRC下-block-copy-引用实例对象"><a href="#MRC下-block-copy-引用实例对象" class="headerlink" title="MRC下 [block copy]引用实例对象"></a>MRC下 [block copy]引用实例对象</h3><p>在MRC下，对block执行了copy操作</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        YZBlock block;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            block = [^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, person.age);</span><br><span class="line">            &#125; <span class="keyword">copy</span>];</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"block.class = %@"</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">            <span class="comment">// MRC下，需要手动释放</span></span><br><span class="line">            [person release];</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block销毁"</span>);</span><br><span class="line">        [block release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为,可知当 block为<code>__NSMallocBlock__</code>类型时候，block是可以保住person的命的</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">iOS</span>-<span class="keyword">block[3056:34126] </span><span class="keyword">block.class </span>= __NSMallocBlock__</span><br><span class="line"><span class="symbol">iOS</span>-<span class="keyword">block[3056:34126] </span><span class="keyword">block销毁</span></span><br><span class="line"><span class="keyword">iOS-block[3056:34126] </span>-[YZPerson dealloc]</span><br></pre></td></tr></table></figure>


<h3 id="weak修饰"><a href="#weak修饰" class="headerlink" title="__weak修饰"></a><code>__weak</code>修饰</h3><ul>
<li>如下代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        YZBlock block;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            YZPerson *person = [[YZPerson alloc]init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            __<span class="keyword">weak</span> YZPerson *weakPerson = person;</span><br><span class="line">            </span><br><span class="line">            block = ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, weakPerson.age);</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@"block.class = %@"</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出为</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">iOS-<span class="built_in">block</span>[<span class="number">3687</span>:<span class="number">42147</span>] <span class="built_in">block</span>.class = __NSMallocBlock__</span><br><span class="line">iOS-<span class="built_in">block</span>[<span class="number">3687</span>:<span class="number">42147</span>] -[YZPerson dealloc]</span><br><span class="line">iOS-<span class="built_in">block</span>[<span class="number">3687</span>:<span class="number">42147</span>] <span class="built_in">block</span>销毁</span><br></pre></td></tr></table></figure>

<ul>
<li><p>生成cpp文件</p>
</li>
<li><p>注意：</p>
</li>
<li><p>在使用clang转换OC为C++代码时，可能会遇到以下问题<br><code>cannot create __weak reference in file using manual reference</code></p>
</li>
<li><p>解决方案：支持ARC、指定运行时系统版本，比如<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code></p>
</li>
</ul>
<p>生成之后，可以看到，如下代码，MRC情况下，生成的代码明显多了,这是因为ARC自动进行了copy操作</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">//copy 函数</span></span><br><span class="line"> void <span class="comment">(*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//dispose函数</span></span><br><span class="line"> void <span class="comment">(*dispose)(struct __main_block_impl_0*)</span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="comment">//weak修饰</span></span><br><span class="line">  YZPerson *__weak weakPerson;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, YZPerson <span class="operator">*</span><span class="params">__weak</span> <span class="params">_weakPerson</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : weak<span class="constructor">Person(<span class="params">_weakPerson</span>)</span> &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="comment">//copy 函数</span></span><br><span class="line">  void (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//dispose函数</span></span><br><span class="line">  void (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123;</span><br><span class="line"> <span class="number">0</span>, </span><br><span class="line"> sizeof(<span class="keyword">struct</span> __main_block_impl_0),</span><br><span class="line">  __main_block_copy_0,</span><br><span class="line">   __main_block_dispose_0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//copy函数内部会调用_Block_object_assign函数</span></span><br><span class="line">static void <span class="constructor">__main_block_copy_0(<span class="params">struct</span> <span class="params">__main_block_impl_0</span><span class="operator">*</span><span class="params">dst</span>, <span class="params">struct</span> <span class="params">__main_block_impl_0</span><span class="operator">*</span><span class="params">src</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//asssgin会对对象进行强引用或者弱引用</span></span><br><span class="line"><span class="constructor">_Block_object_assign((<span class="params">void</span><span class="operator">*</span>)</span>&amp;dst-&gt;person, </span><br><span class="line">(void*)src-&gt;person, </span><br><span class="line"><span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispose函数内部会调用_Block_object_dispose函数</span></span><br><span class="line">static void <span class="constructor">__main_block_dispose_0(<span class="params">struct</span> <span class="params">__main_block_impl_0</span><span class="operator">*</span><span class="params">src</span>)</span> &#123;</span><br><span class="line"><span class="constructor">_Block_object_dispose((<span class="params">void</span><span class="operator">*</span>)</span>src-&gt;person, </span><br><span class="line"><span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>无论是MAC还是ARC</p>
<ul>
<li>当block为<code>__NSStackBlock__</code>类型时候，是在栈空间，无论对外面使用的是strong 还是weak 都不会对外面的对象进行强引用</li>
<li>当block为<code>__NSMallocBlock__</code>类型时候，是在堆空间，block是内部的<code>_Block_object_assign</code>函数会根据<code>strong</code>或者 <code>weak</code>对外界的对象进行强引用或者弱引用。</li>
</ul>
<p>其实也很好理解，因为block本身就在栈上，自己都随时可能消失，怎么能保住别人的命呢？</p>
<ul>
<li><p>当block内部访问了对象类型的auto变量时</p>
<ul>
<li>如果block是在栈上，将不会对auto变量产生强引用</li>
</ul>
</li>
<li><p>如果block被拷贝到堆上</p>
<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用<code>_Block_object_assign</code>函数</li>
<li><code>_Block_object_assign</code>函数会根据auto变量的修饰符<code>（__strong、__weak、__unsafe_unretained）</code>做出相应的操作，形成强引用（retain）或者弱引用</li>
</ul>
</li>
<li><p>如果block从堆上移除</p>
<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的auto变量（release）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="center">调用时机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">copy函数</td>
<td align="center">栈上的Block复制到堆上</td>
</tr>
<tr>
<td align="left">dispose函数</td>
<td align="center">堆上的block被废弃时</td>
</tr>
</tbody></table>
<h2 id="block"><a href="#block" class="headerlink" title="__block"></a><code>__block</code></h2><p>先从一个简单的例子说起，请看下面的代码</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// 定义<span class="keyword">block</span></span><br><span class="line">typedef <span class="built_in">void</span> (^<span class="type">YZBlock</span>)(<span class="built_in">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">YZBlock</span> <span class="keyword">block</span> = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"age = %d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure>

<p>代码很简单，运行之后，输出</p>
<blockquote>
<p>age = 10</p>
</blockquote>
<p>上面的例子在block中访问外部局部变量，那么问题来了，如果想在block内修改外部局部的值，怎么做呢？</p>
<h3 id="修改局部变量的三种方法"><a href="#修改局部变量的三种方法" class="headerlink" title="修改局部变量的三种方法"></a>修改局部变量的三种方法</h3><h4 id="写成全局变量"><a href="#写成全局变量" class="headerlink" title="写成全局变量"></a>写成全局变量</h4><p>我们把a定义为全局变量，那么在哪里都可以访问，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        YZBlock block = ^&#123;</span><br><span class="line">            age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block内部修改之后age = %d"</span>, age);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block调用完 age = %d"</span>, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很简单，输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">block内部修改之后age = <span class="number">20</span></span><br><span class="line">block调用完 age = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>对于输出就结果也没什么问题，因为全局变量，是所有地方都可访问的，在block内部可以直接操作age的内存地址的。调用完block之后，全局变量age指向的地址的值已经被更改为20，所以是上面的打印结果</p>
<h4 id="static修改局部变量"><a href="#static修改局部变量" class="headerlink" title="static修改局部变量"></a>static修改局部变量</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        YZBlock block = ^&#123;</span><br><span class="line">            age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block内部修改之后age = %d"</span>, age);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block调用完 age = %d"</span>, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码输出结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">block内部修改之后age = <span class="number">20</span></span><br><span class="line">block调用完 age = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>终端执行这行指令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code>把<code>main.m</code>生成<code>main.cpp</code><br>可以 看到如下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="built_in">int</span> *age;</span><br><span class="line">    <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">int</span> <span class="operator">*</span><span class="params">_age</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : age(_age) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void <span class="constructor">__main_block_func_0(<span class="params">struct</span> <span class="params">__main_block_impl_0</span> <span class="operator">*</span><span class="params">__cself</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> *age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">    </span><br><span class="line">    (*age) = <span class="number">20</span>;</span><br><span class="line">    <span class="constructor">NSLog((NSString <span class="operator">*</span>)</span>&amp;__NSConstantStringImpl__var_folders_x4_920c4yq936b63mvtj4wmb32m0000gn_T_main_5dbaa1_mi_0, (*age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当局部变量用static修饰之后，这个block内部会有个成员是<code>int *age</code>，也就是说把age的地址捕获了。这样的话，当然在block内部可以修改局部变量age了。</p>
<ul>
<li>以上两种方法，虽然可以达到在block内部修改局部变量的目的，但是，这样做，会导致内存无法释放。无论是全局变量，还是用static修饰，都无法及时销毁，会一直存在内存中。很多时候，我们只是需要临时用一下，当不用的时候，能销毁掉，那么第三种，也就是今天的主角 <code>__block</code>隆重登场</li>
</ul>
<h4 id="block来修饰"><a href="#block来修饰" class="headerlink" title="__block来修饰"></a><code>__block</code>来修饰</h4><p>代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       __block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        YZBlock block = ^&#123;</span><br><span class="line">            age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block内部修改之后age = %d"</span>,age);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block调用完 age = %d"</span>,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果和上面两种一样</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">block内部修改之后age = <span class="number">20</span></span><br><span class="line">block调用完 age = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="block分析"><a href="#block分析" class="headerlink" title="__block分析"></a><code>__block</code>分析</h3><ul>
<li>终端执行这行指令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code>把<code>main.m</code>生成<code>main.cpp</code></li>
</ul>
<p>首先能发现 多了<code>__Block_byref_age_0</code>结构体</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="comment">// 这里多了__Block_byref_age_0类型的结构体</span></span><br><span class="line">  __Block_byref_age_0 *age; <span class="comment">// by ref</span></span><br><span class="line">    <span class="comment">// fp是函数地址  desc是描述信息  __Block_byref_age_0 类型的结构体  *_age  flags标记</span></span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">__Block_byref_age_0</span> <span class="operator">*</span><span class="params">_age</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp; <span class="comment">//fp是函数地址</span></span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再仔细看结构体<code>__Block_byref_age_0</code>，可以发现第一个成员变量是isa指针，第二个是指向自身的指针<code>__forwarding</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 结构体 __Block_byref_age_0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *__isa; <span class="comment">//isa指针</span></span><br><span class="line">    __Block_byref_age_0 *__forwarding; <span class="comment">// 指向自身的指针</span></span><br><span class="line">    <span class="keyword">int</span> __flags;</span><br><span class="line">    <span class="keyword">int</span> __size;</span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">//使用值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看main函数里面的代码</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 这是原始的代码 __Block_byref_age_0</span></span><br><span class="line"> __attribute__<span class="comment">((__blocks__(byref)</span>)) __Block_byref_age_<span class="number">0</span> age = &#123;</span><br><span class="line"> <span class="comment">(void*)</span><span class="number">0</span>,<span class="comment">(__Block_byref_age_0 *)</span>&amp;age, <span class="number">0</span>, sizeof<span class="comment">(__Block_byref_age_0)</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        </span><br><span class="line">             </span><br><span class="line"><span class="comment">// 这是原始的 block代码</span></span><br><span class="line">YZBlock block = <span class="comment">((void (*)</span><span class="comment">()</span>)&amp;__mai<span class="symbol">n_block_impl_0</span><span class="comment">(</span></span><br><span class="line"><span class="comment">(void *)</span>__mai<span class="symbol">n_block_func_0</span>, &amp;__mai<span class="symbol">n_block_desc_0</span>_DATA, <span class="comment">(__Block_byref_age_0 *)</span>&amp;age, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>

<p>代码太长，简化一下，去掉一些强转的代码，结果如下</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这是原始的代码 __Block_byref_age_0</span></span><br><span class="line"><span class="variable">__attribute__</span>((<span class="variable">__blocks__</span>(byref))) <span class="variable">__Block_byref_age_0</span> age = &#123;(void*)<span class="number">0</span>,(<span class="variable">__Block_byref_age_0</span> *)&amp;age, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="variable">__Block_byref_age_0</span>), <span class="number">10</span>&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//这是简化之后的代码 __Block_byref_age_0</span></span><br><span class="line"><span class="variable">__Block_byref_age_0</span> age = &#123;</span><br><span class="line">     <span class="number">0</span>, <span class="comment">//赋值给 __isa</span></span><br><span class="line">     (<span class="variable">__Block_byref_age_0</span> *)&amp;age,<span class="comment">//赋值给 __forwarding,也就是自身的指针</span></span><br><span class="line">      <span class="number">0</span>, <span class="comment">// 赋值给__flags</span></span><br><span class="line">      <span class="built_in">sizeof</span>(<span class="variable">__Block_byref_age_0</span>),<span class="comment">//赋值给 __size</span></span><br><span class="line">      <span class="number">10</span> <span class="comment">// age 使用值</span></span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 这是原始的 block代码</span></span><br><span class="line">YZBlock block = ((void (*)())&amp;<span class="variable">__main_block_impl_0</span>((void *)<span class="variable">__main_block_func_0</span>, &amp;<span class="variable">__main_block_desc_0_DATA</span>, (<span class="variable">__Block_byref_age_0</span> *)&amp;age, <span class="number">570425344</span>));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 这是简化之后的 block代码</span></span><br><span class="line">YZBlock block = (&amp;<span class="variable">__main_block_impl_0</span>(</span><br><span class="line">             		<span class="variable">__main_block_func_0</span>,</span><br><span class="line">           		&amp;<span class="variable">__main_block_desc_0_DATA</span>,</span><br><span class="line">	           	 &amp;age,</span><br><span class="line">            	<span class="number">570425344</span>));</span><br><span class="line">        </span><br><span class="line"> ((void (*)(<span class="variable">__block_impl</span> *))((<span class="variable">__block_impl</span> *)block)-&gt;FuncPtr)((<span class="variable">__block_impl</span> *)block);</span><br><span class="line">        <span class="comment">//简化为</span></span><br><span class="line">block-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure>

<p>其中<code>__Block_byref_age_0</code>结构体中的第二个<code>(__Block_byref_age_0 *)&amp;age</code>赋值给上面代码结构体<code>__Block_byref_age_0</code>中的第二个<code>__Block_byref_age_0 *__forwarding</code>,所以<code>__forwarding</code> 里面存放的是指向自身的指针</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是简化之后的代码 __Block_byref_age_0</span></span><br><span class="line"><span class="variable">__Block_byref_age_0</span> age = &#123;</span><br><span class="line">     <span class="number">0</span>, <span class="comment">//赋值给 __isa</span></span><br><span class="line">     (<span class="variable">__Block_byref_age_0</span> *)&amp;age,<span class="comment">//赋值给 __forwarding,也就是自身的指针</span></span><br><span class="line">      <span class="number">0</span>, <span class="comment">// 赋值给__flags</span></span><br><span class="line">      <span class="built_in">sizeof</span>(<span class="variable">__Block_byref_age_0</span>),<span class="comment">//赋值给 __size</span></span><br><span class="line">      <span class="number">10</span> <span class="comment">// age 使用值</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>结构体<code>__Block_byref_age_0</code>中代码如下，第二个<code>__forwarding</code>存放指向自身的指针,第五个<code>age</code>里面存放局部变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体 __Block_byref_age_0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *__isa; <span class="comment">//isa指针</span></span><br><span class="line">    __Block_byref_age_0 *__forwarding; <span class="comment">// 指向自身的指针</span></span><br><span class="line">    <span class="keyword">int</span> __flags;</span><br><span class="line">    <span class="keyword">int</span> __size;</span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">//使用值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用的时候，先通过<code>__forwarding</code>找到指针，然后去取出age值。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="title">age</span>-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>age));</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092427cff07f0?w=1082&h=925&f=png&s=356321" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09242afff1b4d?w=1077&h=1016&f=png&s=308635" alt=""></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p><code>__block</code>可以用于解决block内部无法修改auto变量值的问题</p>
</li>
<li><p><code>__block</code>不能修饰全局变量、静态变量（static）</p>
<ul>
<li>编译器会将<code>__block</code>变量包装成一个对象</li>
</ul>
</li>
</ul>
<p>调用的是，从<code>__Block_byref_age_0</code>的指针找到 <code>age</code>所在的内存，然后修改值</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09243232b2d65?w=836&h=394&f=png&s=122555" alt=""></p>
<h2 id="内存管理问题"><a href="#内存管理问题" class="headerlink" title="内存管理问题"></a>内存管理问题</h2><h3 id="bloc访问OC对象"><a href="#bloc访问OC对象" class="headerlink" title="bloc访问OC对象"></a>bloc访问OC对象</h3><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>当block内部访问外面的OC对象的时候</p>
<p>eg:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">        YZBlock block = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,obj);</span><br><span class="line">        &#125;;</span><br><span class="line">         block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端使用clang转换OC为C++代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios<span class="number">-8.0</span><span class="number">.0</span> main.m</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092437ffd7ac6?w=1067&h=916&f=png&s=300125" alt=""></p>
<p>因为是在ARC下，所以会copy，栈上拷贝到堆上，结构体<code>__main_block_desc_0</code>中有<code>copy</code>和<code>dispose</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*);</span><br><span class="line">  void (*dispose)(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>copy</code>会调用 <code>__main_block_copy_0</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*dst, </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;obj, </span><br><span class="line">(void*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>其内部的<code>_Block_object_assign</code>会根据代码中的修饰符 <code>strong</code>或者<code>weak</code>而对其进行强引用或者弱引用。</p>
<p>查看<code>__main_block_impl_0</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="comment">//strong 强引用</span></span><br><span class="line">  NSObject *__strong obj;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, NSObject <span class="operator">*</span><span class="params">__strong</span> <span class="params">_obj</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : obj(_obj) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看上修饰符是<code>strong</code>，所以，调用<code>_Block_object_assign</code>时候，会对其进行强引用。</p>
<p>由前面可知</p>
<ul>
<li><p>当block在栈上时，并不会对__block变量产生强引用</p>
</li>
<li><p>当block被copy到堆时</p>
<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用<code>_Block_object_assign</code>函数</li>
<li><code>_Block_object_assign</code>函数会对<code>__block</code>变量形成强引用（retain）</li>
</ul>
</li>
<li><p>当block从堆中移除时</p>
<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的<code>__block变量（release）</code></li>
</ul>
</li>
</ul>
<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>拷贝的时候，</p>
<ul>
<li><p>会调用block内部的copy函数</p>
<ul>
<li>copy函数内部会调用<code>_Block_object_assign</code>函数</li>
<li><code>_Block_object_assign</code>函数会对<code>__block</code>变量形成强引用（retain）</li>
</ul>
<p>中我们知道，如下代码</p>
</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">__block int <span class="attr">age</span> = <span class="number">10</span>;</span><br><span class="line">  YZBlock <span class="attr">block</span> = ^&#123;</span><br><span class="line">      <span class="attr">age</span> = <span class="number">20</span>;</span><br><span class="line">      NSLog(@<span class="string">"block内部修改之后age = %d"</span>,age);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>局部变量age是在栈上的，在block内部引用age,但是当block从栈上拷贝到堆上的时候，怎么能保证下次block访问age的时候，能访问到呢？因为我们知道栈上的局部变量，随时会销毁的。</p>
<p>假设现在有两个栈上的block,分别是block0和block1,同时引用了了栈上的<code>__block变量</code>。现在对block0进行copy操作，我们知道，栈上的block进行copy，就会复制到堆上，也就是说block0会复制到堆上，因为block0持有<code>__block变量</code>，所以也会把这个<code>__block变量</code>复制到堆上，同时堆上的block0对堆上的<code>__block变量</code>是强引用，这样能达到block0随时能访问<code>__block变量</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c0924381b27417?w=415&h=198&f=png&s=36422" alt=""></p>
<p>还是上面的例子，刚才block0拷贝到堆上了，现在如果block1也拷贝到堆上，因为刚才变量已经拷贝到堆上，就不需要再次拷贝，只需要把堆上的block1也强引用堆上的变量就可以了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092450d7d1a7a?w=424&h=208&f=png&s=40125" alt=""></p>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>当释放的时候 </p>
<ul>
<li>会调用block内部的dispose函数<ul>
<li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的<code>__block变量（release）</code></li>
</ul>
</li>
</ul>
<p>上面的代码中，如果在堆上只有一个block引用<code>__block变量</code>,当block销毁时候，直接销毁堆上的<code>__block变量</code>，但是如果有两个block引用<code>__block变量</code>，就需要当两个block都废弃的时候，才会废弃<code>__block变量</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092448f6daa19?w=852&h=215&f=png&s=83642" alt=""></p>
<p>其实，说到底，就是谁使用，谁负责</p>
<h3 id="对象类型的auto变量、-block变量"><a href="#对象类型的auto变量、-block变量" class="headerlink" title="对象类型的auto变量、__block变量"></a>对象类型的<code>auto变量</code>、<code>__block</code>变量</h3><p>把前面的都放在一起整理一下，有 auto 变量 num , <code>__block</code>变量int, obj 和weakObj2如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> __block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="built_in">NSObject</span> *obj2 = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj2 = obj2;</span><br><span class="line">    YZBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age = %d"</span>,age);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"num = %d"</span>,num);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj = %p"</span>,obj);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"weakObj2 = %p"</span>,weakObj2);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block内部修改之后age = %d"</span>,age);</span><br><span class="line">	&#125;;</span><br><span class="line">    </span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>执行终端指令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios<span class="number">-8.0</span><span class="number">.0</span> main.m</span><br></pre></td></tr></table></figure>

<p>生成代码如下所示</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09243a7eccf2d?w=1260&h=952&f=png&s=362007" alt=""></p>
<h3 id="被-block修饰的对象类型"><a href="#被-block修饰的对象类型" class="headerlink" title="被__block修饰的对象类型"></a>被__block修饰的对象类型</h3><ul>
<li><p>当<code>__block</code>变量在栈上时，不会对指向的对象产生强引用</p>
</li>
<li><p>当<code>__block</code>变量被copy到堆时</p>
<ul>
<li>会调用<code>__block</code>变量内部的copy函数</li>
<li>copy函数内部会调用<code>_Block_object_assign</code>函数</li>
<li><code>_Block_object_assign</code>函数会根据所指向对象的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）</li>
</ul>
</li>
<li><p>如果<code>__block</code>变量从堆上移除</p>
<ul>
<li>会调用<code>__block</code>变量内部的dispose函数</li>
<li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放指向的对象（release）</li>
</ul>
</li>
</ul>
<h3 id="block的-forwarding指针"><a href="#block的-forwarding指针" class="headerlink" title="__block的__forwarding指针"></a><code>__block</code>的<code>__forwarding</code>指针</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体__Block_byref_obj_0中有__forwarding</span></span><br><span class="line"> <span class="keyword">struct</span> __Block_byref_obj_0 &#123;</span><br><span class="line">  		<span class="keyword">void</span> *__isa;</span><br><span class="line">		__Block_byref_obj_0 *__forwarding;</span><br><span class="line">		 <span class="keyword">int</span> __flags;</span><br><span class="line"> 		<span class="keyword">int</span> __size;</span><br><span class="line"> 		<span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> 		<span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> 		<span class="built_in">NSObject</span> *__<span class="keyword">strong</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问的时候</span></span><br><span class="line">age-&gt;__forwarding-&gt;age</span><br></pre></td></tr></table></figure>
<p>为啥什么不直接用age,而是<code>age-&gt;__forwarding-&gt;age</code>呢？</p>
<p>这是因为，如果<code>__block</code>变量在栈上，就可以直接访问，但是如果已经拷贝到了堆上，访问的时候，还去访问栈上的，就会出问题，所以，先根据<code>__forwarding</code>找到堆上的地址，然后再取值</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09243cdf01312?w=612&h=373&f=png&s=78494" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>当block在栈上时，对它们都不会产生强引用</p>
</li>
<li><p>当block拷贝到堆上时，都会通过copy函数来处理它们</p>
<ul>
<li><code>__block</code>变量（假设变量名叫做a）</li>
</ul>
</li>
<li><p><code>_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/)</code>;</p>
</li>
<li><p>对象类型的auto变量（假设变量名叫做p）<br>  <code>_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/)</code>;</p>
</li>
<li><p>当block从堆上移除时，都会通过dispose函数来释放它们<br>  <code>__block</code>变量（假设变量名叫做a）<br>  <code>_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/)</code>;</p>
</li>
<li><p>对象类型的auto变量（假设变量名叫做p）<br>  <code>_Block_object_dispose((void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/)</code>;</p>
</li>
</ul>
<h2 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h2><p>继续探索一下block的循环引用问题。</p>
<p>看如下代码，有个Person类，里面两个属性，分别是block和age</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZBlock) (<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) YZBlock block;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m中如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    </span><br><span class="line">        YZPerson *person = [[YZPerson alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        person.block = ^&#123;</span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@"person.age--- %d"</span>,person.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出只有</p>
<blockquote>
<p>iOS-block[38362:358749] ——–</p>
</blockquote>
<p>也就是说程序结束，person都没有释放，造成了内存泄漏。</p>
<h3 id="循环引用原因"><a href="#循环引用原因" class="headerlink" title="循环引用原因"></a>循环引用原因</h3><p>下面这行代码，是有个person指针，指向了YZPerson对象</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZPerson *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>

<p>执行完</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">person.block = ^&#123;</span><br><span class="line">            <span class="constructor">NSLog(@<span class="string">"person.age--- %d"</span>,<span class="params">person</span>.<span class="params">age</span>)</span>;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>之后，block内部有个强指针指向person，下面代码生成cpp文件</p>
<blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="comment">//强指针指向person</span></span><br><span class="line">  YZPerson *__strong person;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, YZPerson <span class="operator">*</span><span class="params">__strong</span> <span class="params">_person</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而block是person的属性</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(copy, nonatomic) YZBlock block;</span><br></pre></td></tr></table></figure>



<p>当程序退出的时候，局部变量person销毁，但是由于MJPerson和block直接，互相强引用，谁都释放不了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092458a4316fa?w=864&h=508&f=png&s=177936" alt=""></p>
<h3 id="weak解决循环引用"><a href="#weak解决循环引用" class="headerlink" title="__weak解决循环引用"></a><code>__weak</code>解决循环引用</h3><p>为了解决上面的问题，只需要用<code>__weak</code>来修饰，即可</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        YZPerson *person = [[YZPerson alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> YZPerson *weakPerson = person;</span><br><span class="line">        </span><br><span class="line">        person.block = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"person.age--- %d"</span>,weakPerson.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完成之后是</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="comment">// block内部对weakPerson是弱引用</span></span><br><span class="line">  YZPerson *__weak weakPerson;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, YZPerson <span class="operator">*</span><span class="params">__weak</span> <span class="params">_weakPerson</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : weak<span class="constructor">Person(<span class="params">_weakPerson</span>)</span> &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>当局部变量消失时候，对于YZPseson来说，只有一个若指针指向它，那它就销毁，然后block也销毁。</p>
<h3 id="unsafe-unretained解决循环引用"><a href="#unsafe-unretained解决循环引用" class="headerlink" title="__unsafe_unretained解决循环引用"></a><code>__unsafe_unretained</code>解决循环引用</h3><p>除了上面的<code>__weak</code>之后，也可以用<code>__unsafe_unretained</code>来解决循环引用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        YZPerson *person = [[YZPerson alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">unsafe_unretained</span> YZPerson *weakPerson = person;</span><br><span class="line">        </span><br><span class="line">        person.block = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"person.age--- %d"</span>,weakPerson.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于的cpp文件为</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  YZPerson *__unsafe_unretained weakPerson;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, YZPerson <span class="operator">*</span><span class="params">__unsafe_unretained</span> <span class="params">_weakPerson</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : weak<span class="constructor">Person(<span class="params">_weakPerson</span>)</span> &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然<code>__unsafe_unretained</code>可以解决循环引用，但是最好不要用，因为</p>
<ul>
<li><code>__weak</code>：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</li>
<li><code>__unsafe_unretained</code>：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</li>
</ul>
<h3 id="block解决循环引用"><a href="#block解决循环引用" class="headerlink" title="__block解决循环引用"></a><code>__block</code>解决循环引用</h3><p>eg:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       __block YZPerson *person = [[YZPerson alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        person.block = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"person.age--- %d"</span>,person.age);</span><br><span class="line">            <span class="comment">//这一句不能少</span></span><br><span class="line">            person = <span class="literal">nil</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 必须调用一次</span></span><br><span class="line">        person.block();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，也是可以解决循环引用的。但是需要注意的是，<code>person.block();</code>必须调用一次，为了执行<code>person = nil;</code>.</p>
<p>对应的结果如下</p>
<ul>
<li>下面的代码，block会对<code>__block</code>产生强引用</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">__block YZPerson *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.block = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"person.age--- %d"</span>,<span class="keyword">person</span>.age);</span><br><span class="line">        //这一句不能少</span><br><span class="line">        <span class="keyword">person</span> = nil;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>person对象本身就对block是强引用</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(copy, nonatomic) YZBlock block;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__block</code>对person产生强引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_person_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="comment">//`__block`对person产生强引用</span></span><br><span class="line"> YZPerson *__strong person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以他们的引用关系如图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c092459f38a181?w=572&h=288&f=png&s=85454" alt=""></p>
<p>当执行完<code>person = nil</code>时候,<code>__block</code>解除对person的引用,进而，全都解除释放了。<br>但是必须调用<code>person = nil</code>才可以，否则，不能解除循环引用</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>通过前面的分析，我们知道，ARC下，上面三种方式对比，最好的是<code>__weak</code></p>
<h3 id="MRC下注意点"><a href="#MRC下注意点" class="headerlink" title="MRC下注意点"></a>MRC下注意点</h3><p>如果再MRC下，因为不支持弱指针<code>__weak</code>，所以，只能是<code>__unsafe_unretained</code>或者<code>__block</code>来解决循环引用</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>回到最开始的问题</p>
<ul>
<li><p>block的原理是怎样的？本质是什么？</p>
</li>
<li><p><code>__block</code>的作用是什么？有什么使用注意点？</p>
</li>
<li><p>block的属性修饰词为什么是copy？使用block有哪些使用注意？</p>
</li>
<li><p>block一旦没有进行copy操作，就不会在堆上</p>
</li>
</ul>
<ul>
<li>block在修改NSMutableArray，需不需要添加__block？</li>
</ul>
<p>现在是不是心中有了自己的答案呢？</p>
<p>参考资料:</p>
<p><a href="https://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">唐巧谈Objective-C block的实现</a></p>
<p><a href="https://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">A look inside blocks: Episode 3 (Block_copy)</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS中load和initialize</title>
    <url>/iOS%E4%B8%ADload%E5%92%8Cinitialize.html/</url>
    <content><![CDATA[<p>首发于<a href="https://ityongzhen.github.io/iOS%E4%B8%ADload%E5%92%8Cinitialize.html">我的个人博客</a></p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="+load方法"></a>+load方法</h2><h3 id="创建类和分类"><a href="#创建类和分类" class="headerlink" title="创建类和分类"></a>创建类和分类</h3><ul>
<li>先创建类YZPerson类，然后创建它的两个分类</li>
</ul>
<p>YZPerson.m类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">+(<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>YZPerson+test1.m类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+test1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">test1</span>)</span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>YZPerson+test2.m类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+test2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">test2</span>)</span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>创建完之后，这几个类不主动调用，直接启动</p>
<ul>
<li>打印结果</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">CateogryDemo[<span class="number">29670</span>:<span class="number">414343</span>] +[YZPerson load]</span><br><span class="line">CateogryDemo[<span class="number">29670</span>:<span class="number">414343</span>] +[YZPerson(test1) load]</span><br><span class="line">CateogryDemo[<span class="number">29670</span>:<span class="number">414343</span>] +[YZPerson(test2) load]</span><br></pre></td></tr></table></figure>

<p>这说明了。load方法，根本不需要我们自己调用，编译完成之后，就会调用。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>但是有个疑问，因为，原来的类和分类中都写了load方法，为啥都调用呢？为什么不是只调用分类中的呢？</p>
<h3 id="查看元类中的方法"><a href="#查看元类中的方法" class="headerlink" title="查看元类中的方法"></a>查看元类中的方法</h3><h4 id="利用runtime写个打印方法"><a href="#利用runtime写个打印方法" class="headerlink" title="利用runtime写个打印方法"></a>利用runtime写个打印方法</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void print<span class="constructor">MethodNamesOfClass(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unsigned <span class="built_in">int</span> count;</span><br><span class="line">    <span class="comment">// 获得方法数组</span></span><br><span class="line">    Method *methodList = <span class="keyword">class</span><span class="constructor">_copyMethodList(<span class="params">cls</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储方法名</span></span><br><span class="line">    NSMutableString *methodNames = <span class="literal">[NSM<span class="identifier">utableString</span> <span class="identifier">string</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的方法</span></span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得方法</span></span><br><span class="line">        Method <span class="keyword">method</span> = methodList<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        <span class="comment">// 获得方法名</span></span><br><span class="line">        NSString *methodName = <span class="constructor">NSStringFromSelector(<span class="params">method_getName</span>(<span class="params">method</span>)</span>);</span><br><span class="line">        <span class="comment">// 拼接方法名</span></span><br><span class="line">        <span class="literal">[<span class="identifier">methodNames</span> <span class="identifier">appendString</span>:<span class="identifier">methodName</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">methodNames</span> <span class="identifier">appendString</span>:@", "]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印方法名</span></span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">"%@ %@"</span>, <span class="params">cls</span>, <span class="params">methodNames</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用，因为是要查看类方法，所以需要打印元类中的方法"><a href="#调用，因为是要查看类方法，所以需要打印元类中的方法" class="headerlink" title="调用，因为是要查看类方法，所以需要打印元类中的方法"></a>调用，因为是要查看类方法，所以需要打印元类中的方法</h4><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    printMethodNamesOfClass(<span class="keyword">object</span><span class="number">_</span>getClass([YZPerson <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果为"><a href="#结果为" class="headerlink" title="结果为"></a>结果为</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">CateogryDemo[<span class="number">30112</span>:<span class="number">420944</span>] +[YZPerson <span class="keyword">load</span>]</span><br><span class="line">CateogryDemo[<span class="number">30112</span>:<span class="number">420944</span>] +[<span class="built_in">YZPerson</span>(test1) <span class="keyword">load</span>]</span><br><span class="line">CateogryDemo[<span class="number">30112</span>:<span class="number">420944</span>] +[<span class="built_in">YZPerson</span>(test2) <span class="keyword">load</span>]</span><br><span class="line">CateogryDemo[<span class="number">30112</span>:<span class="number">420944</span>] YZPerson <span class="keyword">load</span>, <span class="keyword">run</span>, <span class="keyword">load</span>, <span class="keyword">run</span>, <span class="keyword">load</span>, <span class="keyword">run</span>,</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>看得出来，有三个load方法，三个run方法</p>
<p>也进一步验证了，前面查看源码分析的结论：合并分类的时候，其方法列表等，不会覆盖掉原来类中的方法，是共存的。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>同上，先找到初始化方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_objc_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    static <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ<span class="constructor">_init()</span>;</span><br><span class="line">    tls<span class="constructor">_init()</span>;</span><br><span class="line">    static<span class="constructor">_init()</span>;</span><br><span class="line">    lock<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="keyword">exception</span><span class="constructor">_init()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">_dyld_objc_notify_register(&amp;<span class="params">map_images</span>, <span class="params">load_images</span>, <span class="params">unmap_image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 load_images 方法，这个是加载镜像，模块的方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载镜像，模块的方法</span></span><br><span class="line">void</span><br><span class="line">load<span class="constructor">_images(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">path</span> <span class="params">__unused</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">mach_header</span> <span class="operator">*</span><span class="params">mh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!has<span class="constructor">LoadMethods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare<span class="constructor">_load_methods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call<span class="constructor">_load_methods()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看加载load的代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void call<span class="constructor">_load_methods(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    static <span class="built_in">bool</span> loading = NO;</span><br><span class="line">    <span class="built_in">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc<span class="constructor">_autoreleasePoolPush()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="comment">// 1. 调用类的load方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call<span class="constructor">_class_loads()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        <span class="comment">// 2. 调用分类的load方法</span></span><br><span class="line">        more_categories = call<span class="constructor">_category_loads()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span><span class="operator">  ||  </span>more_categories);</span><br><span class="line"></span><br><span class="line">    objc<span class="constructor">_autoreleasePoolPop(<span class="params">pool</span>)</span>;</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，是先调用类的load方法，再调用分类的load方法</p>
<p>继续跟代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 关键代码</span></span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着上面注释中的关键代码，继续看源码</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef void(*load_method_t)(id, <span class="type">SEL</span>);</span><br></pre></td></tr></table></figure>

<p>发现是一个指向函数地址的指针</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>那么，答案就很清晰了。+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用。</li>
</ul>
<h2 id="有分类和子类的情况"><a href="#有分类和子类的情况" class="headerlink" title="有分类和子类的情况"></a>有分类和子类的情况</h2><h3 id="当有分类，也有子类，并且都有load方法-的情况下"><a href="#当有分类，也有子类，并且都有load方法-的情况下" class="headerlink" title="当有分类，也有子类，并且都有load方法 的情况下"></a>当有分类，也有子类，并且都有load方法 的情况下</h3><p>例如YZStudent是 YZPerson 的子类<br>YZStudent+test1 是 YZStudent的分类<br>调用结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">CateogryDemo[<span class="number">31904</span>:<span class="number">444099</span>] +[YZPerson load]</span><br><span class="line">CateogryDemo[<span class="number">31904</span>:<span class="number">444099</span>] +[YZStudent load]</span><br><span class="line">CateogryDemo[<span class="number">31904</span>:<span class="number">444099</span>] +[YZStudent(test1) load]</span><br><span class="line">CateogryDemo[<span class="number">31904</span>:<span class="number">444099</span>] +[YZPerson(test1) load]</span><br><span class="line">CateogryDemo[<span class="number">31904</span>:<span class="number">444099</span>] +[YZPerson(test2) load]</span><br></pre></td></tr></table></figure>


<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>接着之前的源码分析，继续查看源码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载镜像，模块的方法</span></span><br><span class="line">void</span><br><span class="line">load<span class="constructor">_images(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">path</span> <span class="params">__unused</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">mach_header</span> <span class="operator">*</span><span class="params">mh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!has<span class="constructor">LoadMethods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        <span class="comment">// prepare 准备工作</span></span><br><span class="line">        prepare<span class="constructor">_load_methods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call<span class="constructor">_load_methods()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void prepare<span class="constructor">_load_methods(<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span><span class="params">mhdr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        <span class="constructor">_getObjc2NonlazyClassList(<span class="params">mhdr</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    for (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 定制，规划</span></span><br><span class="line">        schedule<span class="constructor">_class_load(<span class="params">remapClass</span>(<span class="params">classlist</span>[<span class="params">i</span>])</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = <span class="constructor">_getObjc2NonlazyCategoryList(<span class="params">mhdr</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    for (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        Class cls = remap<span class="constructor">Class(<span class="params">cat</span>-&gt;<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cls) continue;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realize<span class="constructor">Class(<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="keyword">assert</span>(cls-&gt;<span class="constructor">ISA()</span>-&gt;is<span class="constructor">Realized()</span>);</span><br><span class="line">        add<span class="constructor">_category_to_loadable_list(<span class="params">cat</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void schedule_class_load(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">// 递归调用，传入父类</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">    <span class="comment">// 将cls 添加到 loadable_classes数组最后面</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，load方法，是递归调用，传入父类。依次加入数组中，那么调用的时候，先调用父类的load,再调用子类的load,而且和编译顺序无关。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>+load方法会在runtime加载类、分类时调用</p>
<p>每个类、分类的+load，在程序运行过程中只调用一次<br>load的调用顺序</p>
<ol>
<li><p>先调用类的load</p>
<ul>
<li>先编译的类，优先调用load</li>
<li>调用子类的load之前，会先调用父类的load</li>
</ul>
</li>
<li><p>再调用分类的load</p>
<ul>
<li>先编译的分类，优先调用load</li>
</ul>
</li>
</ol>
<h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h2><p>+initialize方法会在类第一次接收到消息时调用</p>
<h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><p>先调用父类的+initialize，再调用子类的+initialize<br>(先初始化父类，再初始化子类，每个类只会初始化1次)</p>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a><br>objc4源码解读过程</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;1. objc-msg-arm64.s</span><br><span class="line"><span class="bullet">- </span>objc_msgSend</span><br><span class="line"></span><br><span class="line">&gt;2. objc-runtime-new.mm</span><br><span class="line"><span class="bullet">- </span>class_getInstanceMethod</span><br><span class="line"><span class="bullet">- </span>lookUpImpOrNil</span><br><span class="line"><span class="bullet">- </span>lookUpImpOrForward</span><br><span class="line"><span class="bullet">- </span><span class="emphasis">_class_</span>initialize</span><br><span class="line"><span class="bullet">- </span>callInitialize</span><br><span class="line"><span class="bullet">- </span>objc<span class="emphasis">_msgSend(cls, SEL_</span>initialize)</span><br></pre></td></tr></table></figure>

<p>具体来看代码</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL sel)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    if (!cls  ||  !sel) return nil;</span></span></span><br><span class="line"><span class="function"><span class="comment">    lookUpImpOrNil(cls, sel, nil, </span></span></span><br><span class="line"><span class="function"><span class="comment">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    return _class_getMethod(cls, sel);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>继续查看 lookUpImpOrNil</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                   <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lookUpImpOrForward 代码比较长，摘取关键代码如下</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id <span class="keyword">inst, </span></span><br><span class="line">                       <span class="keyword">bool </span>initialize, <span class="keyword">bool </span><span class="keyword">cache, </span><span class="keyword">bool </span>resolver)</span><br><span class="line">&#123;</span><br><span class="line"> if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, <span class="keyword">inst));</span></span><br><span class="line"><span class="keyword"> </span>       runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>继续查看关键代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_class_initialize(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span>(!cls-&gt;is<span class="constructor">MetaClass()</span>);</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="built_in">bool</span> reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supercls<span class="operator">  &amp;&amp;  </span>!supercls-&gt;is<span class="constructor">Initialized()</span>) &#123;</span><br><span class="line">        <span class="constructor">_class_initialize(<span class="params">supercls</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Try to atomically set CLS_INITIALIZING.</span></span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!cls-&gt;is<span class="constructor">Initialized()</span><span class="operator"> &amp;&amp; </span>!cls-&gt;is<span class="constructor">Initializing()</span>) &#123;</span><br><span class="line">            cls-&gt;set<span class="constructor">Initializing()</span>;</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     call<span class="constructor">Initialize(<span class="params">cls</span>)</span>;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出，如果一个类，其父类没有初始化，就递归调用该方法进行初始化。最终调用callInitialize进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，调用到objc_msgSend 方法，那我们继续看objc_msgSend源码，发现是汇编代码<br>截取部分如下:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">	.data</span><br><span class="line">	<span class="selector-class">.align</span> <span class="number">3</span></span><br><span class="line">	<span class="selector-class">.globl</span> _objc_debug_taggedpointer_classes</span><br><span class="line">_objc_debug_taggedpointer_classes:</span><br><span class="line">	<span class="selector-class">.fill</span> <span class="number">16</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line">	<span class="selector-class">.globl</span> _objc_debug_taggedpointer_ext_classes</span><br><span class="line">_objc_debug_taggedpointer_ext_classes:</span><br><span class="line">	<span class="selector-class">.fill</span> <span class="number">256</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #<span class="number">0</span>			<span class="comment">// nil check and tagged pointer check</span></span><br><span class="line"><span class="selector-id">#if</span> SUPPORT_TAGGED_POINTERS</span><br><span class="line">	<span class="selector-tag">b</span><span class="selector-class">.le</span>	LNilOrTagged		<span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">	<span class="selector-tag">b</span><span class="selector-class">.eq</span>	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	ldr	p13, [x0]		<span class="comment">// p13 = isa</span></span><br><span class="line">	GetClassFromIsa_p16 p13		<span class="comment">// p16 = class</span></span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL</span><br></pre></td></tr></table></figure>

<p>这也说明了，objc_msgSend性能高的原因，是因为直接操作汇编。</p>
<p>上述流程，用伪代码表示就是如下，其中<br>YZStudent 继承自 YZPerson</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (YZStudent没有初始化) &#123;</span><br><span class="line">   <span class="selector-tag">if</span>(YZPerson没有初始化)&#123;</span><br><span class="line">      <span class="selector-tag">objc_msgSend</span>([YZPerson class]，<span class="variable">@selector</span>(initialize));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">objc_msgSend</span>([YZStudent class]，<span class="variable">@selector</span>(initialize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点</p>
<ul>
<li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li>
<li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li>
</ul>
<h2 id="对比-load-和-initialize-的总结"><a href="#对比-load-和-initialize-的总结" class="headerlink" title="对比 +load 和 + initialize 的总结"></a>对比 +load 和 + initialize 的总结</h2><h3 id="load、initialize方法的区别什么？"><a href="#load、initialize方法的区别什么？" class="headerlink" title="load、initialize方法的区别什么？"></a>load、initialize方法的区别什么？</h3><ol>
<li><p>调用方式</p>
<ul>
<li>load是根据函数地址直接调用</li>
<li>initialize是通过objc_msgSend调用</li>
</ul>
</li>
<li><p>调用时刻</p>
<ul>
<li>load是runtime加载类、分类的时候调用（只会调用1次）</li>
<li>initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）</li>
</ul>
</li>
<li><p>load、initialize的调用顺序？</p>
<ol>
<li><p>load</p>
<ol>
<li><p>先调用类的load</p>
<ul>
<li>先编译的类，优先调用load</li>
<li>调用子类的load之前，会先调用父类的load</li>
</ul>
</li>
<li><p>再调用分类的load</p>
<ul>
<li>先编译的分类，优先调用load</li>
</ul>
</li>
</ol>
</li>
<li><p>initialize</p>
<ol>
<li>先初始化父类</li>
<li>再初始化子类（可能最终调用的是父类的initialize方法）        </li>
</ol>
</li>
</ol>
</li>
</ol>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a>        </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>详解iOS中的关联对象</title>
    <url>/%E8%AF%A6%E8%A7%A3iOS%E4%B8%AD%E7%9A%84%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1.html/</url>
    <content><![CDATA[<p>首发于<a href="https://ityongzhen.github.io/详解iOS中的关联对象.html">我的个人博客</a></p>
<h2 id="从给分类添加属性说起"><a href="#从给分类添加属性说起" class="headerlink" title="从给分类添加属性说起"></a>从给分类添加属性说起</h2><p>在<a href="https://juejin.im/post/5d204b77f265da1bcc196313" target="_blank" rel="noopener">详解iOS中分类Cateogry</a> 一文中，我们提出一个问题，</p>
<h3 id="Category能否添加成员变量？如果可以，如何给Category添加成员变量？"><a href="#Category能否添加成员变量？如果可以，如何给Category添加成员变量？" class="headerlink" title="Category能否添加成员变量？如果可以，如何给Category添加成员变量？"></a>Category能否添加成员变量？如果可以，如何给Category添加成员变量？</h3><ul>
<li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果,用关联对象技术</li>
</ul>
<p>那这里就详细说明</p>
<h3 id="添加属性，实际上都做了什么"><a href="#添加属性，实际上都做了什么" class="headerlink" title="添加属性，实际上都做了什么"></a>添加属性，实际上都做了什么</h3><p>首先我们要回忆一下，添加属性，实际上做了三件事</p>
<ul>
<li>生成成员变量</li>
<li>生成set方法和get方法的声明</li>
<li>生成set方法和get方法的实现</li>
</ul>
<p>eg：<br>定义一个 <code>YZPerson</code> 类，并定义<code>age</code>属性</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>就相当于干了三件事</p>
<ul>
<li>生成成员变量<code>_age</code></li>
<li>生成<code>set</code>方法和<code>get</code>方法的声明</li>
<li>生成<code>set</code>方法和<code>get</code>方法的实现<br>如下</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age;</span><br><span class="line">- (<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<h3 id="那在分类中添加属性怎么就不行？"><a href="#那在分类中添加属性怎么就不行？" class="headerlink" title="那在分类中添加属性怎么就不行？"></a>那在分类中添加属性怎么就不行？</h3><h4 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h4><ul>
<li>生成成员变量<code>_age</code></li>
<li>会生成<code>set</code>方法和<code>get</code>方法的声明</li>
<li>不会生成<code>set</code>方法和<code>get</code>方法的实现</li>
</ul>
<h4 id="不会生成set方法和get方法的实现"><a href="#不会生成set方法和get方法的实现" class="headerlink" title="不会生成set方法和get方法的实现"></a>不会生成<code>set</code>方法和<code>get</code>方法的实现</h4><p>定义一个分类 <code>YZPerson+Ext.h</code>，然后添加属性<code>weight</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>)  <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZPerson *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.weight = 10;</span><br></pre></td></tr></table></figure>

<p>会直接报错，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">iOS-关联对象[1009:10944]</span> <span class="string">***</span> <span class="string">Terminating</span> <span class="string">app</span> <span class="string">due</span> <span class="string">to</span> <span class="string">uncaught</span> <span class="string">exception</span> <span class="string">'NSInvalidArgumentException'</span><span class="string">,</span> </span><br><span class="line"><span class="attr">reason:</span> <span class="string">'-[YZPerson setWeight:]: unrecognized selector sent to instance 0x10182bd10'</span></span><br><span class="line"><span class="string">***</span> <span class="attr">First throw call stack:</span></span><br><span class="line"><span class="string">(</span></span><br><span class="line">	<span class="number">0</span>   <span class="string">CoreFoundation</span>                      <span class="number">0x00007fff3550d063</span> <span class="string">__exceptionPreprocess</span> <span class="string">+</span> <span class="number">250</span></span><br><span class="line">	<span class="number">1</span>   <span class="string">libobjc.A.dylib</span>                     <span class="number">0x00007fff6ac8e06b</span> <span class="string">objc_exception_throw</span> <span class="string">+</span> <span class="number">48</span></span><br><span class="line">	<span class="number">2</span>   <span class="string">CoreFoundation</span>                      <span class="number">0x00007fff355961bd</span> <span class="string">-[NSObject(NSObject)</span> <span class="string">__retain_OA]</span> <span class="string">+</span> <span class="number">0</span></span><br><span class="line">	<span class="number">3</span>   <span class="string">CoreFoundation</span>                      <span class="number">0x00007fff354b34b4</span> <span class="string">___forwarding___</span> <span class="string">+</span> <span class="number">1427</span></span><br><span class="line">	<span class="number">4</span>   <span class="string">CoreFoundation</span>                      <span class="number">0x00007fff354b2e98</span> <span class="string">_CF_forwarding_prep_0</span> <span class="string">+</span> <span class="number">120</span></span><br><span class="line">	</span><br><span class="line">	<span class="number">6</span>   <span class="string">libdyld.dylib</span>                       <span class="number">0x00007fff6c0183f9</span> <span class="string">start</span> <span class="string">+</span> <span class="number">1</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">libc++abi.dylib:</span> <span class="string">terminating</span> <span class="string">with</span> <span class="string">uncaught</span> <span class="string">exception</span> <span class="string">of</span> <span class="string">type</span> <span class="string">NSException</span></span><br><span class="line"><span class="attr">Program ended with exit code:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>从 <code>reason: &#39;-[YZPerson setWeight:]: unrecognized selector sent to instance 0x10182bd10&#39;</code> 可知，分类中添加属性，没有生成<code>set</code>方法和<code>get</code>方法的实现</p>
<h4 id="会生成set方法和get方法的声明"><a href="#会生成set方法和get方法的声明" class="headerlink" title="会生成set方法和get方法的声明"></a>会生成<code>set</code>方法和<code>get</code>方法的声明</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+Ext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>然后再调用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">YZPerson *person = <span class="literal">[[YZP<span class="identifier">erson</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">person.age = <span class="number">25</span>;</span><br><span class="line">person.weight = <span class="number">10</span>;</span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"person.age = %d"</span>,<span class="params">person</span>.<span class="params">age</span>)</span>;</span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"person.weight = %d"</span>,<span class="params">person</span>.<span class="params">weight</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-10</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">04.406972</span>+<span class="number">0800</span> iOS-关联对象[<span class="number">1620</span>:<span class="number">18520</span>] person.age = <span class="number">25</span></span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-10</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">04.407291</span>+<span class="number">0800</span> iOS-关联对象[<span class="number">1620</span>:<span class="number">18520</span>] person.weight = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>进一步证明了，不会生成<code>set</code>方法和<code>get</code>方法的实现，但是会生成<code>set</code>方法和<code>get</code>方法的声明，因为如果没有生成<code>set</code>方法和<code>get</code>方法的声明，这个方法就不能调用。</p>
<p>我们还可以这样：在<code>YZPerson+Ext.h</code>文件中声明了<code>weight</code>,然后再<code>YZPerson+Ext.m</code>中写实现的时候，会有提示的</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde91859761ab0?w=1068&h=284&f=png&s=157470" alt=""></p>
<p>更加说明了是有声明的。</p>
<h4 id="分类中不能直接定义成员变量"><a href="#分类中不能直接定义成员变量" class="headerlink" title="分类中不能直接定义成员变量"></a>分类中不能直接定义成员变量</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _weight; <span class="comment">// 报错 Instance variables may not be placed in categories</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>)  <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>会直接报错<code>Instance variables may not be placed in categories</code>,成员变量不能定义在分类中</p>
<h4 id="源码角度证明"><a href="#源码角度证明" class="headerlink" title="源码角度证明"></a>源码角度证明</h4><p>前面的文章<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3iOS%E4%B8%AD%E5%88%86%E7%B1%BBCateogry.html">详解iOS中分类Cateogry</a> 中分析过源码，objc-runtime-new.h中分类结构体是这样的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可知，这个结构体中，没有数组存放成员变量，只有属性，协议等。</p>
<h2 id="怎么来完善属性"><a href="#怎么来完善属性" class="headerlink" title="怎么来完善属性"></a>怎么来完善属性</h2><p>有什么办法可以实现在分类中添加属性和在类中添加属性一样的效果么？答案是有的</p>
<h3 id="方案一-用全局变量"><a href="#方案一-用全局变量" class="headerlink" title="方案一 用全局变量"></a>方案一 用全局变量</h3><p>分类<code>YZPerson+Ext.m</code>中定义全局变量 <code>_weight</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+Ext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _weight;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight&#123;</span><br><span class="line">    _weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight&#123;</span><br><span class="line">    <span class="keyword">return</span> _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用时候</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZPerson *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.weight = 103;</span><br><span class="line">NSLog(@<span class="string">"person.weight = %d"</span>,<span class="keyword">person</span>.weight);</span><br></pre></td></tr></table></figure>


<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-关联对象[<span class="number">1983</span>:<span class="number">23793</span>] person.weight = <span class="number">103</span></span><br></pre></td></tr></table></figure>

<p>看起来确实可以，然后实际上我们不能这么用，因为，全局变量是共享的，假设有两个 <code>Person</code>,第二个<code>Person</code>修改了weight属性，然后打印第一个<code>Person.weight</code></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">YZPerson *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.weight = 103;</span><br><span class="line">NSLog(@<span class="string">"person.weight = %d"</span>,<span class="keyword">person</span>.weight);</span><br><span class="line"></span><br><span class="line">YZPerson *person2 = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br><span class="line">person2.weight = 10;</span><br><span class="line">NSLog(@<span class="string">"person.weight = %d"</span>,<span class="keyword">person</span>.weight);</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-关联对象[<span class="number">1983</span>:<span class="number">23793</span>] person.weight = <span class="number">103</span></span><br><span class="line">iOS-关联对象[<span class="number">1983</span>:<span class="number">23793</span>] person.weight = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可知，修改了<code>Person2.weight</code> 会改变<code>Person.weight</code>的值，因为是全局变量的缘故。所以这种方法不行</p>
<h3 id="方案二-用字典"><a href="#方案二-用字典" class="headerlink" title="方案二 用字典"></a>方案二 用字典</h3><p>既然前面方案不能用的原因是全局变量，共享一份，那我们是不是只要保证，一对一的关系，是不是就可以了呢？</p>
<p>定义 字典<code>weights_</code> 以对象的地址值作为<code>key</code>来，<code>weight</code>的值作为<code>value</code>来存储和使用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+Ext.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *weights_;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 写在这里，保证s只初始化一次</span></span><br><span class="line">        weights_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>,<span class="keyword">self</span>];<span class="comment">//self 地址值作为key</span></span><br><span class="line">    weights_[key] = @(weight);<span class="comment">//字典中的value不能直接放int，需要包装成对象</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight&#123;</span><br><span class="line">     <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>,<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span>  [weights_[key] intValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde9185962846f?w=1159&h=553&f=png&s=304359" alt=""></p>
<p>这样的话，使用起来，就不会因为不同对象而干扰了<br>结果如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde9185995ab92?w=755&h=532&f=png&s=114477" alt=""></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul>
<li>因为是全局的，存在内存泄露问题</li>
<li>线程安全问题，多个线程同时访问的话，有线程安全问题</li>
<li>代码太多，如果每次增加一个属性，都要写好多代码。不利于维护</li>
</ul>
<h2 id="关联对象方案"><a href="#关联对象方案" class="headerlink" title="关联对象方案"></a>关联对象方案</h2><h3 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h3><p>下面先简单说明关联对象的使用</p>
<h3 id="动态添加"><a href="#动态添加" class="headerlink" title="动态添加"></a>动态添加</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">objc<span class="constructor">_setAssociatedObject(<span class="params">id</span> <span class="params">object</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>, <span class="params">id</span> <span class="params">value</span>, <span class="params">objc_AssociationPolicy</span> <span class="params">policy</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数一：<code>id object</code> : 给哪个对象添加属性，这里要给自己添加属性，用<code>self</code>。</li>
<li>参数二：<code>void * == id key</code> : <code>key</code>值，根据key获取关联对象的属性的值，在<code>objc_getAssociatedObject</code>中通过次<code>key</code>获得属性的值并返回。</li>
<li>参数三：<code>id value</code> : 关联的值，也就是<code>set</code>方法传入的值给属性去保存。</li>
<li>参数四：<code>objc_AssociationPolicy policy</code>: 策略，属性以什么形式保存。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(<span class="built_in">uint</span>ptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,  <span class="comment">// 指定一个弱引用相关联的对象</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">// 指定相关对象的强引用，非原子性</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,  <span class="comment">// 指定相关的对象被复制，非原子性</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,  <span class="comment">// 指定相关对象的强引用，原子性</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>     <span class="comment">// 指定相关的对象被复制，原子性   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>整理成表格如下</p>
<table>
<thead>
<tr>
<th align="left">objc_AssociationPolicy</th>
<th align="center">对应的修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OBJC_ASSOCIATION_ASSIGN</td>
<td align="center">assign</td>
</tr>
<tr>
<td align="left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td align="center">strong, nonatomic</td>
</tr>
<tr>
<td align="left">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td align="center">copy, nonatomic</td>
</tr>
<tr>
<td align="left">OBJC_ASSOCIATION_RETAIN</td>
<td align="center">strong, atomic</td>
</tr>
<tr>
<td align="left">OBJC_ASSOCIATION_COPY</td>
<td align="center">copy, atomic</td>
</tr>
</tbody></table>
<p>eg: 我们在代码中使用了 <code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 就相当于使用了 <code>nonatomic</code> 和 <code>strong</code> 修饰符。</p>
<p><strong>注意点</strong><br>上面列表中，没有对应<code>weak</code>修饰的策略，<br>原因是<br><code>object</code>经过<code>DISGUISE</code>函数被转化为了<code>disguised_ptr_t</code>类型的<code>disguised_object</code>。</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br></pre></td></tr></table></figure>
<p>而<code>weak</code>修饰的属性，当没有拥有对象之后就会被销毁，并且指针置为<code>nil</code>，那么在对象销毁之后，虽然在<code>map</code>中仍然存在值<code>object</code>对应的<code>AssociationsHashMap</code>，但是因为<code>object</code>地址已经被置为<code>nil</code>，会造成坏地址访问而无法根据<code>object</code>对象的地址转化为<code>disguised_object</code>了,这段话可以再看完全文之后，再回来体会下。</p>
<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">objc<span class="constructor">_getAssociatedObject(<span class="params">id</span> <span class="params">object</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数一：<code>id object</code> : 获取哪个对象里面的关联的属性。 </li>
<li>参数二：<code>void * == id key</code> : 什么属性，与<code>objc_setAssociatedObject</code>中的<code>key</code>相对应，即通过<code>key</code>值取出<code>value</code>。</li>
</ul>
<h3 id="移除关联对象"><a href="#移除关联对象" class="headerlink" title="移除关联对象"></a>移除关联对象</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">- <span class="comment">(void)</span>removeAssociatedObjects</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除关联对象</span></span><br><span class="line">    objc_removeAssociatedObjects<span class="comment">(self)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+Ext.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">Ext</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *YZNameKey = &amp;YZNameKey;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, YZNameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">   <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, YZNameKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    objc_removeAssociatedObjects(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用的时候，正常使用，就可以了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">YZPerson *person = <span class="literal">[[YZP<span class="identifier">erson</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">person.name = @<span class="string">"jack"</span>;</span><br><span class="line"></span><br><span class="line">YZPerson *person2 = <span class="literal">[[YZP<span class="identifier">erson</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">person2.name = @<span class="string">"rose"</span>;</span><br><span class="line">        </span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"person.name = %@"</span>,<span class="params">person</span>.<span class="params">name</span>)</span>;</span><br><span class="line"><span class="constructor">NSLog(@<span class="string">"person2.name = %@"</span>,<span class="params">person2</span>.<span class="params">name</span>)</span>;</span><br></pre></td></tr></table></figure>


<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iOS-关联对象[<span class="number">4266</span>:<span class="number">52285</span>] person.name = jack</span><br><span class="line">iOS-关联对象[<span class="number">4266</span>:<span class="number">52285</span>] person2.name = rose</span><br></pre></td></tr></table></figure>

<p>使用起来就是这么简单</p>
<h2 id="关联对象原理"><a href="#关联对象原理" class="headerlink" title="关联对象原理"></a>关联对象原理</h2><h3 id="四个核心对象"><a href="#四个核心对象" class="headerlink" title="四个核心对象"></a>四个核心对象</h3><p>实现关联对象技术的核心对象有</p>
<ul>
<li>AssociationsManager</li>
<li>AssociationsHashMap</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ul>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>关联对象的源码在 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a>中</p>
<h4 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a><code>objc_setAssociatedObject</code></h4><p>查看<code>objc-runtime.mm</code>类，首先找到<code>objc_setAssociatedObject</code>函数，看一下其实现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void objc<span class="constructor">_setAssociatedObject(<span class="params">id</span> <span class="params">object</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>, <span class="params">id</span> <span class="params">value</span>, <span class="params">objc_AssociationPolicy</span> <span class="params">policy</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">_object_set_associative_reference(<span class="params">object</span>, (<span class="params">void</span> <span class="operator">*</span>)</span>key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="_object_set_associative_reference"></a><code>_object_set_associative_reference</code></h4><p>查看</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void <span class="constructor">_object_set_associative_reference(<span class="params">id</span> <span class="params">object</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>, <span class="params">id</span> <span class="params">value</span>, <span class="params">uintptr_t</span> <span class="params">policy</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old<span class="constructor">_association(0, <span class="params">nil</span>)</span>;</span><br><span class="line">    id new_value = value ? acquire<span class="constructor">Value(<span class="params">value</span>, <span class="params">policy</span>)</span> : nil;</span><br><span class="line">    &#123;</span><br><span class="line">    	</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations<span class="literal">()</span>);</span><br><span class="line">        disguised_ptr_t disguised_object = <span class="constructor">DISGUISE(<span class="params">object</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.<span class="keyword">end</span><span class="literal">()</span>) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="keyword">end</span><span class="literal">()</span>) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = <span class="constructor">ObjcAssociation(<span class="params">policy</span>, <span class="params">new_value</span>)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)<span class="literal">[<span class="identifier">key</span>]</span> = <span class="constructor">ObjcAssociation(<span class="params">policy</span>, <span class="params">new_value</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations<span class="literal">[<span class="identifier">disguised_object</span>]</span> = refs;</span><br><span class="line">                (*refs)<span class="literal">[<span class="identifier">key</span>]</span> = <span class="constructor">ObjcAssociation(<span class="params">policy</span>, <span class="params">new_value</span>)</span>;</span><br><span class="line">                object-&gt;set<span class="constructor">HasAssociatedObjects()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.<span class="keyword">end</span><span class="literal">()</span>) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="keyword">end</span><span class="literal">()</span>) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.has<span class="constructor">Value()</span>) <span class="constructor">ReleaseValue()</span>(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde9185a849239?w=2174&h=1462&f=png&s=415822" alt=""></p>
<p><code>_object_set_associative_reference</code>函数内部我们可以找到我们上面说过的实现关联对象技术的四个核心对象。接下来我们来一个一个看其内部实现原理探寻他们之间的关系。</p>
<h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a><code>AssociationsManager</code></h4><p>查看 <code>AssociationsManager</code> 我们知道<code>AssociationsManager</code> 内部有<code>static AssociationsHashMap *_map;</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    <span class="comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">AssociationsManager()</span>   &#123; <span class="module-access"><span class="module"><span class="identifier">AssociationsManagerLock</span>.</span></span>lock<span class="literal">()</span>; &#125;</span><br><span class="line">    ~<span class="constructor">AssociationsManager()</span>  &#123; <span class="module-access"><span class="module"><span class="identifier">AssociationsManagerLock</span>.</span></span>unlock<span class="literal">()</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map<span class="operator"> == </span>NULL)</span><br><span class="line">            _map = <span class="keyword">new</span> <span class="constructor">AssociationsHashMap()</span>;</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="AssociationsHashMap"><a href="#AssociationsHashMap" class="headerlink" title="AssociationsHashMap"></a><code>AssociationsHashMap</code></h4><p>接下来看 <code>AssociationsHashMap</code><br><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde9185a9ae0f4?w=2366&h=1438&f=png&s=469605" alt=""></p>
<p>上图中 <code>AssociationsHashMap</code>的源码我们发现<code>AssociationsHashMap</code>继承自<code>unordered_map</code>首先来看一下<code>unordered_map</code>内的源码</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde9185d81f1f1?w=2120&h=986&f=png&s=342730" alt=""></p>
<p>从<code>unordered_map</code>源码中我们可以看出 参数 <code>_Key</code>和<code>_Tp</code> 对应着<code>map</code>中的<code>Key</code>和<code>Value</code>，那么对照上面<code>AssociationsHashMap</code>的源码，可以发现<code>_Key</code>中传入的是<code>unordered_map&lt;disguised_ptr_t</code>，<code>_Tp</code>中传入的值则为<code>ObjectAssociationMap *</code>。</p>
<p>然后 我们查看<code>ObjectAssociationMap</code>的源码，上图中<code>ObjectAssociationMap</code>已经标记出，我们可以知道<code>ObjectAssociationMap</code>中同样以<code>key</code>、<code>Value</code>的方式存储着<code>ObjcAssociation</code>。</p>
<h4 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a><code>ObjcAssociation</code></h4><p>接着我们来到<code>ObjcAssociation</code>中，可以看到</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjcAssociation &#123;</span><br><span class="line">       uintptr_t _policy; <span class="comment">// 策略</span></span><br><span class="line">       id _value; <span class="comment">// value值</span></span><br><span class="line">   public:</span><br><span class="line">       <span class="constructor">ObjcAssociation(<span class="params">uintptr_t</span> <span class="params">policy</span>, <span class="params">id</span> <span class="params">value</span>)</span> : <span class="constructor">_policy(<span class="params">policy</span>)</span>, <span class="constructor">_value(<span class="params">value</span>)</span> &#123;&#125;</span><br><span class="line">       <span class="constructor">ObjcAssociation()</span> : <span class="constructor">_policy(0)</span>, <span class="constructor">_value(<span class="params">nil</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">       uintptr_t policy<span class="literal">()</span> const &#123; return _policy; &#125;</span><br><span class="line">       id value<span class="literal">()</span> const &#123; return _value; &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">bool</span> has<span class="constructor">Value()</span> &#123; return _value != nil; &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们发现<code>ObjcAssociation</code>存储着<code>_policy</code>和<code>_value</code>，而这两个值我们可以发现正是我们调用<code>objc_setAssociatedObject</code>函数传入的值，换句话说我们在调用<code>objc_setAssociatedObject</code>函数中传入<code>value</code>和<code>policy</code>这两个值最终是存储在<code>ObjcAssociation</code>中的。</p>
<p>现在我们已经对四个核心对象<code>AssociationsManager</code>、 <code>AssociationsHashMap</code>、 <code>ObjectAssociationMap</code>、<code>ObjcAssociation</code>之间的关系有了初步的了解，那么接下继续仔细阅读源码，看一下<code>objc_setAssociatedObject</code>函数中传入的四个参数分别放在哪个对象中充当什么作用</p>
<h4 id="细读-object-set-associative-reference"><a href="#细读-object-set-associative-reference" class="headerlink" title="细读 _object_set_associative_reference"></a>细读 <code>_object_set_associative_reference</code></h4><p><code>_object_set_associative_reference</code>的代码中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    // retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    // 根据value的值通过acquireValue函数获取得到new_value</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        // 获取 manager 内的 AssociationsHashMap 也就是 associations</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        // object 经过 DISGUISE 函数被转化为了disguised_ptr_t类型的disguised_object</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            // break any existing association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    // policy和new_value 作为键值对存入了ObjcAssociation</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // policy和new_value 作为键值对存入了ObjcAssociation</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 来到这里说明，value为空</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    //移除关联对象</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong><code>acquireValue</code></strong>内部实现 通过对策略的判断返回不同的值</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">static<span class="built_in"> id</span> acquireValue<span class="built_in">(id</span> <span class="keyword">value</span>, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> objc_retain(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">(id</span>(*)<span class="built_in">(id</span>, SEL))objc_msgSend)(<span class="keyword">value</span>, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先根据我们传入的<code>value</code>经过<code>acquireValue</code>函数处理返回了<code>new_value</code>。<code>acquireValue</code>函数内部其实是通过对策略的判断返回不同的值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">disguised_ptr_t</span>;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> disguised_ptr_t <span class="title">DISGUISE</span><span class="params">(id value)</span> </span>&#123; <span class="keyword">return</span> ~<span class="keyword">uintptr_t</span>(value); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> id <span class="title">UNDISGUISE</span><span class="params">(<span class="keyword">disguised_ptr_t</span> dptr)</span> </span>&#123; <span class="keyword">return</span> id(~dptr); &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后创建<code>AssociationsManager manager</code>,得到<code>manager</code>内部的<code>AssociationsHashMap</code>即<code>associations</code>。<br>之后我们看到了我们传入的第一个参数<code>object</code>经过<code>DISGUISE</code>函数被转化为了<code>disguised_ptr_t</code>类型的<code>disguised_object</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">disguised_ptr_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> disguised_ptr_t <span class="title">DISGUISE</span><span class="params">(id value)</span> </span>&#123; <span class="keyword">return</span> ~<span class="keyword">uintptr_t</span>(value); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> id <span class="title">UNDISGUISE</span><span class="params">(<span class="keyword">disguised_ptr_t</span> dptr)</span> </span>&#123; <span class="keyword">return</span> id(~dptr); &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后被处理成<code>new_value</code>的<code>value</code>，和<code>policy</code>一起被存入了<code>ObjcAssociation</code>中。<br>而<code>ObjcAssociation</code>对应我们传入的<code>key</code>被存入了<code>ObjectAssociationMap</code>中。<br><code>disguised_object</code>和<code>ObjectAssociationMap</code>则以<code>key-value</code>的形式对应存储在<code>associations</code>中也就是<code>AssociationsHashMap</code>中。</li>
</ul>
<h4 id="value为空"><a href="#value为空" class="headerlink" title="value为空"></a>value为空</h4><p>如果传入的value为空，那么就删除这个关联对象</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来到这里说明，value为空</span></span><br><span class="line">        <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">            O<span class="function"><span class="title">bjectAssociationMap</span> *refs = i-&gt;</span>second;</span><br><span class="line">            O<span class="function"><span class="title">bjectAssociationMap</span>::iterator j = refs-&gt;</span>find(key);</span><br><span class="line">            <span class="function"><span class="title">if</span> (j != refs-&gt;</span>end()) &#123;</span><br><span class="line">                <span class="function"><span class="title">old_association</span> = j-&gt;</span>second;</span><br><span class="line">                <span class="comment">//移除关联对象</span></span><br><span class="line">                <span class="function"><span class="title">refs</span>-&gt;</span>erase(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h4 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h4><p>用表格总结来展示这几个核心类的关系如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde918b73b14ee?w=851&h=408&f=png&s=78237" alt=""></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>关联对象并不存储在被关联对象本身内存中，而是有一个全局统一的 <code>AssociationsManager</code>中</li>
<li>一个实例对象就对应一个<code>ObjectAssociationMap</code>，</li>
<li>而<code>ObjectAssociationMap</code>中存储着多个此实例对象的关联对象的<code>key</code>以及<code>ObjcAssociation</code>，</li>
<li><code>ObjcAssociation</code>中存储着关联对象的<code>value</code>和<code>policy</code>策略</li>
</ul>
<h4 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a><strong>objc_getAssociatedObject</strong></h4><p><code>objc_getAssociatedObject</code>内部调用的是<code>_object_get_associative_reference</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">id objc<span class="constructor">_getAssociatedObject(<span class="params">id</span> <span class="params">object</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>)</span> &#123;</span><br><span class="line">    return <span class="constructor">_object_get_associative_reference(<span class="params">object</span>, (<span class="params">void</span> <span class="operator">*</span>)</span>key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-get-associative-reference函数"><a href="#object-get-associative-reference函数" class="headerlink" title="_object_get_associative_reference函数"></a><code>_object_get_associative_reference</code>函数</h4><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">id _object_get_associative_reference(<span class="name">id</span> object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        // 查找 disguised_object</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            //查看key 和value</span><br><span class="line">            ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">            if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation <span class="symbol">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">                value = entry.value()<span class="comment">;</span></span><br><span class="line">                policy = entry.policy()<span class="comment">;</span></span><br><span class="line">                // 存在key 和value 就取出对应的值</span><br><span class="line">                if (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(<span class="name">value</span>)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">value</span> <span class="symbol">&amp;&amp;</span> (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        // 不存在key value 就把这个关联对象擦除</span><br><span class="line">        objc_autorelease(<span class="name">value</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码已经在上文中给了注释</p>
<h4 id="objc-removeAssociatedObjects函数"><a href="#objc-removeAssociatedObjects函数" class="headerlink" title="objc_removeAssociatedObjects函数"></a><code>objc_removeAssociatedObjects</code>函数</h4><p><code>objc_removeAssociatedObjects</code>函数用来删除所有关联对象，内部调用了<code>_object_remove_assocations</code></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="function"><span class="title">objc_removeAssociatedObjects</span>(<span class="variable">id</span> <span class="variable"><span class="class">object</span></span>) </span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="variable"><span class="class">object</span></span> &amp;&amp; <span class="variable"><span class="class">object</span></span>-&gt;<span class="title">hasAssociatedObjects</span>()) &#123;</span></span><br><span class="line"><span class="function">        <span class="title">_object_remove_assocations</span>(<span class="variable"><span class="class">object</span></span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="object-remove-assocations"><a href="#object-remove-assocations" class="headerlink" title="_object_remove_assocations"></a><code>_object_remove_assocations</code></h4><p>再来看看<code>_object_remove_assocations</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_object_remove_assocations(<span class="params">id</span> <span class="params">object</span>)</span> &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations<span class="literal">()</span>);</span><br><span class="line">        <span class="keyword">if</span> (associations.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span>) return;</span><br><span class="line">        disguised_ptr_t disguised_object = <span class="constructor">DISGUISE(<span class="params">object</span>)</span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="keyword">end</span><span class="literal">()</span>) &#123; <span class="comment">// 遍历AssociationsHashMap 取出值</span></span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;<span class="keyword">begin</span><span class="literal">()</span>, <span class="keyword">end</span> = refs-&gt;<span class="keyword">end</span><span class="literal">()</span>; j != <span class="keyword">end</span>; ++j) &#123;</span><br><span class="line">                elements.push<span class="constructor">_back(<span class="params">j</span>-&gt;<span class="params">second</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            delete refs;</span><br><span class="line">            <span class="comment">// 删除</span></span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for<span class="constructor">_each(<span class="params">elements</span>.<span class="params">begin</span>()</span>, elements.<span class="keyword">end</span><span class="literal">()</span>, <span class="constructor">ReleaseValue()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中可以看出，接受一个<code>object</code>对象，然后遍历删除该对象所有的关联对象</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用表格总结来展示这几个核心类的关系如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde918b73b14ee?w=851&h=408&f=png&s=78237" alt=""></p>
<ul>
<li>关联对象并不存储在被关联对象本身内存中，而是有一个全局统一的 <code>AssociationsManager</code>中</li>
<li>一个实例对象就对应一个<code>ObjectAssociationMap</code>，</li>
<li>而<code>ObjectAssociationMap</code>中存储着多个此实例对象的关联对象的<code>key</code>以及<code>ObjcAssociation</code>，</li>
<li><code>ObjcAssociation</code>中存储着关联对象的<code>value</code>和<code>policy</code>策略</li>
<li>删除的时候接收一个<code>object</code>对象，然后遍历删除该对象所有的关联对象</li>
<li>设置关联对象<code>_object_set_associative_reference</code>的是时候，如果传入的<code>value</code>为空就删除这个关联对象</li>
</ul>
<p>本文参考资料:</p>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS自动打包</title>
    <url>/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/KVC%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过之前<a href="https://ityongzhen.github.io/categories/Shell/">Shell脚本</a>的学习,整理iOS自动打包脚本</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法:</span></span><br><span class="line"><span class="comment"># step1: 将该脚本放在工程的根目录下（跟.xcworkspace文件or .xcodeproj文件同目录）</span></span><br><span class="line"><span class="comment"># step2: 根据情况修改下面的参数</span></span><br><span class="line"><span class="comment"># step3: 打开终端，执行脚本。（输入sh ，然后将脚本文件拉到终端，会生成文件路径，然后enter就可）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============项目自定义部分(自定义好下列参数后再执行该脚本)=================== #</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否编译工作空间 (例:若是用Cocopods管理的.xcworkspace项目,赋值true;用Xcode默认创建的.xcodeproj,赋值false)</span></span><br><span class="line">is_workspace=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># .xcworkspace的名字，如果is_workspace为true，则必须填。否则可不填</span></span><br><span class="line">workspace_name=<span class="string">"xcworkspace的名字"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># .xcodeproj的名字，如果is_workspace为false，则必须填。否则可不填</span></span><br><span class="line">project_name=<span class="string">"xcworkspace的名字"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目的scheme名称（也就是工程的target名称），必填</span></span><br><span class="line">scheme_name=<span class="string">"xcworkspace的名字"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要打包编译的方式 : Release,Debug。一般用Release。必填</span></span><br><span class="line">build_configuration=<span class="string">"Release"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># method，打包的方式。方式分别为 development, ad-hoc, app-store, enterprise 。必填</span></span><br><span class="line">echo <span class="string">"Place enter the number you want to export ? \033[33;1m [1:app-store 2:ad-hoc 3:development 4:enterprise 5:gitlog]\033[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">read</span> number</span><br><span class="line"><span class="keyword">while</span>([[ $number != <span class="number">1</span> ]] &amp;&amp; [[ $number != <span class="number">2</span> ]] &amp;&amp; [[ $number != <span class="number">3</span> ]] &amp;&amp; [[ $number != <span class="number">4</span> ]] &amp;&amp; [[ $number != <span class="number">5</span> ]])</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo <span class="string">"Place enter the number you want to export ? \033[33;1m [1:app-store 2:ad-hoc 3:development 4:enterprise 5:gitlog]\033[0m"</span></span><br><span class="line"><span class="keyword">read</span> number</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $number == <span class="number">1</span> ];then</span><br><span class="line">method=<span class="string">"app-store"</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $number == <span class="number">2</span> ];then</span><br><span class="line">method=<span class="string">"ad-hoc"</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $number == <span class="number">3</span> ];then</span><br><span class="line">method=<span class="string">"development"</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $number == <span class="number">4</span> ];then</span><br><span class="line">method=<span class="string">"development"</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  下面两个参数只是在手动指定Pofile文件的时候用到，如果使用Xcode自动管理Profile,直接留空就好</span></span><br><span class="line"><span class="comment"># (跟method对应的)mobileprovision文件名，需要先双击安装.mobileprovision文件.手动管理Profile时必填</span></span><br><span class="line">mobileprovision_name=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目的bundleID，手动管理Profile时必填</span></span><br><span class="line">bundle_identifier=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo <span class="string">"--------------------脚本配置参数检查--------------------"</span></span><br><span class="line">echo <span class="string">"\033[33;1mis_workspace=<span class="subst">$&#123;is_workspace&#125;</span> "</span></span><br><span class="line">echo <span class="string">"workspace_name=<span class="subst">$&#123;workspace_name&#125;</span>"</span></span><br><span class="line">echo <span class="string">"project_name=<span class="subst">$&#123;project_name&#125;</span>"</span></span><br><span class="line">echo <span class="string">"scheme_name=<span class="subst">$&#123;scheme_name&#125;</span>"</span></span><br><span class="line">echo <span class="string">"build_configuration=<span class="subst">$&#123;build_configuration&#125;</span>"</span></span><br><span class="line">echo <span class="string">"bundle_identifier=<span class="subst">$&#123;bundle_identifier&#125;</span>"</span></span><br><span class="line">echo <span class="string">"method=<span class="subst">$&#123;method&#125;</span>"</span></span><br><span class="line">echo <span class="string">"mobileprovision_name=<span class="subst">$&#123;mobileprovision_name&#125;</span> \033[0m"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =======================脚本的一些固定参数定义(无特殊情况不用修改)====================== #</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前脚本所在目录</span></span><br><span class="line">script_dir=<span class="string">"$( cd "</span>$( dirname <span class="string">"$0"</span>  )<span class="string">" &amp;&amp; pwd  )"</span></span><br><span class="line"><span class="comment"># 工程根目录</span></span><br><span class="line">project_dir=$script_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间</span></span><br><span class="line">DATE=<span class="string">`date '+%Y%m%d_%H%M%S'`</span></span><br><span class="line"><span class="comment"># 指定输出导出文件夹路径</span></span><br><span class="line">export_path=<span class="string">"$project_dir/Package/$scheme_name-$DATE"</span></span><br><span class="line"><span class="comment"># 指定输出归档文件路径</span></span><br><span class="line">export_archive_path=<span class="string">"$export_path/$scheme_name.xcarchive"</span></span><br><span class="line"><span class="comment"># 指定输出ipa文件夹路径</span></span><br><span class="line">export_ipa_path=<span class="string">"$export_path"</span></span><br><span class="line"><span class="comment"># 指定输出ipa名称</span></span><br><span class="line">ipa_name=<span class="string">"<span class="subst">$&#123;scheme_name&#125;</span>_<span class="subst">$&#123;DATE&#125;</span>"</span></span><br><span class="line"><span class="comment"># 指定导出ipa包需要用到的plist配置文件的路径</span></span><br><span class="line">export_options_plist_path=<span class="string">"$project_dir/ExportOptions.plist"</span></span><br><span class="line"></span><br><span class="line">dSYM_path=<span class="string">"$export_archive_path/dSYMs/$scheme_name.app.dSYM"</span></span><br><span class="line">new_dSYM_path=<span class="string">"$export_path/$scheme_name.app.dSYM"</span></span><br><span class="line">zip_dSYM_path=<span class="string">"$export_path/$scheme_name.app.dSYM.zip"</span></span><br><span class="line"></span><br><span class="line">echo <span class="string">"--------------------脚本固定参数检查--------------------"</span></span><br><span class="line">echo <span class="string">"\033[33;1mproject_dir=<span class="subst">$&#123;project_dir&#125;</span>"</span></span><br><span class="line">echo <span class="string">"DATE=<span class="subst">$&#123;DATE&#125;</span>"</span></span><br><span class="line">echo <span class="string">"export_path=<span class="subst">$&#123;export_path&#125;</span>"</span></span><br><span class="line">echo <span class="string">"export_archive_path=<span class="subst">$&#123;export_archive_path&#125;</span>"</span></span><br><span class="line">echo <span class="string">"export_ipa_path=<span class="subst">$&#123;export_ipa_path&#125;</span>"</span></span><br><span class="line">echo <span class="string">"export_options_plist_path=<span class="subst">$&#123;export_options_plist_path&#125;</span>"</span></span><br><span class="line">echo <span class="string">"ipa_name=<span class="subst">$&#123;ipa_name&#125;</span>"</span></span><br><span class="line">echo <span class="string">"zip_dSYM_path=<span class="subst">$&#123;zip_dSYM_path&#125;</span> \033[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =======================自动打包部分(无特殊情况不用修改)====================== #</span></span><br><span class="line"></span><br><span class="line">echo <span class="string">"------------------------------------------------------"</span></span><br><span class="line">echo <span class="string">"\033[32m开始构建项目  \033[0m"</span></span><br><span class="line"><span class="comment"># 进入项目工程目录</span></span><br><span class="line">cd $&#123;project_dir&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出文件目录不存在则创建</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"$export_path"</span> ] ; then</span><br><span class="line">    echo $export_path</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">mkdir</span> -pv $export_path</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $number == <span class="number">5</span> ];then</span><br><span class="line"></span><br><span class="line"><span class="comment">#git 日志路径</span></span><br><span class="line">txt_path=$export_path/<span class="string">`date +%Y-%m-%d-%H_%M_%S.html`</span></span><br><span class="line">temp_txt=$export_path/gitlog.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入 ipa 下载链接</span></span><br><span class="line"><span class="comment"># echo "&lt;div style='height: 40px;font-size: 20px;'&gt;iOS 安装包下载链接：&lt;a href=$&#123;ipa_link&#125;&gt;$ipa_link&lt;/a&gt;&lt;/div&gt;" &gt;&gt; $txt_path </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取 git 日志</span></span><br><span class="line">git <span class="keyword">log</span> --pretty=<span class="keyword">format</span>:<span class="string">"&lt;span style='font-size: 16px;'&gt;%ai,%an:&lt;/span&gt; &lt;span style='color: #469cf7;font-size: 16px;'&gt;%s&lt;/span&gt;&lt;br&gt;"</span> \</span><br><span class="line"> --<span class="keyword">no</span>-merges  &gt;&gt; $txt_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二行插入 &lt;div&gt;</span></span><br><span class="line">sed <span class="string">"2 i\ </span></span><br><span class="line"><span class="string">&lt;div style='letter-spacing: 0.5px;line-height: 25px'&gt;"</span> $txt_path &gt; $temp_txt</span><br><span class="line">echo <span class="string">`cat $temp_txt`</span> &gt; $txt_path </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后一行插入 &lt;/div&gt;</span></span><br><span class="line">sed <span class="string">"$ a\ </span></span><br><span class="line"><span class="string">&lt;/div&gt;"</span> $txt_path &gt; $temp_txt</span><br><span class="line">echo <span class="string">`cat $temp_txt`</span> &gt; $txt_path </span><br><span class="line"></span><br><span class="line"><span class="comment">#移除中间转换文件</span></span><br><span class="line">rm -f $temp_txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开文件夹</span></span><br><span class="line"><span class="keyword">open</span> $export_path</span><br><span class="line"><span class="keyword">open</span> $txt_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span> <span class="number">0</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断编译的项目类型是workspace还是project</span></span><br><span class="line"><span class="keyword">if</span> $is_workspace ; then</span><br><span class="line"><span class="comment"># 编译前清理工程</span></span><br><span class="line">xcodebuild clean -workspace $&#123;workspace_name&#125;.xcworkspace \</span><br><span class="line">                 -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                 -configuration $&#123;build_configuration&#125;</span><br><span class="line"></span><br><span class="line">xcodebuild archive -workspace $&#123;workspace_name&#125;.xcworkspace \</span><br><span class="line">                   -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                   -configuration $&#123;build_configuration&#125; \</span><br><span class="line">                   -archivePath $&#123;export_archive_path&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># 编译前清理工程</span></span><br><span class="line">xcodebuild clean -project $&#123;project_name&#125;.xcodeproj \</span><br><span class="line">                 -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                 -configuration $&#123;build_configuration&#125;</span><br><span class="line"></span><br><span class="line">xcodebuild archive -project $&#123;project_name&#125;.xcodeproj \</span><br><span class="line">                   -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                   -configuration $&#123;build_configuration&#125; \</span><br><span class="line">                   -archivePath $&#123;export_archive_path&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment">#  检查是否构建成功</span></span><br><span class="line"><span class="comment">#  xcarchive 实际是一个文件夹不是一个文件所以使用 -d 判断</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"$export_archive_path"</span> ] ; then</span><br><span class="line">    echo <span class="string">"\033[32;1m项目构建成功 🚀 🚀 🚀  \033[0m"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">"\033[31;1m项目构建失败 😢 😢 😢  \033[0m"</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line">echo <span class="string">"------------------------------------------------------"</span></span><br><span class="line"></span><br><span class="line">echo <span class="string">"\033[32m开始导出ipa文件 \033[0m"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先删除export_options_plist文件</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"$export_options_plist_path"</span> ] ; then</span><br><span class="line">    <span class="comment">#echo "$&#123;export_options_plist_path&#125;文件存在，进行删除"</span></span><br><span class="line">    rm -f $export_options_plist_path</span><br><span class="line">fi</span><br><span class="line"><span class="comment"># 根据参数生成export_options_plist文件</span></span><br><span class="line">/usr/libexec/PlistBuddy -c  <span class="string">"Add :method String <span class="subst">$&#123;method&#125;</span>"</span>  $export_options_plist_path</span><br><span class="line">/usr/libexec/PlistBuddy -c  <span class="string">"Add :provisioningProfiles:"</span>  $export_options_plist_path</span><br><span class="line">/usr/libexec/PlistBuddy -c  <span class="string">"Add :provisioningProfiles:<span class="subst">$&#123;bundle_identifier&#125;</span> String <span class="subst">$&#123;mobileprovision_name&#125;</span>"</span>  $export_options_plist_path</span><br><span class="line">/usr/libexec/PlistBuddy -c  <span class="string">"Add :compileBitcode bool NO"</span>  $export_options_plist_path</span><br><span class="line"></span><br><span class="line">xcodebuild  -exportArchive \</span><br><span class="line">            -archivePath $&#123;export_archive_path&#125; \</span><br><span class="line">            -exportPath $&#123;export_ipa_path&#125; \</span><br><span class="line">            -exportOptionsPlist $&#123;export_options_plist_path&#125; \</span><br><span class="line">            -allowProvisioningUpdates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查ipa文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"$export_ipa_path/$scheme_name.ipa"</span> ] ; then</span><br><span class="line">    echo <span class="string">"\033[32;1mexportArchive ipa包成功,准备进行重命名\033[0m"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">"\033[31;1mexportArchive ipa包失败 😢 😢 😢     \033[0m"</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改ipa文件名称</span></span><br><span class="line">mv $export_ipa_path/$scheme_name.ipa $export_ipa_path/$ipa_name.ipa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"$export_ipa_path/$ipa_name.ipa"</span> ] ; then</span><br><span class="line">    echo <span class="string">"\033[32;1m导出 <span class="subst">$&#123;ipa_name&#125;</span>.ipa 包成功 🎉  🎉  🎉   \033[0m"</span></span><br><span class="line">    <span class="comment"># open $export_path</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">"\033[31;1m导出 <span class="subst">$&#123;ipa_name&#125;</span>.ipa 包失败 😢 😢 😢     \033[0m"</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除export_options_plist文件（中间文件）</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"$export_options_plist_path"</span> ] ; then</span><br><span class="line">    <span class="comment">#echo "$&#123;export_options_plist_path&#125;文件存在，准备删除"</span></span><br><span class="line">    rm -f $export_options_plist_path</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出dSYM并压缩 zip</span></span><br><span class="line">cp -r <span class="string">"<span class="subst">$&#123;dSYM_path&#125;</span>"</span> <span class="string">"<span class="subst">$&#123;export_path&#125;</span>"</span></span><br><span class="line">zip -r <span class="string">"$zip_dSYM_path"</span> <span class="string">"$new_dSYM_path"</span></span><br><span class="line">rm -r $new_dSYM_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出打包总用时</span></span><br><span class="line">echo <span class="string">"\033[36;1m使用AutoPackage打包总用时: <span class="subst">$&#123;SECONDS&#125;</span>s \033[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备上传dSYM文件到 bugly</span></span><br><span class="line">echo <span class="string">"\033[33m ==========准备上传dSYM文件到 bugly============ \033[0m"</span></span><br><span class="line"></span><br><span class="line">curl -k <span class="string">"https://api.bugly.qq.com/openapi/file/upload/symbol?app_key=4ec76824-0694-4de5-a0a3-447f3ad4259a&amp;app_id=cf4e8e6eaa"</span> \</span><br><span class="line">--form <span class="string">"api_version=1"</span> --form <span class="string">"app_id=cf4e8e6eaa"</span> --form <span class="string">"app_key=4ec76824-0694-4de5-a0a3-447f3ad4259a"</span> \</span><br><span class="line">--form <span class="string">"symbolType=2"</span> --form <span class="string">"bundleId=yourBundleId"</span>  --form <span class="string">"fileName=$scheme_name.app.dSYM.zip"</span> \</span><br><span class="line">--form <span class="string">"file=@/$zip_dSYM_path"</span> --verbose | python -<span class="keyword">m</span> json.tool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $number == <span class="number">1</span> ];then</span><br><span class="line">echo <span class="string">"\033[33m ==========准备上传ipa到App Store============ \033[0m"</span></span><br><span class="line"><span class="comment">#验证并上传到App Store，将-u 后面的XXX替换成自己的AppleID的账号，-p后面的XXX替换成自己的密码</span></span><br><span class="line">altoolPath=<span class="string">"/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool"</span></span><br><span class="line"><span class="string">"$altoolPath"</span> --validate-app -f $&#123;ipa_name&#125;.ipa -u appid账号 -p appid密码 -t ios --output-<span class="keyword">format</span> xml</span><br><span class="line"><span class="string">"$altoolPath"</span> --upload-app -f $&#123;ipa_name&#125;.ipa -u  appid账号 -p appid密码 -t ios --output-<span class="keyword">format</span> xml</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">echo <span class="string">"\033[33m ==========准备上传ipa到fir============ \033[0m"</span></span><br><span class="line"><span class="comment">#自定义短链</span></span><br><span class="line">short=<span class="string">"rxios"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ipa 完整下载链接</span></span><br><span class="line">ipa_link=<span class="string">"https://fir.im/$short"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上传 ipa</span></span><br><span class="line">fir publish $export_ipa_path/$ipa_name.ipa -T <span class="string">'4596a0fbf2d0adeaa017302b17686f0c'</span> -Q -<span class="keyword">s</span> <span class="string">"$short"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#git 日志路径</span></span><br><span class="line">txt_path=$export_path/<span class="string">`date +%Y-%m-%d-%H_%M_%S.html`</span></span><br><span class="line">temp_txt=$export_path/gitlog.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入 ipa 下载链接</span></span><br><span class="line">echo <span class="string">"&lt;div style='height: 40px;font-size: 20px;'&gt;iOS 安装包下载链接：&lt;a href=<span class="subst">$&#123;ipa_link&#125;</span>&gt;$ipa_link&lt;/a&gt;&lt;/div&gt;"</span> &gt;&gt; $txt_path </span><br><span class="line"></span><br><span class="line"><span class="comment">#抓取 git 日志</span></span><br><span class="line">git <span class="keyword">log</span> --pretty=<span class="keyword">format</span>:<span class="string">"&lt;span style='font-size: 16px;'&gt;%ai,%an:&lt;/span&gt; &lt;span style='color: #469cf7;font-size: 16px;'&gt;%s&lt;/span&gt;&lt;br&gt;"</span> \</span><br><span class="line"> --<span class="keyword">no</span>-merges  &gt;&gt; $txt_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二行插入 &lt;div&gt;</span></span><br><span class="line">sed <span class="string">"2 i\ </span></span><br><span class="line"><span class="string">&lt;div style='letter-spacing: 0.5px;line-height: 25px'&gt;"</span> $txt_path &gt; $temp_txt</span><br><span class="line">echo <span class="string">`cat $temp_txt`</span> &gt; $txt_path </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后一行插入 &lt;/div&gt;</span></span><br><span class="line">sed <span class="string">"$ a\ </span></span><br><span class="line"><span class="string">&lt;/div&gt;"</span> $txt_path &gt; $temp_txt</span><br><span class="line">echo <span class="string">`cat $temp_txt`</span> &gt; $txt_path </span><br><span class="line"></span><br><span class="line"><span class="comment">#发送版本信息到邮箱，为了防止在widndows电脑上文本乱码，邮件内容用html的形式</span></span><br><span class="line"><span class="comment"># mail_title="容信iOS安装包已更新"</span></span><br><span class="line"><span class="comment"># mail -s  "$(echo "$&#123;mail_title&#125;\nContent-Type:text/html;charset=UTF-8")"  \</span></span><br><span class="line"><span class="comment"># eagle_01yz@163.com\</span></span><br><span class="line"><span class="comment"># &lt; $&#123;txt_path&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#移除中间转换文件</span></span><br><span class="line">rm -f $temp_txt</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开文件夹</span></span><br><span class="line"><span class="keyword">open</span> $export_path</span><br><span class="line"><span class="keyword">open</span> $txt_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编总结</title>
    <url>/%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93.html/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93.html">个人博客</a></p>
<h3 id="汇编语言的种类"><a href="#汇编语言的种类" class="headerlink" title="汇编语言的种类"></a>汇编语言的种类</h3><ul>
<li>8086汇编(16bit) </li>
<li>x86汇编(32bit) </li>
<li>x64汇编(64bit) </li>
<li>ARM汇编(嵌入式、移动设备) p……</li>
</ul>
<h3 id="x86、x64汇编根据编译器的不同，有2种书写格式"><a href="#x86、x64汇编根据编译器的不同，有2种书写格式" class="headerlink" title="x86、x64汇编根据编译器的不同，有2种书写格式"></a>x86、x64汇编根据编译器的不同，有2种书写格式</h3><ul>
<li>Intel:Windows派系</li>
<li>AT&amp;T :Unix派系</li>
</ul>
<h3 id="作为iOS开发工程师，最主要的汇编语言是"><a href="#作为iOS开发工程师，最主要的汇编语言是" class="headerlink" title="作为iOS开发工程师，最主要的汇编语言是"></a>作为iOS开发工程师，最主要的汇编语言是</h3><ul>
<li>AT&amp;T汇编 -&gt; iOS模拟器</li>
<li>ARM汇编 -&gt; iOS真机设备</li>
</ul>
<h2 id="常见的汇编指令"><a href="#常见的汇编指令" class="headerlink" title="常见的汇编指令"></a>常见的汇编指令</h2><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="center">AT&amp;T</th>
<th align="center">Intel</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">寄存器命名</td>
<td align="center">%rax</td>
<td align="center">rax</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">操作数顺序</td>
<td align="center">movq %rax, %rdx</td>
<td align="center">mov rdx, rax</td>
<td align="center">将rax的值赋值给rdx</td>
</tr>
<tr>
<td align="left">常数\立即数</td>
<td align="center">movq $0x10, %rax</td>
<td align="center">mov rax, 0x10</td>
<td align="center">将0x10赋值给rax</td>
</tr>
<tr>
<td align="left">内存赋值</td>
<td align="center">movq $0xa, 0x1ff7(%rip)</td>
<td align="center">mov qword ptr [rip+0x1ff7], 0xa</td>
<td align="center">将0xa赋值给地址为rip + 0x1ff7的内存空间</td>
</tr>
<tr>
<td align="left">取内存地址</td>
<td align="center">leaq -0x18(%rbp), %rax</td>
<td align="center">lea rax, [rbp – 0x18]</td>
<td align="center">将rbp – 0x18这个地址值赋值给rax</td>
</tr>
<tr>
<td align="left">jmp指令</td>
<td align="center">jmp *%rdx</td>
<td align="center">jmp rdx</td>
<td align="center">call和jmp写法类似</td>
</tr>
<tr>
<td align="left">操作数长度</td>
<td align="center">leaw 0x10(%dx), %ax</td>
<td align="center">lea ax, [dx + 0x10]</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="操作数长度的说明"><a href="#操作数长度的说明" class="headerlink" title="操作数长度的说明"></a>操作数长度的说明</h3><ul>
<li>b = byte (8-bit) </li>
<li>s = short (16-bit integer or 32-bit floating point) </li>
<li>w = word (16-bit)</li>
<li>l = long (32-bit integer or 64-bit floating point) </li>
<li>q = quad (64 bit) t = ten bytes (80-bit floating point)</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="有16个常用寄存器"><a href="#有16个常用寄存器" class="headerlink" title="有16个常用寄存器"></a>有16个常用寄存器</h3><ul>
<li>rax、rbx、rcx 、rdx、rsi、rdi、rbp、rsp </li>
<li>r8、r9、r10、r11、r12、r13、r14、r15</li>
</ul>
<h3 id="寄存器的具体用途"><a href="#寄存器的具体用途" class="headerlink" title="寄存器的具体用途"></a>寄存器的具体用途</h3><ul>
<li>rax常作为函数返回值使用 </li>
<li>rdi、rsi、rdx、rcx、r8、r9等寄存器常用于存放函数参数 </li>
<li>rsp、rbp用于栈操作</li>
<li>rip作为指令指针<ul>
<li>存储着CPU下一条要执行的指令的地址</li>
<li>一旦CPU读取一条指令，rip会自动指向下一条指令(存储下一条指令的地址)</li>
</ul>
</li>
</ul>
<h3 id="lldb常用指令"><a href="#lldb常用指令" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h3><ul>
<li>读取寄存器的值 <ul>
<li>register read/格式 </li>
<li>register read/x</li>
</ul>
</li>
<li>修改寄存器的值<ul>
<li>register write 寄存器名称 数值 </li>
<li>register write rax 0</li>
</ul>
</li>
<li>读取内存中的值 <ul>
<li>x/数量-格式-字节大小 内存地址 </li>
<li>x/3xw 0x0000010</li>
</ul>
</li>
<li>修改内存中的值<ul>
<li>memory write 内存地址 数值 </li>
<li>memory write 0x0000010 10</li>
</ul>
</li>
<li>格式 <ul>
<li>x是16进制，f是浮点，d是十进制</li>
</ul>
</li>
<li>字节大小<ul>
<li>b – byte 1字节</li>
<li>h – half word 2字节 </li>
<li>w – word 4字节</li>
<li>g – giant word 8字节</li>
</ul>
</li>
<li>expression 表达式 <ul>
<li>可以简写:expr 表达式 </li>
<li>expression $rax </li>
<li>expression $rax = 1</li>
</ul>
</li>
<li>po 表达式 </li>
<li>print 表达式 <ul>
<li>po/x $rax </li>
<li>po (int)$rax</li>
</ul>
</li>
</ul>
<h2 id="lldb常用指令-1"><a href="#lldb常用指令-1" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h2><ul>
<li>thread step-over、next、n <ul>
<li>单步运⾏行行，把子函数当做整体⼀一步执⾏行行(源码级别)</li>
</ul>
</li>
<li>thread step-in、step、s<ul>
<li>单步运⾏行行，遇到子函数会进⼊入子函数(源码级别)</li>
</ul>
</li>
<li>thread step-inst-over、nexti、ni <ul>
<li>单步运⾏行行，把子函数当做整体⼀一步执⾏行行(汇编级别)</li>
</ul>
</li>
<li>thread step-inst、stepi、si <ul>
<li>单步运⾏行行，遇到子函数会进⼊入子函数(汇编级别)</li>
</ul>
</li>
<li>thread step-out、finish <ul>
<li>直接执⾏行行完当前函数的所有代码，返回到上一个函数(遇到断点会卡住)</li>
</ul>
</li>
</ul>
<h2 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h2><ul>
<li>内存地址格式为:0x4bdc(%rip)，一般是全局变量，全局区(数据段) </li>
<li>内存地址格式为:-0x78(%rbp)，一般是局部变量，栈空间</li>
<li>内存地址格式为:0x10(%rax)，一般是堆空间</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>详解iOS中分类Cateogry</title>
    <url>/%E8%AF%A6%E8%A7%A3iOS%E4%B8%AD%E5%88%86%E7%B1%BBCateogry.html/</url>
    <content><![CDATA[<p>首发于<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3iOS%E4%B8%AD%E5%88%86%E7%B1%BBCateogry.html">我的个人博客</a></p>
<h2 id="分类的基本使用"><a href="#分类的基本使用" class="headerlink" title="分类的基本使用"></a>分类的基本使用</h2><ul>
<li>首先我们定义一个类 YZPerson 继承自 NSObject</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后定义一个分类 YZPerson+test1.h</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> (<span class="title">test1</span>)</span></span><br><span class="line">-(<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson+test1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span> (<span class="title">test1</span>)</span></span><br><span class="line">-(<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在控制器 ViewController 中使用</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="comment">[super viewDidLoad]</span>;</span><br><span class="line">    </span><br><span class="line">    YZPerson *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[YZPerson alloc]</span> init]</span>;</span><br><span class="line">    <span class="comment">[person run]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果为</li>
</ul>
<blockquote>
<p>CateogryDemo[23773:321096] -[YZPerson(test1) run]</p>
</blockquote>
<p><strong>注意点：如果原来的类和分类中有同样的方法，那么执行的结果的是分类中的，例如</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">-(<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果不会发生变化，依然是</li>
</ul>
<blockquote>
<p>CateogryDemo[23773:321096] -[YZPerson(test1) run]</p>
</blockquote>
<p>原因在后面分析</p>
<h2 id="分类的结构"><a href="#分类的结构" class="headerlink" title="分类的结构"></a>分类的结构</h2><h3 id="打开终端，进入项目下，执行如下命令，生成C语言的文件"><a href="#打开终端，进入项目下，执行如下命令，生成C语言的文件" class="headerlink" title="打开终端，进入项目下，执行如下命令，生成C语言的文件"></a>打开终端，进入项目下，执行如下命令，生成C语言的文件</h3><blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc YZPerson+test1.m</p>
</blockquote>
<h3 id="生成-YZPerson-test1-cpp文件"><a href="#生成-YZPerson-test1-cpp文件" class="headerlink" title="生成 YZPerson+test1.cpp文件"></a>生成 YZPerson+test1.cpp文件</h3><p>摘取主要代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_YZPerson_$_test1 __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"run"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_YZPerson_test1_run&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">YZPerson</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_YZPerson_</span>$_<span class="title">test1</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="string">"YZPerson"</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_YZPerson,</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_YZPerson_$_test1,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_YZPerson_$_test1(<span class="keyword">void</span> ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_YZPerson_$_test1.cls = &amp;OBJC_CLASS_$_YZPerson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明编译完之后每一个分类都会生成一个 </p>
<blockquote>
<p>_category_t</p>
</blockquote>
<p>的结构体，里面有名称，对象方法列表，类方法列表，协议方法列表，属性列表,如果对应的为空，比如协议为空，属性为空，那么结构体中保存的就是0。</p>
<h3 id="objc-runtime-new-h"><a href="#objc-runtime-new-h" class="headerlink" title="objc-runtime-new.h"></a>objc-runtime-new.h</h3><p>打开源码最新的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a>看，objc-runtime-new.h中分类结构体是这样的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="源码解读顺序"><a href="#源码解读顺序" class="headerlink" title="源码解读顺序"></a>源码解读顺序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objc-os.mm</span><br><span class="line">_objc_init</span><br><span class="line">map_images</span><br><span class="line">map_images_nolock</span><br><span class="line"></span><br><span class="line">objc-runtime-<span class="keyword">new</span>.mm</span><br><span class="line">_read_images</span><br><span class="line">remethodizeClass</span><br><span class="line">attachCategories</span><br><span class="line">attachLists</span><br><span class="line"><span class="built_in">realloc</span>、memmove、 <span class="built_in">memcpy</span></span><br></pre></td></tr></table></figure>

<ul>
<li>先找到 objc-os.mm 类，里面的</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// runtime初始化方法</span></span><br><span class="line">void <span class="constructor">_objc_init(<span class="params">void</span>)</span> <span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    static <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ<span class="constructor">_init()</span>;</span><br><span class="line">    tls<span class="constructor">_init()</span>;</span><br><span class="line">    static<span class="constructor">_init()</span>;</span><br><span class="line">    lock<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="keyword">exception</span><span class="constructor">_init()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">_dyld_objc_notify_register(&amp;<span class="params">map_images</span>, <span class="params">load_images</span>, <span class="params">unmap_image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继续跟下去</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 </li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">map_images_nolock</span></span><br></pre></td></tr></table></figure>

<p>找到</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="constructor">_read_images(<span class="params">hList</span>, <span class="params">hCount</span>, <span class="params">totalClasses</span>, <span class="params">unoptimizedTotalClasses</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到了文件 objc-runtime-new.mm 中</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_read_images(<span class="params">header_info</span> <span class="operator">**</span><span class="params">hList</span>, <span class="params">uint32_t</span> <span class="params">hCount</span>, <span class="params">int</span> <span class="params">totalClasses</span>, <span class="params">int</span> <span class="params">unoptimizedTotalClasses</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 关键代码</span></span><br><span class="line">	 remethodize<span class="constructor">Class(<span class="params">cls</span>)</span>;</span><br><span class="line">	 <span class="comment">// 关键代码</span></span><br><span class="line">     remethodize<span class="constructor">Class(<span class="params">cls</span>-&gt;ISA()</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void remethodizeClass(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="keyword">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="keyword">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要代码和注释已经在代码中展示了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void </span><br><span class="line">attach<span class="constructor">Categories(Class <span class="params">cls</span>, <span class="params">category_list</span> <span class="operator">*</span><span class="params">cats</span>, <span class="params">bool</span> <span class="params">flush_caches</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cats 分类列表</span></span><br><span class="line">    <span class="keyword">if</span> (!cats) return;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) print<span class="constructor">Replacements(<span class="params">cls</span>, <span class="params">cats</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> isMeta = cls-&gt;is<span class="constructor">MetaClass()</span>;</span><br><span class="line">    <span class="comment">// 方法数组 二维数组</span></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">    malloc(cats-&gt;count<span class="operator"> * </span>sizeof(*mlists));</span><br><span class="line">    <span class="comment">// 属性数组 二维数组</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">    malloc(cats-&gt;count<span class="operator"> * </span>sizeof(*proplists));</span><br><span class="line">    <span class="comment">// 协议数组 二维数组</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">    malloc(cats-&gt;count<span class="operator"> * </span>sizeof(*protolists));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="built_in">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="built_in">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="comment">// 这个while循环 合并分类中的 对象方法 属性 协议</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// 取出某个分类</span></span><br><span class="line">        auto&amp; entry = cats-&gt;<span class="built_in">list</span><span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        <span class="comment">// 取出分类中的对象方法</span></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methods<span class="constructor">ForMeta(<span class="params">isMeta</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists<span class="literal">[<span class="identifier">mcount</span><span class="operator">++</span>]</span> = mlist;</span><br><span class="line">            fromBundle <span class="pattern-match">|= entry.hi-&gt;is<span class="constructor">Bundle()</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 取出分类中的属性</span></span><br><span class="line"><span class="pattern-match">        property<span class="constructor">_list_t</span> <span class="operator">*</span>proplist =</span></span><br><span class="line"><span class="pattern-match">        entry.cat-&gt;properties<span class="constructor">ForMeta(<span class="params">isMeta</span>, <span class="params">entry</span>.<span class="params">hi</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (proplist) &#123;</span></span><br><span class="line"><span class="pattern-match">            proplists[propcount<span class="operator">++</span>] = proplist;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 取出分类中的协议</span></span><br><span class="line"><span class="pattern-match">        protocol<span class="constructor">_list_t</span> <span class="operator">*</span>protolist = entry.cat-&gt;protocols;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (protolist) &#123;</span></span><br><span class="line"><span class="pattern-match">            protolists[protocount<span class="operator">++</span>] = protolist;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> 得到类对象里面的数据</span></span><br><span class="line"><span class="pattern-match">    auto rw = cls-&gt;data();</span></span><br><span class="line"><span class="pattern-match">    </span></span><br><span class="line"><span class="pattern-match">    prepare<span class="constructor">MethodLists(<span class="params">cls</span>, <span class="params">mlists</span>, <span class="params">mcount</span>, NO, <span class="params">fromBundle</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> 所有分类的对象方法，附加到类对象的方法列表中</span></span><br><span class="line"><span class="pattern-match">    rw-&gt;methods.attach<span class="constructor">Lists(<span class="params">mlists</span>, <span class="params">mcount</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    free(mlists);</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (flush<span class="constructor">_caches</span>  <span class="operator">&amp;&amp;</span>  mcount &gt; 0) flush<span class="constructor">Caches(<span class="params">cls</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> 所有分类的属性，附加到类对象的属性列表中，</span></span><br><span class="line"><span class="pattern-match">    rw-&gt;properties.attach<span class="constructor">Lists(<span class="params">proplists</span>, <span class="params">propcount</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    free(proplists);</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> 所有分类的协议，附加到类对象的协议列表中</span></span><br><span class="line"><span class="pattern-match">    rw-&gt;protocols.attach<span class="constructor">Lists(<span class="params">protolists</span>, <span class="params">protocount</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    free(protolists);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="memmove-memcpy"><a href="#memmove-memcpy" class="headerlink" title="memmove memcpy"></a>memmove memcpy</h3><p>上面的代码继续跟下去来到了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="comment">// 内存挪动</span></span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, </span><br><span class="line">            				<span class="built_in">array</span>()-&gt;lists,</span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">// 内存拷贝</span></span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists,</span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists,</span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中关键代码是</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存挪动</span></span><br><span class="line"> memmove(<span class="keyword">array</span>()-&gt;lists + addedCount,</span><br><span class="line">                    <span class="keyword">array</span>()-&gt;lists,</span><br><span class="line">                    oldCount * sizeof(<span class="keyword">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">// 内存拷贝</span></span><br><span class="line"> memcpy(<span class="keyword">array</span>()-&gt;lists, addedLists,</span><br><span class="line">                   addedCount * sizeof(<span class="keyword">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>

<p>关于memcpy与memmove的区别，可以参考 <a href="https://www.jianshu.com/p/9c3784d8d8ad" target="_blank" rel="noopener">memcpy与memmove的区别</a></p>
<p>简单总结就是：</p>
<blockquote>
<p>区别就在于关键字restrict, memcpy假定两块内存区域没有数据重叠，而memmove没有这个前提条件。如果复制的两个区域存在重叠时使用memcpy，其结果是不可预知的，有可能成功也有可能失败的，所以如果使用了memcpy,程序员自身必须确保两块内存没有重叠部分</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合并分类的时候，其方法列表等，不会覆盖掉原来类中的方法，是共存的。但是分类中的方法在前面，原来的类中的方法在后面，调用的时候，就会调用分类中的方法，如果多个分类有同样的方法，后编译的分类会调用。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Category的使用场合是什么？"><a href="#Category的使用场合是什么？" class="headerlink" title="Category的使用场合是什么？"></a>Category的使用场合是什么？</h3><ul>
<li>不同模块的功能区分开来，可以使用分类实现</li>
</ul>
<h3 id="Category的实现原理"><a href="#Category的实现原理" class="headerlink" title="Category的实现原理"></a>Category的实现原理</h3><ul>
<li>Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息<br>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</li>
</ul>
<h3 id="Category和Class-Extension的区别是什么？"><a href="#Category和Class-Extension的区别是什么？" class="headerlink" title="Category和Class Extension的区别是什么？"></a>Category和Class Extension的区别是什么？</h3><p>Class Extension在编译的时候，它的数据就已经包含在类信息中<br>Category是在运行时，才会将数据合并到类信息中</p>
<h3 id="Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？"><a href="#Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？" class="headerlink" title="Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？"></a>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</h3><p>有load方法<br>load方法在runtime加载类、分类的时候调用<br>load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</p>
<h3 id="Category能否添加成员变量？如果可以，如何给Category添加成员变量？"><a href="#Category能否添加成员变量？如果可以，如何给Category添加成员变量？" class="headerlink" title="Category能否添加成员变量？如果可以，如何给Category添加成员变量？"></a>Category能否添加成员变量？如果可以，如何给Category添加成员变量？</h3><ul>
<li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果,关联对象</li>
</ul>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
<p><a href="https://www.jianshu.com/p/9c3784d8d8ad" target="_blank" rel="noopener">memcpy与memmove的区别</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>详解RunLoop之面试题</title>
    <url>/%E8%AF%A6%E8%A7%A3RunLoop%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3RunLoop%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">个人博客</a></p>
<h2 id="回顾详解RunLoop之源码分析中提出的问题"><a href="#回顾详解RunLoop之源码分析中提出的问题" class="headerlink" title="回顾详解RunLoop之源码分析中提出的问题"></a>回顾<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3RunLoop%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">详解RunLoop之源码分析</a>中提出的问题</h2><ul>
<li>什么是Runloop</li>
<li>ios程序中 main函数为什么不会退出</li>
<li>runloop和线程的关系？</li>
<li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</li>
<li>runloop内部实现逻辑？</li>
<li>runloop 是怎么响应用户操作的， 具体流程是什么样的？</li>
<li>说说runLoop的几种状态</li>
<li>runloop的mode作用是什么？</li>
<li>如何实现一个常驻线程</li>
</ul>
<h2 id="什么是Runloop"><a href="#什么是Runloop" class="headerlink" title="什么是Runloop"></a>什么是Runloop</h2><ul>
<li>Runloop 还是比较顾名思义的一个东西，说白了就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 Runloop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，Runloop 会进入休眠状态，有事件发生时， Runloop 会去找对应的 Handler 处理事件。Runloop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠</li>
<li>RunLoop是通过内部维护的时间循环来对事件/消息进行管理的一个对象<ul>
<li>没有消息需要处理时，休眠避免掉资源占用<ul>
<li>用户态 -&gt; 内核态</li>
</ul>
</li>
<li>有消息时候，立刻被唤醒 <ul>
<li>内核态 -&gt; 用户态<br><img src="https://upload-images.jianshu.io/upload_images/3373351-a836912b87aa725b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ios程序中-main函数为什么不会退出"><a href="#ios程序中-main函数为什么不会退出" class="headerlink" title="ios程序中 main函数为什么不会退出"></a>ios程序中 main函数为什么不会退出</h2><ul>
<li>main函数内部调用 UIApplicationMain 这个方法会启动一个RunLoop，有事做就做事，没事做就等待，保持不会退出</li>
</ul>
<h2 id="runloop和线程的关系？"><a href="#runloop和线程的关系？" class="headerlink" title="runloop和线程的关系？"></a>runloop和线程的关系？</h2><pre><code>+ 每条线程都有唯一的一个与之对应的RunLoop对象
+ RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value
+ 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建
+ RunLoop会在线程结束时销毁</code></pre><h2 id="runloop内部实现逻辑？"><a href="#runloop内部实现逻辑？" class="headerlink" title="runloop内部实现逻辑？"></a>runloop内部实现逻辑？</h2><p>就是下图所示的，用自己话总结出来就好<br><img src="https://upload-images.jianshu.io/upload_images/3373351-2cc435e0dbda8ba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"><a href="#程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？" class="headerlink" title="程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"></a>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</h2><ul>
<li><p>常见的2种Mode</p>
</li>
<li><p>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</p>
</li>
<li><p>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</p>
</li>
<li><p>common模式下(一个占位用的Mode，不是一种真正的Mode) 可以兼容以上两种模式</p>
</li>
</ul>
<h2 id="runloop-是怎么响应用户操作的，-具体流程是什么样的？"><a href="#runloop-是怎么响应用户操作的，-具体流程是什么样的？" class="headerlink" title="runloop 是怎么响应用户操作的， 具体流程是什么样的？"></a>runloop 是怎么响应用户操作的， 具体流程是什么样的？</h2><ul>
<li>source1 捕捉用户触摸事件</li>
<li>source0去处理触摸时间</li>
</ul>
<h2 id="说说runLoop的几种状态"><a href="#说说runLoop的几种状态" class="headerlink" title="说说runLoop的几种状态"></a>说说runLoop的几种状态</h2><ul>
<li>kCFRunLoopEntry = (1UL &lt;&lt; 0),           // 即将进入Loop</li>
<li>kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    //即将处理Timer</li>
<li>kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   //即将处理Source</li>
<li>kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   //即将进入休眠</li>
<li>kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    //刚从休眠中唤醒</li>
<li>kCFRunLoopExit = (1UL &lt;&lt; 7),            //即将退出Loop</li>
<li>kCFRunLoopAllActivities = 0x0FFFFFFFU   //所有状态改变</li>
</ul>
<h2 id="runloop的mode作用是什么？"><a href="#runloop的mode作用是什么？" class="headerlink" title="runloop的mode作用是什么？"></a>runloop的mode作用是什么？</h2><ul>
<li>简单来说就是不同模式隔离开来，保证同一种摸下下运行，source0,source1,timer,observer 的运行更流畅</li>
</ul>
<h2 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h2><p>简单来说就是</p>
<ul>
<li>创建RunLoop </li>
<li>像RunLoop中添加port、source等来保证RunLoop不退出</li>
<li>启动RunLoop</li>
</ul>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">RunLoop官方源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>关于KVO看这篇就够了</title>
    <url>/%E5%85%B3%E4%BA%8EKVO%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E5%85%B3%E4%BA%8EKVO%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html">个人博客</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>KVO全称KeyValueObserving，俗称<strong>键值监听</strong>，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于KVO的实现机制，所以对属性才会发生作用，一般继承自NSObject的对象都默认支持KVO。</li>
<li>KVC和KVO都属于键值编程而且底层实现机制都是<strong>isa-swizzing</strong>。</li>
<li>KVO和NSNotificationCenter都是iOS中<strong>观察者模式</strong>的一种实现。KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听。</li>
<li>KVO可以监听单个属性的变化，也可以监听集合对象的变化。通过KVC的mutableArrayValueForKey:等方法获得代理对象，当代理对象的内部对象发生改变时，会回调KVO监听的方法。集合对象包含NSArray和NSSet。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>KVO是通过isa-swizzling技术实现的(这句话是整个KVO实现的重点)。</li>
<li>在运行时根据原类创建一个中间类，这个中间类是原类的子类，并动态修改当前对象的isa指向中间类。当修改 instance 对象的属性时，会调用 Foundation框架的 _NSSetXXXValueAndNotify 函数 ,该函数里面会先调用 willChangeValueForKey: 然后调用父类原来的 setter 方法修改值，最后是 didChangeValueForKey:。didChangeValueForKey 内部会触发监听器（Oberser）的监听方法observeValueForKeyPath:ofObject:change:context:</li>
<li>并且将class方法重写，返回原类的Class。</li>
</ul>
<h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>通过addObserver:forKeyPath:options:context:方法注册观察者，观察者可以接收keyPath属性的变化事件。</li>
<li>在观察者中实现observeValueForKeyPath:ofObject:change:context:方法，当keyPath属性发生改变后，KVO会回调这个方法来通知观察者。</li>
<li>当观察者不需要监听时，可以调用removeObserver:forKeyPath:方法将KVO移除。需要注意的是，调用removeObserver需要在观察者消失之前，否则会导致Crash。</li>
</ol>
<p>例如，我们定义一个 YZPerson 类 继承自 NSObject ，里面有name 和 age 两个属性</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic ,assign) int age;</span><br><span class="line"><span class="variable">@property</span> (nonatomic,strong) NSString  *name;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>然后在ViewController中，写如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   	<span class="comment">//调用方法</span></span><br><span class="line">    [<span class="keyword">self</span> setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@属性值改变了 - %@ - %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">  <span class="keyword">self</span>.person.name = <span class="string">@"ccc"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">11482</span>:<span class="number">141804</span>] 监听到&lt;YZPerson: <span class="number">0x6000004e8400</span>&gt;的name属性值改变了 - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = ccc;</span><br><span class="line">    old = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125; - <span class="number">1111</span>- <span class="number">1111</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>需要注意的是，上面代码中我们已经移除了监听，如果再次移除的话，就会crash</strong></p>
<p>例如</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   	<span class="comment">//调用方法</span></span><br><span class="line">    [<span class="keyword">self</span> setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">   <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">       <span class="comment">// 移除监听</span></span><br><span class="line">    [person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">    <span class="comment">// 再次移除</span></span><br><span class="line">     [person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除多次会报错 </p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">9261</span>:<span class="number">2171323</span>] *** Terminating app due <span class="keyword">to</span> uncaught exception <span class="comment">'NSRangeException', </span></span><br><span class="line">reason: <span class="comment">'Cannot remove an observer <span class="doctag">&lt;ViewController 0x139e07220&gt;</span> for the key path "name" </span></span><br><span class="line"><span class="keyword">from</span> &lt;YZPerson <span class="number">0x281322f20</span>&gt; because it <span class="keyword">is</span> <span class="keyword">not</span> registered <span class="keyword">as</span> an observer.<span class="comment">'</span></span><br></pre></td></tr></table></figure>


<p><strong>如果忘记移除的话，有可能下次收到这个属性的变化的时候，会carsh</strong></p>
<p>所以，我们要保证add和remove是成对出现的</p>
<h2 id="抛出疑问"><a href="#抛出疑问" class="headerlink" title="抛出疑问"></a>抛出疑问</h2><p>假如我们有两个YZPerson对象，只监听其中一个</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person2 = [[YZPerson alloc] init];</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">self</span>.person.name = <span class="string">@"ccc"</span>;</span><br><span class="line">    <span class="keyword">self</span>.person2.name = <span class="string">@"ddd"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@属性值改变了 - %@ - %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击屏幕时候，打印如下</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">监听到&lt;YZPerson: <span class="number">0</span>x600001afa740&gt;的name属性值改变了 - &#123;</span><br><span class="line">    <span class="attr">kind</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="attr">new</span> = ccc;</span><br><span class="line">    <span class="attr">old</span> = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125; - <span class="number">1111</span></span><br></pre></td></tr></table></figure>

<p>但是我们知道，</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">self.person.name</span> = @<span class="string">"ccc"</span><span class="comment">;</span></span><br><span class="line"><span class="attr">self.person2.name</span> = @<span class="string">"ddd"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面这两句代码都是调用  setName</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，两个对象，都是调用 setName 方法，根据iOS的机制，应该都是根据 YZPerson的isa指针，去类对象中查找方法。怎么就能做到 self.person.name 可以监听 self.person2.name 不能监听呢？</p>
<h2 id="本质分析"><a href="#本质分析" class="headerlink" title="本质分析"></a>本质分析</h2><p>针对上面的疑问，我们可以猜测，是不是person 和 person2 的isa指针不一样呢，导致执行的方法不同呢？</p>
<p>打断点，并打印两者的isa</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(lldb) po <span class="keyword">self</span>.person-&gt;isa</span><br><span class="line">NSKVONotifying_YZPerson</span><br><span class="line"></span><br><span class="line">(lldb) po <span class="keyword">self</span>.person2-&gt;isa</span><br><span class="line">YZPerson</span><br></pre></td></tr></table></figure>

<p>发现果然是isa指针不同，既然isa指向不同了。是不是说明两者的类对象不同呢？答案是肯定的。因为oc中，就是根据isa去查找类对象的，那么接下来进行验证</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="对类对象进行验证"><a href="#对类对象进行验证" class="headerlink" title="对类对象进行验证"></a>对类对象进行验证</h3><p>导入 runtime，对两者的类进行打印</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person添加KVO监听之前 - %@ %@"</span>,</span><br><span class="line">        object_getClass(<span class="keyword">self</span>.person),</span><br><span class="line">        object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line">  <span class="comment">// 注册观察者</span></span><br><span class="line">  <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">  [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"person添加KVO监听之后 - %@ %@"</span>,</span><br><span class="line">        object_getClass(<span class="keyword">self</span>.person),</span><br><span class="line">        object_getClass(<span class="keyword">self</span>.person2));</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">13302</span>:<span class="number">171740</span>] person添加KVO监听之前 - YZPerson YZPerson</span><br><span class="line">KVOdemo[<span class="number">13302</span>:<span class="number">171740</span>] person添加KVO监听之后 - NSKVONotifying_YZPerson YZPerson</span><br></pre></td></tr></table></figure>

<p>由此可见，添加KVO监听之后，确实 self.person 的类对象是NSKVONotifying_YZPerson 而self.person2的类对象不变，依然是 YZPerson</p>
<h3 id="注意点：如果使用-self-person-class-无法获取真实的类"><a href="#注意点：如果使用-self-person-class-无法获取真实的类" class="headerlink" title="注意点：如果使用 [self.person class] 无法获取真实的类"></a>注意点：如果使用 [self.person class] 无法获取真实的类</h3><p>例如我们在添加KVO监听之后，这样来获取类对象</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NSLog(@<span class="string">"person添加KVO监听之后 - %@ %@"</span>,</span><br><span class="line">             [<span class="keyword">self</span>.person <span class="class"><span class="keyword">class</span>],</span></span><br><span class="line">             [<span class="keyword">self</span>.person2 <span class="class"><span class="keyword">class</span>]);</span></span><br></pre></td></tr></table></figure>

<p>那么打印结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">17839</span>:<span class="number">239214</span>] person添加KVO监听之后 - YZPerson YZPerson</span><br></pre></td></tr></table></figure>

<p>这是因为，苹果为我们生成了中间类 NSKVONotifying_YZPerson 但是，他并不想让我们知道有这个类的存在，重写了这个 NSKVONotifying_YZPerson 的class方法，所以，我们获取的结果是不准确的。</p>
<h3 id="对方法IMP进行验证"><a href="#对方法IMP进行验证" class="headerlink" title="对方法IMP进行验证"></a>对方法IMP进行验证</h3><p>我们知道，当改变name属性的时候，是调用setName: 进行的，那我们就来查看一下setName: 有什么变化</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NSLog(@<span class="string">"person添加KVO监听之前 - %p %p"</span>,</span><br><span class="line">        [self.person <span class="string">methodForSelector:</span><span class="meta">@selector</span>(<span class="string">setName:</span>)],</span><br><span class="line">        [self.person2 <span class="string">methodForSelector:</span><span class="meta">@selector</span>(<span class="string">setName:</span>)]);</span><br><span class="line">  <span class="comment">// 注册观察者</span></span><br><span class="line">  NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">  [self.person <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>options <span class="string">context:</span>@<span class="string">"1111"</span>];</span><br><span class="line">  </span><br><span class="line">  NSLog(@<span class="string">"person添加KVO监听之后 - %p %p"</span>,</span><br><span class="line">        [self.person <span class="string">methodForSelector:</span><span class="meta">@selector</span>(<span class="string">setName:</span>)],</span><br><span class="line">        [self.person2 <span class="string">methodForSelector:</span><span class="meta">@selector</span>(<span class="string">setName:</span>)]);</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">KVOdemo[<span class="number">13655</span>:<span class="number">177448</span>] person添加KVO监听之前 - <span class="number">0x10ccfa630</span> <span class="number">0x10ccfa630</span></span><br><span class="line">KVOdemo[<span class="number">13655</span>:<span class="number">177448</span>] person添加KVO监听之后 - <span class="number">0x10d056d1a</span> <span class="number">0x10ccfa630</span></span><br></pre></td></tr></table></figure>

<p>有上面打印结果可知，添加监听之后，self.person的 setName 地址变了。继续通过LLDB查看</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">KVOdemo[<span class="number">13655</span>:<span class="number">177448</span>] person添加KVO监听之前 - <span class="number">0x10ccfa630</span> <span class="number">0x10ccfa630</span></span><br><span class="line">KVOdemo[<span class="number">13655</span>:<span class="number">177448</span>] person添加KVO监听之后 - <span class="number">0x10d056d1a</span> <span class="number">0x10ccfa630</span></span><br><span class="line">(lldb) p (IMP)<span class="number">0x10ccfa630</span></span><br><span class="line">(IMP) $<span class="number">0</span> = <span class="number">0x000000010ccfa630</span> (KVOdemo`-[YZPerson setName:] at YZPerson.m:<span class="number">12</span>)</span><br><span class="line">(lldb) p (IMP)<span class="number">0x10d056d1a</span></span><br><span class="line">(IMP) $<span class="number">1</span> = <span class="number">0x000000010d056d1a</span> (Foundation`_NSSetObjectValueAndNotify)</span><br></pre></td></tr></table></figure>

<p>可知，添加KVO监听之后，setName:方法指向了 Foundation 框架中的 _NSSetObjectValueAndNotify</p>
<h3 id="元类对象验证"><a href="#元类对象验证" class="headerlink" title="元类对象验证"></a>元类对象验证</h3><p>既然添加KVO监听之后，类对象不是同一个，那元类对象呢？如下验证</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"类对象 - %@ %@"</span>,</span><br><span class="line">          object_getClass(<span class="keyword">self</span>.person),  <span class="comment">// self.person.isa</span></span><br><span class="line">          object_getClass(<span class="keyword">self</span>.person2)); <span class="comment">// self.person2.isa</span></span><br><span class="line">          </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"元类对象 - %@ %@"</span>,</span><br><span class="line">          object_getClass(object_getClass(<span class="keyword">self</span>.person)), <span class="comment">// self.person.isa.isa</span></span><br><span class="line">          object_getClass(object_getClass(<span class="keyword">self</span>.person2))); <span class="comment">// self.person2.isa.isa</span></span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">KVOdemo[<span class="number">13655</span>:<span class="number">177448</span>] 类对象 - NSKVONotifying_YZPerson YZPerson</span><br><span class="line">KVOdemo[<span class="number">13655</span>:<span class="number">177448</span>] 元类对象 - NSKVONotifying_YZPerson YZPerson</span><br></pre></td></tr></table></figure>

<p>可知，元类对象变成了 NSKVONotifying_YZPerson</p>
<h2 id="内部调用流程"><a href="#内部调用流程" class="headerlink" title="内部调用流程"></a>内部调用流程</h2><p>那设置了kvo监听之后，内部调用有什么流程呢？我们在Person中添加如下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">     _name = name;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - begin"</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击屏幕之后，如下打印</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">KVOdemo[<span class="number">17486</span>:<span class="number">233248</span>] willChangeValueForKey</span><br><span class="line">KVOdemo[<span class="number">17486</span>:<span class="number">233248</span>] didChangeValueForKey - begin</span><br><span class="line">KVOdemo[<span class="number">17486</span>:<span class="number">233248</span>] 监听到&lt;YZPerson: <span class="number">0x600000889ca0</span>&gt;的name属性值改变了 - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = ccc;</span><br><span class="line">    old = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125; - <span class="number">1111</span></span><br><span class="line">KVOdemo[<span class="number">17486</span>:<span class="number">233248</span>] didChangeValueForKey - end</span><br></pre></td></tr></table></figure>

<p>也就是说调用 [super didChangeValueForKey:key]; 的时候，监听到监听对象的改变，进而处理监听逻辑</p>
<h2 id="窥探-NSKVONotifying-YZPerson-的方法"><a href="#窥探-NSKVONotifying-YZPerson-的方法" class="headerlink" title="窥探 NSKVONotifying_YZPerson 的方法"></a>窥探 NSKVONotifying_YZPerson 的方法</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printMethodNamesOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 获得方法数组</span></span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储方法名</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得方法</span></span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="comment">// 获得方法名</span></span><br><span class="line">        <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line">        <span class="comment">// 拼接方法名</span></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@", "</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印方法名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, cls, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person添加KVO监听之后 - self.person的类是：%@   里面的方法有："</span>,object_getClass(<span class="keyword">self</span>.person));</span><br><span class="line">    [<span class="keyword">self</span> printMethodNamesOfClass:object_getClass(<span class="keyword">self</span>.person)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行结果为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">KVOdemo[<span class="number">19286</span>:<span class="number">259546</span>] person添加KVO监听之后 - self.person的类是：NSKVONotifying_YZPerson   里面的方法有：</span><br><span class="line">KVOdemo[<span class="number">19286</span>:<span class="number">259546</span>] NSKVONotifying_YZPerson setName:, <span class="keyword">class</span>, <span class="symbol">dealloc, <span class="symbol">_isKVOA</span>,</span></span><br></pre></td></tr></table></figure>

<p>这也进一步验证了，系统重写了新建的子类  <strong>NSKVONotifying_YZPerson</strong> 的setName, class, dealloc，新增了 _isKVOA方法</p>
<h2 id="手动调用KVO"><a href="#手动调用KVO" class="headerlink" title="手动调用KVO"></a>手动调用KVO</h2><p>由上面可知，KVO监听的关键 <strong>willChangeValueForKey</strong> 和 <strong>didChangeValueForKey</strong> 起了关键作用，一般来说只有监听属性发生变化的时候，才能触发监听，但是如果我们想自己手动调用KVO的话，只要自己手动调用这两个方法就可以了。eg:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setNameKVO&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person = [[YZPerson alloc] init];</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:options context:<span class="string">@"1111"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person添加KVO监听之后 - self.person的类是：%@   里面的方法有："</span>,object_getClass(<span class="keyword">self</span>.person));</span><br><span class="line">    [<span class="keyword">self</span> printMethodNamesOfClass:object_getClass(<span class="keyword">self</span>.person)];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="comment">//    self.person.name = @"ccc";</span></span><br><span class="line">    <span class="comment">// 手动调用KVO</span></span><br><span class="line">    [<span class="keyword">self</span>.person willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@属性值改变了 - %@ - %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次点击屏幕的时候，打印如下</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">监听到&lt;YZPerson: <span class="number">0</span>x600003e5b020&gt;的name属性值改变了 - &#123;</span><br><span class="line">    <span class="attr">kind</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="attr">new</span> = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">    <span class="attr">old</span> = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125; - <span class="number">1111</span></span><br></pre></td></tr></table></figure>

<p>可以看到虽然，new 和 old都是null ，也就是name的值没有改变，但是因为我们手动调用了,</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">self.person</span> willChangeValueForKey:@<span class="string">"name"</span>]<span class="comment">;</span></span><br><span class="line">   </span><br><span class="line">[<span class="name">self.person</span> didChangeValueForKey:@<span class="string">"name"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>所以就是会触发KVO</p>
<h2 id="拓展深入"><a href="#拓展深入" class="headerlink" title="拓展深入"></a>拓展深入</h2><h3 id="iOS用什么方式实现对一个对象的KVO？-KVO的本质是什么？"><a href="#iOS用什么方式实现对一个对象的KVO？-KVO的本质是什么？" class="headerlink" title="iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)"></a>iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</h3><ul>
<li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<br>willChangeValueForKey:<br>父类原来的setter<br>didChangeValueForKey:<br>内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li>
</ul>
<h3 id="如何手动触发KVO？"><a href="#如何手动触发KVO？" class="headerlink" title="如何手动触发KVO？"></a>如何手动触发KVO？</h3><ul>
<li>手动调用willChangeValueForKey:和didChangeValueForKey:</li>
</ul>
<h3 id="直接修改成员变量会触发KVO么？"><a href="#直接修改成员变量会触发KVO么？" class="headerlink" title="直接修改成员变量会触发KVO么？"></a>直接修改成员变量会触发KVO么？</h3><ul>
<li>不会触发KVO</li>
</ul>
<p>因为，触发KVO是因为，执行set方法时候，调用 <strong>willChangeValueForKey</strong> <strong>didChangeValueForKey</strong> 但是直接修改成员变量不会调用set方法</p>
<p>eg:<br>我们把name 成员变量 设置为如下的形式，就不会自动生成set 和 get方法</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">YZPerson </span>: NSObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@public</span></span><br><span class="line">    NSString *_name;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@property</span> (nonatomic ,assign) int age;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<p>在监听控制器里面，改成如下操作,直接修改成员变量</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person-&gt;_name = <span class="string">@"abc"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是不会触发KVO的，如果我们想让它触发KVO，就手动调用，如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.person willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    <span class="keyword">self</span>.person-&gt;_name = <span class="string">@"abc"</span>;</span><br><span class="line">	 [<span class="keyword">self</span>.person didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这样就可以触发KVO了。</p>
<h3 id="通过KVC修改属性会触发KVO么？"><a href="#通过KVC修改属性会触发KVO么？" class="headerlink" title="通过KVC修改属性会触发KVO么？"></a>通过KVC修改属性会触发KVO么？</h3><ul>
<li>会触发KVO</li>
<li>详细分析见 <a href="https://ityongzhen.github.io/KVC%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B.html">KVC那点儿事</a></li>
</ul>
<h3 id="KVC-与-KVO-的不同？"><a href="#KVC-与-KVO-的不同？" class="headerlink" title="KVC 与 KVO 的不同？"></a>KVC 与 KVO 的不同？</h3><p>KVC(键值编码)，即 Key-Value Coding，一个非正式的 Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用 Setter、Getter 方法等显式的存取方式去访问。<br>KVO(键值监听)，即 Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后,对象就会接受到通知，前提是执行了 setter 方法、或者使用了 KVC 赋值。</p>
<h3 id="KVO和-notification-通知-的区别？"><a href="#KVO和-notification-通知-的区别？" class="headerlink" title="KVO和 notification(通知)的区别？"></a>KVO和 notification(通知)的区别？</h3><p>notification 比 KVO 多了发送通知的一步。<br>两者都是一对多，但是对象之间直接的交互，notification 明显得多，需要notificationCenter 来做为中间交互。而 KVO 如我们介绍的，设置观察者-&gt;处理属性变化，至于中间通知这一环，则隐秘多了，只留一句“交由系统通知”，具体的可参照以上实现过程的剖析。</p>
<p>notification 的优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，例如键盘、前后台等系统通知的使用也更显灵活方便。</p>
<h3 id="KVO与-delegate-的不同？"><a href="#KVO与-delegate-的不同？" class="headerlink" title="KVO与 delegate 的不同？"></a>KVO与 delegate 的不同？</h3><p>和 delegate 一样，KVO 和 NSNotification 的作用都是类与类之间的通信。但是与 delegate 不同的是：<br>这两个都是负责发送接收通知，剩下的事情由系统处理，所以不用返回值；而 delegate 则需要通信的对象通过变量(代理)联系；<br>delegate 一般是一对一，而这两个可以一对多。</p>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
<p><a href="https://segmentfault.com/a/1190000013813643" target="_blank" rel="noopener">KVO原理分析及使用进阶</a></p>
<p><a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FackBook的KVOController</a> </p>
<p><a href="https://www.jianshu.com/p/e59bb8f59302" target="_blank" rel="noopener">iOS开发 – KVO的实现原理与具体应用</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>详解RunLoop与多线程</title>
    <url>/%E8%AF%A6%E8%A7%A3RunLoop%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html/</url>
    <content><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3RunLoop%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">个人博客</a></p>
<h2 id="控制线程生命周期（线程保活）"><a href="#控制线程生命周期（线程保活）" class="headerlink" title="控制线程生命周期（线程保活）"></a>控制线程生命周期（线程保活）</h2><p>通过上一篇<a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3RunLoop%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">详解RunLoop之源码分析</a> 我们知道了runlLoop每条线程都有唯一的一个与之对应的RunLoop对象 并且 RunLoop会在线程结束时销毁<br>接下来就具体分析RunLoop会在线程结束时销毁这个特点</p>
<p>首先定义一个YZThread继承自NSThread 重写它的dealloc方法，为了检测是否销毁<br>然后，创建该类，并执行方法，如下图所示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** YZThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZThread</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZThread *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">      YZThread *thread = [[YZThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">    [thread start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> Interview03-线程保活[<span class="number">7854</span>:<span class="number">134789</span>] -[ViewController run] &lt;YZThread: <span class="number">0x600000a13b80</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">Interview03-线程保活[<span class="number">7854</span>:<span class="number">134789</span>] -[YZThread dealloc]</span><br></pre></td></tr></table></figure>
<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-68ebe0a1db98ffbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->

<p>从结果中，我们发现，当执行完run这个方法之后，该线程就销毁了。</p>
<p>但是在项目中，或者很多第三方中(比如AFN)，可能会遇到这个线程我们经常做事情，如果每次都销毁、创建、销毁、、、那么对性能也是一种损耗.我们就需要我们自己控制线程的销毁和创建。<br>上面线程之所以立即销毁，根据上篇文章我们知道，</p>
<ul>
<li>是因为 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出<br>那我们给它加上这些东西不就行了么？来试试看吧。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** YZThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZThread</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZThread *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">      YZThread *thread = [[YZThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">    [thread start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s ----end----"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Interview03-线程保活[<span class="number">7967</span>:<span class="number">136867</span>] -[ViewController run] &lt;YZThread: <span class="number">0x600003105b00</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>

<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-fa48f4d18531e917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->
<p>如上所示，添加了port之后，该线程就没有调用dealloc方法了。上一篇介绍了，Source1包含了基于Port的线程间通信，也就是说。添加了port之后，相当于有了source1 那么线程就不会退出，也就不会调用dealloc方法了。</p>
<p>但是如果我们想在这个线程执行自己的操作，那就需要我们持有这个线程了。如下图所示，增加个属性，并且屏幕点击事件中调用test方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** YZThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZThread</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZThread *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.thread = [[YZThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s ----end----"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法的目的：线程保活</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击屏幕"</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Interview03-线程保活[<span class="number">8035</span>:<span class="number">138457</span>] -[ViewController run] &lt;YZThread: <span class="number">0x60000232d4c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line"> Interview03-线程保活[<span class="number">8035</span>:<span class="number">138399</span>] 点击屏幕</span><br><span class="line">Interview03-线程保活[<span class="number">8035</span>:<span class="number">138457</span>] -[ViewController test] &lt;YZThread: <span class="number">0x60000232d4c0</span>&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure>
<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-28907f837de1264c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->

<p>果然是线程不会销毁，而且 由 number = 3 可知，确实是在我们自己创建的线程中执行的操作</p>
<p>接下来我们再看一个问题，首先在控制器中写上dealloc方法，</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"%s"</span>, __func__)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后给个导航控制器跳转到当前控制器，之后返回的时候发现dealloc并没有执行<br>这是因为代码中用的</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.thread = [[YZThread alloc] initWithTarget:<span class="keyword">self</span> <span class="keyword">selector</span>:@<span class="keyword">selector</span>(run) object:<span class="keyword">nil</span>];</span><br></pre></td></tr></table></figure>
<p>这个方法，会导致线程持有当前控制器，导致循环引用，如果解除循环引用，需要把这个initWithTarget 换成initWithBlock</p>
<p>我们将之前的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.thread = [[YZThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s ----end----"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">self</span>.thread = [[YZThread alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@----begin----"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        <span class="comment">// 这个方法会不能退出循环</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">               </span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Interview03-线程保活[<span class="number">8035</span>:<span class="number">138457</span>] -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-7a5b894d4017485f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->

<p>这次控制器可以销毁了。然后，你可能已经发现了，虽然控制器可以销毁，但是线程并没有销毁。换句话说，虽然没有循环引用了。而且控制器销毁了，然后线程依然没有销毁，这是为什么呢。</p>
<h2 id="NSRunLoop-currentRunLoop-run"><a href="#NSRunLoop-currentRunLoop-run" class="headerlink" title="[[NSRunLoop currentRunLoop] run]"></a>[[NSRunLoop currentRunLoop] run]</h2><h3 id="注意-NSRunLoop-currentRunLoop-run"><a href="#注意-NSRunLoop-currentRunLoop-run" class="headerlink" title="注意[[NSRunLoop currentRunLoop] run]"></a>注意[[NSRunLoop currentRunLoop] run]</h3><p>其实关键的一句代码是</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[[<span class="name">NSRunLoop</span> currentRunLoop] run]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>看一下官方对这个方法的解释</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Discussion</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> no input sources <span class="keyword">or</span> timers are attached <span class="keyword">to</span> the run <span class="keyword">loop</span>, this <span class="function"><span class="keyword">method</span> <span class="title">exits</span> <span class="title">immediately</span>;</span></span><br><span class="line"> otherwise, it runs the receiver <span class="keyword">in</span> the NSDefaultRunLoopMode <span class="keyword">by</span> repeatedly invoking runMode:beforeDate:. </span><br><span class="line"> <span class="keyword">In</span> other words, this <span class="function"><span class="keyword">method</span> <span class="title">effectively</span> <span class="title">begins</span> <span class="title">an</span> <span class="title">infinite</span> <span class="title">loop</span> <span class="title">that</span> <span class="title">processes</span> <span class="title">data</span> <span class="title">from</span> <span class="title">the</span> <span class="title">run</span> <span class="title">loop</span>’<span class="title">s</span> <span class="title">input</span> <span class="title">sources</span> <span class="title">and</span> <span class="title">timers</span>.</span></span><br></pre></td></tr></table></figure>
<p>也就是说，NSRunLoop的run方法是无法停止的，它专门用于开启一个永不销毁的线程（NSRunLoop）<br>就相当于</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>就算我们手动调用停止RunLoop的方法，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 停止RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br></pre></td></tr></table></figure>
<p>也无法停止这个线程，因为这个只能停止这一次的RunLoop,下次循环，依然可以继续进行下去</p>
<p>我们把代码修改为如下的写法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">self</span>.thread = [[YZThread alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@----begin----"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@----end----"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于停止子线程的RunLoop</span></span><br><span class="line">- (<span class="keyword">void</span>)stopThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置标记为NO</span></span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用一个bool值做未标记,当下次进来的时候。判断已经停止了。那就不进入下次RunLoop了，就可以退出循环</p>
<p><strong>注意</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走）</span></span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(stopThread) <span class="string">onThread:</span>self.thread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>YES];</span><br></pre></td></tr></table></figure>

<p>至此，我们代码如下所示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZThread *thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isStoped) <span class="built_in">BOOL</span> stopped;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.thread = [[YZThread alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@----begin----"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        <span class="comment">// 这个方法会不能退出循环</span></span><br><span class="line"><span class="comment">//        [[NSRunLoop currentRunLoop] run];</span></span><br><span class="line">        <span class="keyword">while</span> (!weakSelf.isStoped) &#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@----end----"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)stop &#123;</span><br><span class="line">    <span class="comment">// 在子线程调用stop</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopThread) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于停止子线程的RunLoop</span></span><br><span class="line">- (<span class="keyword">void</span>)stopThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置标记为NO</span></span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s %@"</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [self stop];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-96f84c22b8766692.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->

<h2 id="封装线程"><a href="#封装线程" class="headerlink" title="封装线程"></a>封装线程</h2><p>到这里，我们已经可以控制线程的创建，执行，销毁了。<br>但是，这也太复杂了吧。每次我们都需要写这么多代码，如果我们每次，都这么干的话，岂不是疯掉了。所以我们要抽取出来，这样，以后用的时候，直接拿来就可以了。</p>
<p>首先新建一个继承自 NSObject的类YZPermenantThread 然后持有一个NSThread的属性，注意这里不是直接继承NSThread 是因为，如果继承了NSThread 那么外界调用的时候，可以直接使用NSThread的方法，会影响线程的使用。所以，本着简洁，可控的原则，定义的类继承自NSThread 然后拥有属性NSThread，这样，外界只能使用我们暴露出去接口。</p>
<p>.h中代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZPermenantThreadTask)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPermenantThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开启线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//- (void)run;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在当前子线程执行一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(YZPermenantThreadTask)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 结束线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br></pre></td></tr></table></figure>
<p>.m中代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** YZPermenantThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPermenantThread</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span> *innerThread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPermenantThread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - public methods</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"begin----"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建上下文（要初始化一下结构体）</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建source</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 往Runloop中添加source</span></span><br><span class="line">            <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopDefaultMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 销毁source</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(source);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span></span><br><span class="line">            <span class="comment">//                // 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span></span><br><span class="line">            <span class="comment">//                CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true);</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"end----"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- (void)run</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if (!self.innerThread) return;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [self.innerThread start];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(YZPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)__stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(YZPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>YZPermenantThread.h 就是这样的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^YZPermenantThreadTask)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPermenantThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开启线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//- (void)run;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在当前子线程执行一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(YZPermenantThreadTask)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 结束线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-92bf3f5f5c91efcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->
<p>YZPermenantThread.m 就是这样的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YZPermenantThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** YZThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZThread</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** YZPermenantThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YZPermenantThread</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span> *innerThread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YZPermenantThread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - public methods</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"begin----"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建上下文（要初始化一下结构体）</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建source</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 往Runloop中添加source</span></span><br><span class="line">            <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopDefaultMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 销毁source</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(source);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span></span><br><span class="line">            <span class="comment">//                // 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span></span><br><span class="line">            <span class="comment">//                CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true);</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"end----"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- (void)run</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if (!self.innerThread) return;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [self.innerThread start];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(YZPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)__stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(YZPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-21d4500bcdd19d2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/3373351-d7651f5badd92a1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->

<p>这样就简单封装了线程，而且因为是用C语言创建的，能更灵活的控制 看官方对CFRunLoopAddSource的定义，第三个参数，如果是false,那么这个线程，执行完当前这次RunLoop，不会退出。这样写的话，就可以保证线程一直存在。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="regexp">//</span>第三个参数 ：A flag indicating whether the run loop should <span class="keyword">exit</span> after processing one source. </span><br><span class="line"><span class="regexp">//</span>If false, the run loop continues processing events until seconds has passed.</span><br><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);</span><br></pre></td></tr></table></figure>

<h2 id="封装之后的使用"><a href="#封装之后的使用" class="headerlink" title="封装之后的使用"></a>封装之后的使用</h2><p>使用的时候，我们可以主动调用stop 来销毁掉线程，也可以，不做任何处理，当控制器销毁时候，YZPermenantThread对象就会销毁，根据</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知，RunLoop也会停止，线程也就退出了。所以使用的时候，如下所示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YZPermenantThread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YZPermenantThread *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">     <span class="keyword">self</span>.thread = [[YZPermenantThread alloc] init];</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.thread executeTask:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务 - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)stop &#123;</span><br><span class="line">    [<span class="keyword">self</span>.thread stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<!--![image.png](https://upload-images.jianshu.io/upload_images/3373351-638ce4f6cd8239dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)-->

<p>至此。就说完了RunLoop和线程直接关系，以及线程的保活，以及自定义线程。这样使用起来更加得心用手。</p>
<p>本文相关代码github地址 <a href="https://github.com/ITyongzhen/MyBlogs-iOS-Demos" target="_blank" rel="noopener">github</a></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">RunLoop官方源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>详解RunLoop之源码分析</title>
    <url>/%E8%AF%A6%E8%A7%A3RunLoop%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html/</url>
    <content><![CDATA[<p> 首发于 <a href="https://ityongzhen.github.io/%E8%AF%A6%E8%A7%A3RunLoop%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">个人博客</a></p>
<h2 id="RunLoop是什么"><a href="#RunLoop是什么" class="headerlink" title="RunLoop是什么"></a>RunLoop是什么</h2><p>runloop 是什么？Runloop 还是比较顾名思义的一个东西，说白了就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 Runloop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，Runloop 会进入休眠状态，有事件发生时， Runloop 会去找对应的 Handler 处理事件。Runloop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠</p>
<h3 id="开始之前，先想想这几道面试题"><a href="#开始之前，先想想这几道面试题" class="headerlink" title="开始之前，先想想这几道面试题"></a>开始之前，先想想这几道面试题</h3><ul>
<li>runloop和线程的关系？</li>
<li>timer 与 runloop 的关系？</li>
<li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</li>
<li>runloop内部实现逻辑？</li>
<li>runloop 是怎么响应用户操作的， 具体流程是什么样的？</li>
<li>说说runLoop的几种状态</li>
<li>runloop的mode作用是什么？</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>回答问题之前，我们先看源码</p>
<p>RunLoop 源码  <a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a> 里面数字最大的是最 新的，下载最新的     CF-1153.18.tar.gz(写本文时候的最新版本)</p>
<p>查看源码 中的</p>
 <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">       CHECK_FOR_FORK();</span><br><span class="line">       <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">       <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">       <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 </p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">_CFRu<span class="symbol">nLoopGet0</span> 获取的</span><br></pre></td></tr></table></figure>


<p>进去查看做了什么</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">loop = (CFRunLoopRef)<span class="constructor">CFDictionaryGetValue(<span class="params">__CFRunLoops</span>, <span class="params">pthreadPointer</span>(<span class="params">t</span>)</span>);</span><br><span class="line">	<span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">	    <span class="constructor">CFDictionarySetValue(<span class="params">__CFRunLoops</span>, <span class="params">pthreadPointer</span>(<span class="params">t</span>)</span>, newLoop);</span><br><span class="line">	    loop = newLoop;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>发现有这么一个获取线程的方法，也就是传入一个线程作为key，获取一个loop,如果loop为空，就以这个线程为key创建runloop</p>
<p>小结:</p>
<ul>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li>
<li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li>
<li>RunLoop会在线程结束时销毁(下面分析这一条)</li>
</ul>
<h3 id="runloop的mode"><a href="#runloop的mode" class="headerlink" title="runloop的mode"></a>runloop的mode</h3><p>接下来认识一下runloop的主要类<br>Core Foundation中关于RunLoop的5个类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopModeRef</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span></span><br></pre></td></tr></table></figure>
<p>看一下runloop结构体</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">struct <span class="variable">__CFRunLoop</span> &#123;</span><br><span class="line">    CFRuntimeBase <span class="variable">_base</span>;</span><br><span class="line">    pthread_mutex_t <span class="variable">_lock</span>;			<span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    <span class="variable">__CFPort</span> <span class="variable">_wakeUpPort</span>;			<span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean <span class="variable">_unused</span>;</span><br><span class="line">    volatile <span class="variable">_per_run_data</span> *<span class="variable">_perRunData</span>;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    pthread_t <span class="variable">_pthread</span>;</span><br><span class="line">    uint32_t <span class="variable">_winthread</span>;</span><br><span class="line">    CFMutableSetRef <span class="variable">_commonModes</span>;</span><br><span class="line">    CFMutableSetRef <span class="variable">_commonModeItems</span>;</span><br><span class="line">    CFRunLoopModeRef <span class="variable">_currentMode</span>;</span><br><span class="line">    CFMutableSetRef <span class="variable">_modes</span>;</span><br><span class="line">    struct <span class="variable">_block_item</span> *<span class="variable">_blocks_head</span>;</span><br><span class="line">    struct <span class="variable">_block_item</span> *<span class="variable">_blocks_tail</span>;</span><br><span class="line">    CFAbsoluteTime <span class="variable">_runTime</span>;</span><br><span class="line">    CFAbsoluteTime <span class="variable">_sleepTime</span>;</span><br><span class="line">    CFTypeRef <span class="variable">_counterpart</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只保留主要的就剩下了</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunLoopRef</span>;</span><br><span class="line"> <span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">	 pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode; <span class="comment">//当前模式</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">//所有的模式</span></span><br><span class="line">  	<span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>理解为CFRunLoopRef中包含有_modes，modes是由 CFRunLoopModeRef组成的集合<br>这些modes中，只有一种是当前模式，称为 _currentMode</p>
<p>接下来我们看看runloopmode中究竟有什么，同样，只保留主要的，关键就是下面4个</p>
<p>总结起来就是</p>
<ul>
<li>CFRunLoopModeRef代表RunLoop的运行模式</li>
<li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</li>
<li>RunLoop启动时只能选择其中一个Mode，作为currentMode</li>
<li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入</li>
<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>
<li>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以理解为，RunLoop中有许多模式，但当前运行的只有一种，一个图来表示，就是<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114044.png" alt=""></p>
<p>具体在某一种runloop中的运行逻辑，官方给出下图<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114135.png" alt=""></p>
<p>那么，前面说的，_sources0、_sources1、_observers、_timers J究竟包含了什么呢？<br>先用一张图来总结一下，然后再详细介绍<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114205.png" alt=""></p>
<p>如上图所示，_sources0 包含触摸事件，和 performSelector:onThread:<br>跑一下代码证明一下，<br>首先创建一个新项目，实现点击事件，NSLog只是为了打断点</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"这个打印只是为了打断点"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">断点暂停之后，输入lldb指令 bt 之后如图所示</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114248.png" alt=""></p>
<p>从打印日志来看 调用了<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong> 这个SOURCE0方法<br>那么接下来验证一下performSelector<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114313.png" alt=""><br>由上图可知，performSelector 也是执行了source0</p>
<p>那我们再看一下Timer<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114336.png" alt=""><br>如上图所示，这次是<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></p>
<p>对于其他几种情况，读者课自行验证。</p>
<p>用一幅图来总结RunLoop的运行逻辑<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114424.png" alt=""></p>
<h2 id="源码内部细节分析"><a href="#源码内部细节分析" class="headerlink" title="源码内部细节分析"></a>源码内部细节分析</h2><p>要想分析源码首先要知道入口在哪里，由前面的断点可知<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114446.png" alt=""><br>入口为 CFRunLoopRunSpecific<br>去源码中找到之后发现有很多。只保留关键信息</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SInt32 <span class="constructor">CFRunLoopRunSpecific(CFRunLoopRef <span class="params">rl</span>, CFStringRef <span class="params">modeName</span>, CFTimeInterval <span class="params">seconds</span>, Boolean <span class="params">returnAfterSourceHandled</span>)</span> &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="constructor">CHECK_FOR_FORK()</span>;</span><br><span class="line">    <span class="comment">// 通知Observers: 进入Loop</span></span><br><span class="line">  <span class="constructor">__CFRunLoopDoObservers(<span class="params">rl</span>, <span class="params">currentMode</span>, <span class="params">kCFRunLoopEntry</span>)</span>;</span><br><span class="line">    <span class="comment">// 具体要做的事情</span></span><br><span class="line">	result = <span class="constructor">__CFRunLoopRun(<span class="params">rl</span>, <span class="params">currentMode</span>, <span class="params">seconds</span>, <span class="params">returnAfterSourceHandled</span>, <span class="params">previousMode</span>)</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 通知Observers: 退出Loop</span></span><br><span class="line">	<span class="constructor">__CFRunLoopDoObservers(<span class="params">rl</span>, <span class="params">currentMode</span>, <span class="params">kCFRunLoopExit</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们继续跟__CFRunLoopRun 看看做了什么，发现里面很长的东西，整理了一下，只保留关键代码，如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rl, rlm are locked on entrance and exit */</span></span><br><span class="line">static int32_t <span class="constructor">__CFRunLoopRun(CFRunLoopRef <span class="params">rl</span>, CFRunLoopModeRef <span class="params">rlm</span>, CFTimeInterval <span class="params">seconds</span>, Boolean <span class="params">stopAfterHandle</span>, CFRunLoopModeRef <span class="params">previousMode</span>)</span> &#123;</span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 通知Observers: 即将处理Timers</span></span><br><span class="line">        <span class="constructor">__CFRunLoopDoObservers(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">kCFRunLoopBeforeTimers</span>)</span>;</span><br><span class="line">        <span class="comment">// 通知Observers: 即将处理Sources</span></span><br><span class="line">        <span class="constructor">__CFRunLoopDoObservers(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">kCFRunLoopBeforeSources</span>)</span>;</span><br><span class="line">        <span class="comment">// 处理Blocks</span></span><br><span class="line">        <span class="constructor">__CFRunLoopDoBlocks(<span class="params">rl</span>, <span class="params">rlm</span>)</span>;</span><br><span class="line">        <span class="comment">// 处理Sources0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">__CFRunLoopDoSources0(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">stopAfterHandle</span>)</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理Blocks</span></span><br><span class="line">            <span class="constructor">__CFRunLoopDoBlocks(<span class="params">rl</span>, <span class="params">rlm</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boolean poll = sourceHandledThisLoop<span class="operator"> || </span>(<span class="number">0</span>ULL<span class="operator"> == </span>timeout_context-&gt;termTSR);</span><br><span class="line">        <span class="comment">//判断有无source1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">__CFRunLoopServiceMachPort(<span class="params">dispatchPort</span>, &amp;<span class="params">msg</span>, <span class="params">sizeof</span>(<span class="params">msg_buffer</span>)</span>, &amp;livePort, <span class="number">0</span>, &amp;voucherState, NULL)) &#123; <span class="comment">// 如果有source1 就跳转到 handle_msg</span></span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知Observers: 即将休眠</span></span><br><span class="line">        <span class="constructor">__CFRunLoopDoObservers(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">kCFRunLoopBeforeWaiting</span>)</span>;</span><br><span class="line">        <span class="constructor">__CFRunLoopSetSleeping(<span class="params">rl</span>)</span>;</span><br><span class="line">        <span class="comment">// 通知Observers: 结束休眠</span></span><br><span class="line">        <span class="constructor">__CFRunLoopServiceMachPort(<span class="params">waitSet</span>, &amp;<span class="params">msg</span>, <span class="params">sizeof</span>(<span class="params">msg_buffer</span>)</span>, &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">    handle_msg:;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (被Timer唤醒) &#123;</span><br><span class="line">            <span class="comment">// 处理Timers</span></span><br><span class="line">            <span class="constructor">__CFRunLoopDoTimers(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">mach_absolute_time</span>()</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (被gcd唤醒) &#123;</span><br><span class="line">            <span class="comment">//处理GCD</span></span><br><span class="line">            <span class="constructor">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class="params">msg</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//能来到这里，就说明被Source1唤醒</span></span><br><span class="line">            </span><br><span class="line">            <span class="constructor">__CFRunLoopDoSource1(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">rls</span>, <span class="params">msg</span>, <span class="params">msg</span>-&gt;<span class="params">msgh_size</span>, &amp;<span class="params">reply</span>)</span><span class="operator"> || </span>sourceHandledThisLoop;</span><br><span class="line">            <span class="comment">// 处理Blocks</span></span><br><span class="line">            <span class="constructor">__CFRunLoopDoBlocks(<span class="params">rl</span>, <span class="params">rlm</span>)</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置返回值，决定是否继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop<span class="operator"> &amp;&amp; </span>stopAfterHandle) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach<span class="constructor">_absolute_time()</span>) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="constructor">__CFRunLoopIsStopped(<span class="params">rl</span>)</span>) &#123;</span><br><span class="line">                <span class="constructor">__CFRunLoopUnsetStopped(<span class="params">rl</span>)</span>;</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">                rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="constructor">__CFRunLoopModeIsEmpty(<span class="params">rl</span>, <span class="params">rlm</span>, <span class="params">previousMode</span>)</span>) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            voucher<span class="constructor">_mach_msg_revert(<span class="params">voucherState</span>)</span>;</span><br><span class="line">            os<span class="constructor">_release(<span class="params">voucherCopy</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span><span class="operator"> == </span>retVal);</span><br><span class="line">        </span><br><span class="line">        return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截图下来的话，就是这样的<br><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114509.png" alt=""></p>
<p>###调用细节<br>前面说了大概的流程，那么，具体怎么调用的呢，lldb调试堆栈的时候，那些方法怎么调用的呢？这里以 __CFRunLoopDoTimers 为例，看下源码怎么调用的</p>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114529.png" alt=""><br>上图可知，关键代码是 CFRunLoopTimerRef<br>继续查看 CFRunLoopTimerRef</p>
<p><img src="https://gitee.com/yinyongzhen/myBlogsPictures/raw/master/img/20200528114554.png" alt=""><br>关键代码是<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong><br>看到这里是不是对前面截图中的调用堆栈更清晰了呢。<br>其他几种也都是类似的逻辑，就不赘述了。</p>
<h2 id="目前已知的Mode有五种"><a href="#目前已知的Mode有五种" class="headerlink" title="目前已知的Mode有五种"></a>目前已知的Mode有五种</h2><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">目前已知的<span class="keyword">Mode</span>有<span class="number">5</span>种</span><br><span class="line">kCFRunLoopDefaultMode：App的默认<span class="keyword">Mode</span>，通常主线程是在这个<span class="keyword">Mode</span>下运行</span><br><span class="line"></span><br><span class="line">UITrackingRunLoopMode：界面跟踪 <span class="keyword">Mode</span>，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 <span class="keyword">Mode</span> 影响</span><br><span class="line"></span><br><span class="line">UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 <span class="keyword">Mode</span>，启动完成后就不再使用</span><br><span class="line"></span><br><span class="line">GSEventReceiveRunLoopMode：接受系统事件的内部 <span class="keyword">Mode</span>，通常用不到</span><br><span class="line"></span><br><span class="line">kCFRunLoopCommonModes：这是一个占位用的<span class="keyword">Mode</span>，不是一种真正的<span class="keyword">Mode</span></span><br></pre></td></tr></table></figure>

<h2 id="RunLoop的状态"><a href="#RunLoop的状态" class="headerlink" title="RunLoop的状态"></a>RunLoop的状态</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),           <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),    <span class="comment">//即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),   <span class="comment">//即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),   <span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),    <span class="comment">//刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),            <span class="comment">//即将退出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>常见的2种Mode</p>
<ul>
<li><p>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</p>
</li>
<li><p>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</p>
</li>
</ul>
<h2 id="RunLoop-和-NSTimer"><a href="#RunLoop-和-NSTimer" class="headerlink" title="RunLoop 和 NSTimer"></a>RunLoop 和 NSTimer</h2><p>我们知道，默认情况下，NSTimer计时器，会被UIScrollView 打断，会影响计时器的使用。原因就是滚动时候，RunLoop切换到了UITrackingRunLoopMode模式下，但计时器在NSDefaultRunLoopMode下，所以就停止了。解决办法就是设置NSRunLoopCommonModes。特别注意的是：</p>
<p><strong>NSRunLoopCommonModes并不是一个真的模式，它只是一个标记</strong></p>
<p>本文参考资料:</p>
<p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">RunLoop官方源码</a></p>
<p><a href="https://ke.qq.com/course/package/11609" target="_blank" rel="noopener">iOS底层原理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
</search>
