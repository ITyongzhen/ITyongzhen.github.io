---
layout: post
title: 设计模式之(八)访问者模式
date: 2019-03-30 17:32:24.000000000 +09:00
categories: 
- 设计模式
---


[本文首发于个人博客](https://ityongzhen.github.io/设计模式之(八)访问者模式.html)

## 前言

**本文代码为java代码**

### 什么是访问者模式

[访问者模式](https://www.runoob.com/design-pattern/visitor-pattern.html)  属于行为型模式，在[菜鸟教程](https://www.runoob.com/design-pattern/visitor-pattern.html)中的定义如下

>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。


## 模式结构


### 介绍
- 意图：主要将数据结构与数据操作分离。

### 主要解决：
- 稳定的数据结构和易变的操作耦合问题。

### 何时使用：
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。

### 如何解决：
- 在被访问的类里面加一个对外提供接待访问者的接口。

### 关键代码：
- 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

### 应用实例：
- 您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。

### 优点： 
- 符合单一职责原则。 
- 优秀的扩展性。 3、灵活性。

### 缺点： 
- 具体元素对访问者公布细节，违反了迪米特原则。 
- 具体元素变更比较困难。 
- 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

### 使用场景： 
- 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。

###  注意事项：
- 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。


## 代码



### 场景
假设我们写了一个平衡二叉树，那么对应的肯定有对应的肯定有添加元素，删除元素，中序遍历，后序遍历...等等。我们就以中序遍历二叉树为例，先看不用访问者模式会有什么问题。


### Node 

创建`Node`节点类，有左子树，右子树，父节点

~~~~
public static class Node<E> {
		Integer element;
		Node<Integer> left;
		Node<Integer> right;
		Node<Integer> parent;
		public Node(Integer element, Node<Integer> parent) {
			this.element = element;
			this.parent = parent;
		}
	}
~~~~

### BinarySearchTree

创建`BinarySearchTree`类，有size，根节点`root`, 添加，删除，遍历等等

~~~~
public class BinarySearchTree<Integer> {
	private int size;
	public Node<Integer> root;
	
	public void add(Integer element) {
		//添加的代码就不写了
	}
	
	public void remove(Integer element) {
		//删除的代码就不写了	
	}
	
	... 其他接口
	
	// 中序遍历
	
	private void inorder(Node<Integer> node) {
		if (node == null ) return;
	
		// 遍历左子树
		inorder(node.left);
		// 打印
		System.out.println(node.element);
		
		// 遍历右子树
		inorder(node.right);
	}
}


~~~~

### 存在的问题？

上面的代码是否也是可以用的，调用`inorder `遍历之后，这个二叉树可以按照中序遍历的方式打印出来，似乎没什么问题。但是仔细想想，其实存在问题的。因为这个我们写死了是打印出元素，假设我们真正使用的时候，不是想直接打印呢？而是想每个元素的值加上2 然后再打印呢？又或者每个元素的值加上10，而且不想打印呢?

你可能会说，那简单啊，直接改啊，例如每个元素的值加上2 然后再打印

~~~~
public class BinarySearchTree<Integer> {
	//... 其他接口
	
	// 中序遍历
	
	private void inorder(Node<Integer> node) {
		if (node == null ) return;
		// 遍历左子树
		inorder(node.left);
		
		// 打印
		System.out.println(node.element + 2);

		// 遍历右子树
		inorder(node.right);
	}
}


~~~~

看起来也没问题，既然是加上2再打印那就直接加上2再打印咯。但是有如下两个问题

- 很麻烦，每次不同的场景都要修改遍历的实现
- 如果是我们提供给外界使用的话，尽量不要让使用者修改内部实现。

也就是说，有没有一种不修改遍历的具体实现，就能满足不同场景下的遍历呢？答案是有的，就是访问者模式

### 访问者模式


~~~~
public class BinarySearchTree<Integer> {
	private int size;
	public Node<Integer> root;
	
	public void add(Integer element) {
		//添加的代码就不写了
	}
	
	public void remove(Integer element) {
		//删除的代码就不写了	
	}
	
	... 其他接口
	
	// 中序遍历
	public void inorder(Visitor<Integer> visitor) {
		if (visitor == null) return;
		inorder(root, visitor);
	}
	
	
	private void inorder(Node<Integer> node, Visitor<Integer> visitor) {
		if (node == null ) return;
		
		//遍历左子树
		inorder(node.left, visitor);
		
		// 元素给visitor，具体的逻辑由外界的visitor处理
		visitor.visit(node.element);
		
		//遍历右子树
		inorder(node.right, visitor);
	}
}


~~~~

### 使用访问者模式的调用

这样修改之后，使用的时候

每个节点的值加上2再打印

~~~~
BinarySearchTree<Integer> bst = new BinarySearchTree<>();
bst.preorder(new Visitor<Integer>() {
	public boolean visit(Integer element) {
		System.out.print(element + 2);
	}
});
~~~~

每个节点的值加上10再打印

~~~~
BinarySearchTree<Integer> bst = new BinarySearchTree<>();
bst.preorder(new Visitor<Integer>() {
	public boolean visit(Integer element) {
		System.out.print(element + 10);
	}
});
~~~~

这样的话，无论使用者如何更改需求，不同的场景下，都不用修改二叉树内部的遍历代码，都可以满足。

