---
layout: post
title: 十大排序算法之冒泡排序
date: 2018-06-08 17:32:24.000000000 +09:00
categories: 
- 数据结构&算法
---


本文首发于[个人博客](https://ityongzhen.github.io/十大排序算法之冒泡排序.html)

https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1
## 前言

本系列排序包括十大经典排序算法。

![](https://user-gold-cdn.xitu.io/2019/11/14/16e6883ad25132a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 使用的语言为：Java
- 结构为：
定义抽象类`Sort`里面实现了，交换，大小比较等方法。例如交换两个值，直接传入下标就可以了。其他的具体排序的类都继承抽象类`Sort`。这样我们就能专注于算法本身。


~~~~
/*
	 * 返回值等于0，代表 array[i1] == array[i2]
	 * 返回值小于0，代表 array[i1] < array[i2]
	 * 返回值大于0，代表 array[i1] > array[i2]
	 */
	protected int cmp(int i1, int i2) {
		return array[i1].compareTo(array[i2]);
	}
	
	protected int cmp(T v1, T v2) {
		return v1.compareTo(v2);
	}
	
	protected void swap(int i1, int i2) {
		T tmp = array[i1];
		array[i1] = array[i2];
		array[i2] = tmp;
	}

~~~~

## 什么是冒泡排序

- [冒泡排序（Bubble Sort）](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin)是一种计算机科学领域的较简单的排序算法。
- 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
- 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

## 算法原理
- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![](https://user-gold-cdn.xitu.io/2019/10/28/16e11936eb22cb7c?w=614&h=300&f=png&s=191258)

## 算法分析

### 时间复杂度
- 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M 均达到最小值：C=n-1 ， M=0。
- 所以，冒泡排序最好的时间复杂度为O(n) 。
- 若初始文件是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
C = n(n-1)/2 = O(n^2).
M = 3n(n-1)/2 = O(n^2).

冒泡排序的最坏时间复杂度为 O(n^2)。 
综上，因此冒泡排序总的平均时间复杂度为O(n^2)。

### 算法稳定性
- 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

### 是否是原地算法

- 何为原地算法？
	- 不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入
	- 空间复杂度为 𝑂(1) 的都可以认为是原地算法
- 非原地算法，称为 Not-in-place 或者 Out-of-place
- 冒泡排序属于 In-place

## 代码
### 代码一

~~~~
public class BubbleSort<T extends Comparable<T>> extends Sort<T>  {

	@Override
	protected void sort() {
		for (int end = array.length-1; end>0; end--) {
			for (int begin = 1; begin <= end; begin++) {
				if (cmp(begin, begin-1)<0) {
				//ayyay[begin] 小于 ayyay[begin-1] 就交换
					swap(begin, begin-1);
				}
			}
		}
	}
}

~~~~

### 优化

- 我们知道，每次都是两两比较，如果已经拍好顺序了。可以提前终止排序

~~~~
public class BubbleSort1<T extends Comparable<T>> extends Sort<T>  {

	@Override
	protected void sort() {
		// TODO Auto-generated method stub
		for (int end = array.length-1; end >0; end--) {
			boolean isSorted = true; //定义布尔值 isSorted来标记是否有交换
			for (int begin = 1; begin <= end; begin++) {
				//ayyay[begin] 小于 ayyay[begin-1] 就交换
				if (cmp(begin, begin-1)<0) {
					swap(begin, begin-1);
					isSorted = false;
				}
			}
			if (isSorted) {
				//来到这里，说明没有交换过。已经是完全有序的了。提前终止排序
				break;
			}
			
		}
	}

}

~~~~

### 再次优化

- 如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数

~~~~
public class BubbleSort2<T extends Comparable<T>> extends Sort<T>   {

	@Override
	protected void sort() {
		// TODO Auto-generated method stub
		for (int end = array.length-1; end >0; end--) {
			int sortedIndex = 1;
			for (int begin = 1; begin <= end; begin++) {
				if (cmp(begin, begin-1)<0) {
					swap(begin, begin-1);
					sortedIndex = begin;
				}
			}
			end = sortedIndex;
			
		}
	}

}

~~~~

### 验证

使用数据源如下
>Integer[] array = {7, 3, 5, 8, 6, 7, 4, 5,19,30,40,50};

结果为：

- 【BubbleSort】 稳定性：true 	耗时：0.0s(0ms) 比较次数：66	 交换次数：14


- 【BubbleSort1】稳定性：true 	耗时：0.001s(1ms) 	比较次数：51	 交换次数：14	


- 【BubbleSort2】稳定性：true 	耗时：0.0s(0ms) 	比较次数：30	 交换次数：14


可以明显感觉到做了优化之后，比较测试减少了。

## 代码地址：

- 文中的代码在git上：[github地址](https://github.com/ITyongzhen/DataStructureAndAlgorithm)
