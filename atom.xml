<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>殷永振</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ityongzhen.github.io/"/>
  <updated>2020-02-29T03:43:59.573Z</updated>
  <id>https://ityongzhen.github.io/</id>
  
  <author>
    <name>ityongzhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter学习之Dart语法(一)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80)/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80)/</id>
    <published>2020-02-10T00:32:24.000Z</published>
    <updated>2020-02-29T03:43:59.573Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(一).html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准 。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</li><li>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system</li></ul><p><strong>Google为Flutter选择了Dart作为开发语言</strong></p><p>关于Dart的环境安装和配置这里就不赘述了。</p><h2 id="新建程序"><a href="#新建程序" class="headerlink" title="新建程序"></a>新建程序</h2><p>用VSCode新建一个Dart文件，默认是如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(&#39;Hello World&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这也和Java,C等等其他语言一样，main函数作为入口。</p><ul><li>Dart语言的入口也是main函数，并且必须显示的进行定义；</li><li>Dart的入口函数main是没有返回值的；</li><li>传递给main的命令行参数，是通过List<String>完成的。<ul><li>从字面值就可以理解List是Dart中的集合类型。</li><li>其中的每一个String都表示传递给main的一个参数；</li></ul></li><li>定义字符串的时候，可以使用单引号或双引号；</li><li>每行语句必须使用分号结尾，很多语言并不需要分号，比如Swift、JavaScript；</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="明确声明-Explicit"><a href="#明确声明-Explicit" class="headerlink" title="明确声明(Explicit)"></a>明确声明(Explicit)</h3><p>明确声明变量的方式, 格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量类型 变量名称 &#x3D; 赋值;</span><br></pre></td></tr></table></figure><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; &#39;eagle&#39;;</span><br><span class="line">int age &#x3D; 20;</span><br><span class="line">print(&#39;$&#123;name&#125;, $&#123;age&#125;&#39;);</span><br></pre></td></tr></table></figure><p>注意: 定义的变量可以修改值, 但是不能赋值其他类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String content &#x3D; &#39;Hello World&#39;;</span><br><span class="line">content &#x3D; &#39;Hello China&#39;; &#x2F;&#x2F; 正确的</span><br><span class="line">content &#x3D; 111; &#x2F;&#x2F; 错误的, 将一个int值赋值给一个String变量</span><br></pre></td></tr></table></figure><h3 id="类型推导-Type-Inference"><a href="#类型推导-Type-Inference" class="headerlink" title="类型推导(Type Inference)"></a>类型推导(Type Inference)</h3><p>和swift等语言类似，Dart也是支持类型推导的，类型推导声明变量的方式, 格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var&#x2F;dynamic&#x2F;const&#x2F;final 变量名称 &#x3D; 赋值;</span><br></pre></td></tr></table></figure><h4 id="var的使用"><a href="#var的使用" class="headerlink" title="var的使用"></a>var的使用</h4><p>var的使用示例:</p><ul><li>runtimeType用于获取变量当前的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;eagle&#39;;</span><br><span class="line">name &#x3D; &#39;ITYongzhen&#39;;</span><br><span class="line">print(name.runtimeType); &#x2F;&#x2F; String</span><br></pre></td></tr></table></figure><p>var的错误用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var age &#x3D; 18;</span><br><span class="line">age &#x3D; &#39;eagle&#39;; &#x2F;&#x2F; 不可以将String赋值给一个int类型</span><br></pre></td></tr></table></figure><h4 id="dynamic的使用"><a href="#dynamic的使用" class="headerlink" title="dynamic的使用"></a>dynamic的使用</h4><p>如果确实希望这样做,可以使用dynamic来声明变量:</p><ul><li>但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dynamic name &#x3D; &#39;eagle&#39;;</span><br><span class="line">print(name.runtimeType); &#x2F;&#x2F; String</span><br><span class="line">name &#x3D; 18;</span><br><span class="line">print(name.runtimeType); &#x2F;&#x2F; int</span><br></pre></td></tr></table></figure><h4 id="final-amp-const的使用"><a href="#final-amp-const的使用" class="headerlink" title="final&amp;const的使用"></a>final&amp;const的使用</h4><p>final和const都是用于定义常量的, 也就是定义之后值都不可以修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final name &#x3D; &#39;eagle&#39;;</span><br><span class="line">name &#x3D; &#39;ITyongzhen&#39;; &#x2F;&#x2F; 错误做法</span><br><span class="line"></span><br><span class="line">const age &#x3D; 18;</span><br><span class="line">age &#x3D; 20; &#x2F;&#x2F; 错误做法</span><br></pre></td></tr></table></figure><h4 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h4><p>const在赋值时, 赋值的内容必须是在编译期间就确定下来的<br>final在赋值时, 可以动态获取, 比如赋值一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String getName() &#123;</span><br><span class="line">  return &#39;eagle&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  const name &#x3D; getName(); &#x2F;&#x2F; 错误的做法, 因为要执行函数才能获取到值</span><br><span class="line">  final name &#x3D; getName(); &#x2F;&#x2F; 正确的做法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final和const小案例:</p><ul><li>首先, const是不可以赋值为DateTime.now()</li><li>其次, final一旦被赋值后就有确定的结果, 不会再次赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; const time &#x3D; DateTime.now(); &#x2F;&#x2F; 错误的赋值方式</span><br><span class="line">final time &#x3D; DateTime.now();</span><br><span class="line">print(time); &#x2F;&#x2F; 2020-02-05 12:04:50.052626</span><br><span class="line"></span><br><span class="line">sleep(Duration(seconds: 2));</span><br><span class="line">print(time); &#x2F;&#x2F; 2020-02-05 12:04:50.052626</span><br></pre></td></tr></table></figure><p>const放在赋值语句的右边，可以共享对象，提高性能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  const Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final a &#x3D; const Person();</span><br><span class="line">  final b &#x3D; const Person();</span><br><span class="line">  print(identical(a, b)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">  final m &#x3D; Person();</span><br><span class="line">  final n &#x3D; Person();</span><br><span class="line">  print(identical(m, n)); &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><h4 id="int和double"><a href="#int和double" class="headerlink" title="int和double"></a><code>int</code>和<code>double</code></h4><p>对于数值来说，我们也不用关心它是否有符号，以及数据的宽度和精度等问题。只要记着整数用<code>int</code>，浮点数用<code>double</code>就行了。<br>不过，要注意的是<code>Dart</code>中的<code>int</code>和<code>double</code>可表示的范围并不是固定的，它取决于运行Dart的平台。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.整数类型int</span><br><span class="line">int age &#x3D; 18;</span><br><span class="line">int hexAge &#x3D; 0x12;</span><br><span class="line">print(age);</span><br><span class="line">print(hexAge);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.浮点类型double</span><br><span class="line">double height &#x3D; 1.88;</span><br><span class="line">print(height);</span><br></pre></td></tr></table></figure><h4 id="字符串和数字之间的转化"><a href="#字符串和数字之间的转化" class="headerlink" title="字符串和数字之间的转化"></a>字符串和数字之间的转化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串和数字转化</span><br><span class="line">&#x2F;&#x2F; 1.字符串转数字</span><br><span class="line">var one &#x3D; int.parse(&#39;111&#39;);</span><br><span class="line">var two &#x3D; double.parse(&#39;12.22&#39;);</span><br><span class="line">print(&#39;$&#123;one&#125; $&#123;one.runtimeType&#125;&#39;); &#x2F;&#x2F; 111 int</span><br><span class="line">print(&#39;$&#123;two&#125; $&#123;two.runtimeType&#125;&#39;); &#x2F;&#x2F; 12.22 double</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.数字转字符串</span><br><span class="line">var num1 &#x3D; 123;</span><br><span class="line">var num2 &#x3D; 123.456;</span><br><span class="line">var num1Str &#x3D; num1.toString();</span><br><span class="line">var num2Str &#x3D; num2.toString();</span><br><span class="line">var num2StrD &#x3D; num2.toStringAsFixed(2); &#x2F;&#x2F; 保留两位小数</span><br><span class="line">print(&#39;$&#123;num1Str&#125; $&#123;num1Str.runtimeType&#125;&#39;); &#x2F;&#x2F; 123 String</span><br><span class="line">print(&#39;$&#123;num2Str&#125; $&#123;num2Str.runtimeType&#125;&#39;); &#x2F;&#x2F; 123.456 String</span><br><span class="line">print(&#39;$&#123;num2StrD&#125; $&#123;num2StrD.runtimeType&#125;&#39;); &#x2F;&#x2F; 123.46 String</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型中,Dart提供了一个bool的类型, 取值为true和false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 布尔类型</span><br><span class="line">var isFlag &#x3D; true;</span><br><span class="line">print(&#39;$isFlag $&#123;isFlag.runtimeType&#125;&#39;);</span><br></pre></td></tr></table></figure><p><strong>注意: Dart中不能判断非0即真, 或者非空即真</strong></p><p>Dart的类型安全性意味着您不能使用if(非booleanvalue)或assert(非booleanvalue)之类的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var message &#x3D; &#39;Hello Dart&#39;;</span><br><span class="line">&#x2F;&#x2F; 错误的写法</span><br><span class="line">if (message) &#123;</span><br><span class="line">  print(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>Dart字符串是UTF-16编码单元的序列。您可以使用单引号或双引号创建一个字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义字符串的方式</span><br><span class="line">var s1 &#x3D; &#39;Hello World&#39;;</span><br><span class="line">var s2 &#x3D; &quot;Hello Dart&quot;;</span><br><span class="line">var s3 &#x3D; &#39;Hello\&#39;Fullter&#39;;</span><br><span class="line">var s4 &#x3D; &quot;Hello&#39;Fullter&quot;;</span><br></pre></td></tr></table></figure><p>可以使用三个单引号或者双引号表示多行字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2.表示多行字符串的方式</span><br><span class="line">var message1 &#x3D; &#39;&#39;&#39;</span><br><span class="line">哈哈哈</span><br><span class="line">呵呵呵</span><br><span class="line">嘿嘿嘿&#39;&#39;&#39;;</span><br></pre></td></tr></table></figure><p>字符串和其他变量或表达式拼接: 使用<code>${expression}</code>, 如果表达式是一个标识符, 那么<code>{}</code>可以省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3.拼接其他变量</span><br><span class="line">var name &#x3D; &#39;eagle&#39;;</span><br><span class="line">var age &#x3D; 18;</span><br><span class="line">var height &#x3D; 1.88;</span><br><span class="line">print(&#39;my name is $&#123;name&#125;, age is $age, height is $height&#39;);</span><br></pre></td></tr></table></figure><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><ul><li>集合类型的定义</li></ul><p>对于集合类型，Dart则内置了最常用的三种：<code>List / Set / Map</code>。<br>其中，<code>List</code>可以这样来定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; List定义</span><br><span class="line">&#x2F;&#x2F; 1.使用类型推导定义</span><br><span class="line">var letters &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];</span><br><span class="line">print(&#39;$letters $&#123;letters.runtimeType&#125;&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.明确指定类型</span><br><span class="line">List&lt;int&gt; numbers &#x3D; [1, 2, 3, 4];</span><br><span class="line">print(&#39;$numbers $&#123;numbers.runtimeType&#125;&#39;);</span><br></pre></td></tr></table></figure><p>其中，<code>set</code>可以这样来定义：</p><p>其实，也就是把[]换成{}就好了。<br>Set和List最大的两个不同就是：Set是无序的，并且元素是不重复的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Set的定义</span><br><span class="line">&#x2F;&#x2F; 1.使用类型推导定义</span><br><span class="line">var lettersSet &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;;</span><br><span class="line">print(&#39;$lettersSet $&#123;lettersSet.runtimeType&#125;&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.明确指定类型</span><br><span class="line">Set&lt;int&gt; numbersSet &#x3D; &#123;1, 2, 3, 4&#125;;</span><br><span class="line">print(&#39;$numbersSet $&#123;numbersSet.runtimeType&#125;&#39;);</span><br></pre></td></tr></table></figure><p>最后，Map是我们常说的字典类型，它的定义是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map的定义</span><br><span class="line">&#x2F;&#x2F; 1.使用类型推导定义</span><br><span class="line">var infoMap1 &#x3D; &#123;&#39;name&#39;: &#39;eagle&#39;, &#39;age&#39;: 18&#125;;</span><br><span class="line">print(&#39;$infoMap1 $&#123;infoMap1.runtimeType&#125;&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.明确指定类型</span><br><span class="line">Map&lt;String, Object&gt; infoMap2 &#x3D; &#123;&#39;height&#39;: 1.88, &#39;address&#39;: &#39;北京市&#39;&#125;;</span><br><span class="line">print(&#39;$infoMap2 $&#123;infoMap2.runtimeType&#125;&#39;);</span><br></pre></td></tr></table></figure><h4 id="集合的常见操作"><a href="#集合的常见操作" class="headerlink" title="集合的常见操作"></a>集合的常见操作</h4><p>了解了这三个集合的定义方式之后，我们来看一些最基础的公共操作</p><p>第一类，是所有集合都支持的获取长度的属性length：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取集合的长度</span><br><span class="line">print(letters.length);</span><br><span class="line">print(lettersSet.length);</span><br><span class="line">print(infoMap1.length);</span><br></pre></td></tr></table></figure><p>第二类, 是添加/删除/包含操作</p><p>并且，对List来说，由于元素是有序的，它还提供了一个删除指定索引位置上元素的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加&#x2F;删除&#x2F;包含元素</span><br><span class="line">numbers.add(5);</span><br><span class="line">numbersSet.add(5);</span><br><span class="line">print(&#39;$numbers $numbersSet&#39;);</span><br><span class="line"></span><br><span class="line">numbers.remove(1);</span><br><span class="line">numbersSet.remove(1);</span><br><span class="line">print(&#39;$numbers $numbersSet&#39;);</span><br><span class="line"></span><br><span class="line">print(numbers.contains(2));</span><br><span class="line">print(numbersSet.contains(2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; List根据index删除元素</span><br><span class="line">numbers.removeAt(3);</span><br><span class="line">print(&#39;$numbers&#39;);</span><br></pre></td></tr></table></figure><p>第三类，是Map的操作</p><p>由于它有key和value，因此无论是读取值，还是操作，都要明确是基于key的，还是基于value的，或者是基于key/value对的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Map的操作</span><br><span class="line">&#x2F;&#x2F; 1.根据key获取value</span><br><span class="line">print(infoMap1[&#39;name&#39;]); &#x2F;&#x2F; eagle</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.获取所有的entries</span><br><span class="line">print(&#39;$&#123;infoMap1.entries&#125; $&#123;infoMap1.entries.runtimeType&#125;&#39;); &#x2F;&#x2F; (MapEntry(name: eagle), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.获取所有的keys</span><br><span class="line">print(&#39;$&#123;infoMap1.keys&#125; $&#123;infoMap1.keys.runtimeType&#125;&#39;); &#x2F;&#x2F; (name, age) _CompactIterable&lt;String&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.获取所有的values</span><br><span class="line">print(&#39;$&#123;infoMap1.values&#125; $&#123;infoMap1.values.runtimeType&#125;&#39;); &#x2F;&#x2F; (eagle, 18) _CompactIterable&lt;Object&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5.判断是否包含某个key或者value</span><br><span class="line">print(&#39;$&#123;infoMap1.containsKey(&#39;age&#39;)&#125; $&#123;infoMap1.containsValue(18)&#125;&#39;); &#x2F;&#x2F; true true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6.根据key删除元素</span><br><span class="line">infoMap1.remove(&#39;age&#39;);</span><br><span class="line">print(&#39;$&#123;infoMap1&#125;&#39;); &#x2F;&#x2F; &#123;name: eagle&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(一).html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习之Dart语法(一)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80)~/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80)~/</id>
    <published>2020-02-10T00:32:24.000Z</published>
    <updated>2020-02-29T03:17:15.783Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(一).html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准 。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</li><li>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system</li></ul><p><strong>Google为Flutter选择了Dart作为开发语言</strong></p><p>关于Dart的环境安装和配置这里就不赘述了。</p><h2 id="新建程序"><a href="#新建程序" class="headerlink" title="新建程序"></a>新建程序</h2><p>用VSCode新建一个Dart文件，默认是如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(&#39;Hello World&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这也和Java,C等等其他语言一样，main函数作为入口。</p><ul><li>Dart语言的入口也是main函数，并且必须显示的进行定义；</li><li>Dart的入口函数main是没有返回值的；</li><li>传递给main的命令行参数，是通过List<String>完成的。<ul><li>从字面值就可以理解List是Dart中的集合类型。</li><li>其中的每一个String都表示传递给main的一个参数；</li></ul></li><li>定义字符串的时候，可以使用单引号或双引号；</li><li>每行语句必须使用分号结尾，很多语言并不需要分号，比如Swift、JavaScript；</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="明确声明-Explicit"><a href="#明确声明-Explicit" class="headerlink" title="明确声明(Explicit)"></a>明确声明(Explicit)</h3><p>明确声明变量的方式, 格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量类型 变量名称 &#x3D; 赋值;</span><br></pre></td></tr></table></figure><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; &#39;eagle&#39;;</span><br><span class="line">int age &#x3D; 20;</span><br><span class="line">print(&#39;$&#123;name&#125;, $&#123;age&#125;&#39;);</span><br></pre></td></tr></table></figure><p>注意: 定义的变量可以修改值, 但是不能赋值其他类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String content &#x3D; &#39;Hello World&#39;;</span><br><span class="line">content &#x3D; &#39;Hello China&#39;; &#x2F;&#x2F; 正确的</span><br><span class="line">content &#x3D; 111; &#x2F;&#x2F; 错误的, 将一个int值赋值给一个String变量</span><br></pre></td></tr></table></figure><h3 id="类型推导-Type-Inference"><a href="#类型推导-Type-Inference" class="headerlink" title="类型推导(Type Inference)"></a>类型推导(Type Inference)</h3><p>和swift等语言类似，Dart也是支持类型推导的，类型推导声明变量的方式, 格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var&#x2F;dynamic&#x2F;const&#x2F;final 变量名称 &#x3D; 赋值;</span><br></pre></td></tr></table></figure><h4 id="var的使用"><a href="#var的使用" class="headerlink" title="var的使用"></a>var的使用</h4><p>var的使用示例:</p><ul><li>runtimeType用于获取变量当前的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;eagle&#39;;</span><br><span class="line">name &#x3D; &#39;ITYongzhen&#39;;</span><br><span class="line">print(name.runtimeType); &#x2F;&#x2F; String</span><br></pre></td></tr></table></figure><p>var的错误用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var age &#x3D; 18;</span><br><span class="line">age &#x3D; &#39;eagle&#39;; &#x2F;&#x2F; 不可以将String赋值给一个int类型</span><br></pre></td></tr></table></figure><h4 id="dynamic的使用"><a href="#dynamic的使用" class="headerlink" title="dynamic的使用"></a>dynamic的使用</h4><p>如果确实希望这样做,可以使用dynamic来声明变量:</p><ul><li>但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dynamic name &#x3D; &#39;eagle&#39;;</span><br><span class="line">print(name.runtimeType); &#x2F;&#x2F; String</span><br><span class="line">name &#x3D; 18;</span><br><span class="line">print(name.runtimeType); &#x2F;&#x2F; int</span><br></pre></td></tr></table></figure><h4 id="final-amp-const的使用"><a href="#final-amp-const的使用" class="headerlink" title="final&amp;const的使用"></a>final&amp;const的使用</h4><p>final和const都是用于定义常量的, 也就是定义之后值都不可以修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final name &#x3D; &#39;eagle&#39;;</span><br><span class="line">name &#x3D; &#39;ITyongzhen&#39;; &#x2F;&#x2F; 错误做法</span><br><span class="line"></span><br><span class="line">const age &#x3D; 18;</span><br><span class="line">age &#x3D; 20; &#x2F;&#x2F; 错误做法</span><br></pre></td></tr></table></figure><h5 id="final和const有什么区别呢"><a href="#final和const有什么区别呢" class="headerlink" title="final和const有什么区别呢?"></a>final和const有什么区别呢?</h5><p>const在赋值时, 赋值的内容必须是在编译期间就确定下来的<br>final在赋值时, 可以动态获取, 比如赋值一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String getName() &#123;</span><br><span class="line">  return &#39;eagle&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  const name &#x3D; getName(); &#x2F;&#x2F; 错误的做法, 因为要执行函数才能获取到值</span><br><span class="line">  final name &#x3D; getName(); &#x2F;&#x2F; 正确的做法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final和const小案例:</p><ul><li>首先, const是不可以赋值为DateTime.now()</li><li>其次, final一旦被赋值后就有确定的结果, 不会再次赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; const time &#x3D; DateTime.now(); &#x2F;&#x2F; 错误的赋值方式</span><br><span class="line">final time &#x3D; DateTime.now();</span><br><span class="line">print(time); &#x2F;&#x2F; 2020-02-05 12:04:50.052626</span><br><span class="line"></span><br><span class="line">sleep(Duration(seconds: 2));</span><br><span class="line">print(time); &#x2F;&#x2F; 2020-02-05 12:04:50.052626</span><br></pre></td></tr></table></figure><p>const放在赋值语句的右边，可以共享对象，提高性能:</p><p>class Person {<br>  const Person();<br>}</p><p>main(List<String> args) {<br>  final a = const Person();<br>  final b = const Person();<br>  print(identical(a, b)); // true</p><p>  final m = Person();<br>  final n = Person();<br>  print(identical(m, n)); // false<br>}</p><p>参考资料:<br><a href="https://juejin.im/post/5d76340c6fb9a06adb800961" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(一).html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Swift之下标</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87/</id>
    <published>2019-10-30T00:32:24.000Z</published>
    <updated>2019-12-12T06:40:29.375Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift中对枚举、结构体、类使用下标(subscript），就可以像使用数组一样来使用了</p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ul><li>使用subscript可以给任意类型（枚举、结构体、类）增加下标功能，有些地方也翻译为：下标脚本</li><li>subscript的语法类似于实例方法、计算属性，本质就是方法（函数）</li></ul><p>例如下面的代码中，类<code>Point</code>中，的属性 x 和 y,可以用下标访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">                x &#x3D; newValue</span><br><span class="line">            &#125; else if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">                y &#x3D; newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">                return x</span><br><span class="line">            &#125; else if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">                return y</span><br><span class="line">            &#125;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; Point()</span><br><span class="line">p[0] &#x3D; 11.1</span><br><span class="line">p[1] &#x3D; 22.2</span><br><span class="line">print(p.x) &#x2F;&#x2F; 11.1</span><br><span class="line">print(p.y) &#x2F;&#x2F; 22.2</span><br><span class="line">print(p[0]) &#x2F;&#x2F; 11.1</span><br><span class="line">print(p[1]) &#x2F;&#x2F; 22.2</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>subscript中定义的返回值类型决定了<ul><li>get方法的返回值类型</li><li>set方法中newValue的类型</li></ul></li><li>subscript可以接受多个参数，并且类型任意</li></ul><h3 id="subscript可以没有set方法"><a href="#subscript可以没有set方法" class="headerlink" title="subscript可以没有set方法"></a>subscript可以没有set方法</h3><p>例如下面的代码中，只提供了get，没有set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">                return x</span><br><span class="line">            &#125; else if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">                return y</span><br><span class="line">            &#125;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有get方法，可以省略get</li></ul><p>上面的代码可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">            return x</span><br><span class="line">        &#125; else if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return y</span><br><span class="line">        &#125;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可以设置参数标签"><a href="#可以设置参数标签" class="headerlink" title="可以设置参数标签"></a>可以设置参数标签</h3><p>例如下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    subscript(index i: Int) -&gt; Double &#123;</span><br><span class="line">        if i &#x3D;&#x3D; 0 &#123;</span><br><span class="line">            return x</span><br><span class="line">        &#125; else if i &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return y</span><br><span class="line">        &#125;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; Point()</span><br><span class="line">p.y &#x3D; 22.2</span><br><span class="line">print(p[index: 1]) &#x2F;&#x2F; 22.2</span><br></pre></td></tr></table></figure><h3 id="下标可以是类型方法"><a href="#下标可以是类型方法" class="headerlink" title="下标可以是类型方法"></a>下标可以是类型方法</h3><p>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Sum &#123;</span><br><span class="line">    static subscript(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">        return v1 + v2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(Sum[10, 20]) &#x2F;&#x2F; 30</span><br></pre></td></tr></table></figure><h2 id="结构体、类作为返回值对比"><a href="#结构体、类作为返回值对比" class="headerlink" title="结构体、类作为返回值对比"></a>结构体、类作为返回值对比</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>eg,如下代码,结构体Point，用了下标<code>subscript</code>只有get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0, y &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PointManager &#123;</span><br><span class="line">    var point &#x3D; Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">        get &#123; point &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var pm &#x3D; PointManager()</span><br><span class="line">pm[0].x &#x3D; 11 &#x2F;&#x2F;Cannot assign to property: subscript is get-only</span><br><span class="line">&#x2F;&#x2F; 等价于 pm[0] &#x3D; Point(x: 11, y: pm[0].y)</span><br><span class="line">pm[0].y &#x3D; 22&#x2F;&#x2F;Cannot assign to property: subscript is get-only</span><br></pre></td></tr></table></figure><h3 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h3><ul><li>加上set方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0, y &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PointManager &#123;</span><br><span class="line">    var point &#x3D; Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">       set &#123; point &#x3D; newValue &#125;</span><br><span class="line">        get &#123; point &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面使用正常</span><br><span class="line">var pm &#x3D; PointManager()</span><br><span class="line">pm[0].x &#x3D; 11</span><br><span class="line">&#x2F;&#x2F; 等价于 pm[0] &#x3D; Point(x: 11, y: pm[0].y)</span><br><span class="line">pm[0].y &#x3D; 22</span><br></pre></td></tr></table></figure><h3 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h3><p>结构体改成类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x &#x3D; 0, y &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PointManager &#123;</span><br><span class="line">    var point &#x3D; Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">        get &#123; point &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面使用正常</span><br><span class="line">var pm &#x3D; PointManager()</span><br><span class="line">pm[0].x &#x3D; 11</span><br><span class="line">&#x2F;&#x2F; 等价于 pm[0] &#x3D; Point(x: 11, y: pm[0].y)</span><br><span class="line">pm[0].y &#x3D; 22</span><br></pre></td></tr></table></figure><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>类是引用类型的，传递的是地址<br>结构体是值类型，传递的是具体的值</p><h2 id="接受多个参数的下标"><a href="#接受多个参数的下标" class="headerlink" title="接受多个参数的下标"></a>接受多个参数的下标</h2><p>eg,如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Grid &#123;</span><br><span class="line">    var data &#x3D; [</span><br><span class="line">        [0, 1, 2],</span><br><span class="line">        [3, 4, 5],</span><br><span class="line">        [6, 7, 8]</span><br><span class="line">    ]</span><br><span class="line">    subscript(row: Int, column: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            guard row &gt;&#x3D; 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;&#x3D; 0 &amp;&amp; column &lt; 3 else &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            data[row][column] &#x3D; newValue</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            guard row &gt;&#x3D; 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;&#x3D; 0 &amp;&amp; column &lt; 3 else &#123;</span><br><span class="line">                return 0</span><br><span class="line">            &#125;</span><br><span class="line">            return data[row][column]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var grid &#x3D; Grid()</span><br><span class="line">grid[0, 1] &#x3D; 77</span><br><span class="line">grid[1, 2] &#x3D; 88</span><br><span class="line">grid[2, 0] &#x3D; 99</span><br><span class="line">print(grid.data)</span><br></pre></td></tr></table></figure><p>输出为</p><blockquote><p>[[0, 77, 2], [3, 4, 88], [99, 7, 8]]</p></blockquote><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之协议</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE/</id>
    <published>2019-10-16T00:32:24.000Z</published>
    <updated>2019-12-12T06:37:26.102Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>协议，有关开发经验的应该都不陌生，很多语言中都有协议，但是相对来说，Swift中的协议更加强大，灵活。</p><ul><li>Swift中协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;协议</span><br><span class="line">protocol Drawable &#123;</span><br><span class="line">    &#x2F;&#x2F;方法</span><br><span class="line">    func draw()</span><br><span class="line">    &#x2F;&#x2F;可读可写属性</span><br><span class="line">    var x: Int &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;只读属性</span><br><span class="line">    var y: Int &#123; get &#125;</span><br><span class="line">    &#x2F;&#x2F; 下标</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类<code>TestClass</code>准守多个协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol Test1 &#123; &#125;</span><br><span class="line">protocol Test2 &#123; &#125;</span><br><span class="line">protocol Test3 &#123; &#125;</span><br><span class="line">class TestClass : Test1, Test2, Test3 &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h3><ul><li>协议中定义方法时不能有默认参数值</li><li>默认情况下，协议中定义的内容必须全部都实现</li><li>也有办法办到只实现部分内容，后面会说</li></ul><h2 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h2><ul><li>协议中定义属性时必须用var关键字</li><li>实现协议时的属性权限要不小于协议中定义的属性权限</li><li>协议定义get、set，用var存储属性或get、set计算属性去实现</li><li>协议定义get，用任何属性都可以实现</li></ul><p>eg：有协议<code>Drawable</code>,里面有方法<code>draw</code>，以及可读可写属性<code>x</code>，只读属性<code>y</code>，下标。其中属性必须用<code>var</code>关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;协议</span><br><span class="line">protocol Drawable &#123;</span><br><span class="line">    func draw() &#x2F;&#x2F;方法</span><br><span class="line">    var x: Int &#123; get set &#125; &#x2F;&#x2F;可读可写 属性用var</span><br><span class="line">    var y: Int &#123; get &#125; &#x2F;&#x2F;只读  属性用var</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123; get set &#125; &#x2F;&#x2F;下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现的时候，有如下的方式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person : Drawable &#123;</span><br><span class="line">    var x: Int &#x3D; 0 &#x2F;&#x2F;用var的存储属性</span><br><span class="line">    let y: Int &#x3D; 0 &#x2F;&#x2F;let实现只读属性</span><br><span class="line">    func draw() &#123;</span><br><span class="line">        print(&quot;Person draw&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123; &#125;</span><br><span class="line">        get &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了。也可以写成如下这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person : Drawable &#123;</span><br><span class="line">    var x: Int &#123; &#x2F;&#x2F;用计算属性</span><br><span class="line">        get &#123; 0 &#125;</span><br><span class="line">        set &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var y: Int &#123; 0 &#125; &#x2F;&#x2F;var实现只读属性</span><br><span class="line">    func draw() &#123; print(&quot;Person draw&quot;) &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123; &#125;</span><br><span class="line">        get &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static、class"><a href="#static、class" class="headerlink" title="static、class"></a>static、class</h2><ul><li>为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标<ul><li>因为class只能用在类中，不能用于结构体等。所以为了通用，用static</li><li>但是实现的时候，可以用class，也可以用static，具体看自己的情况<br>eg:</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">&#x2F;&#x2F;这里必须用static</span><br><span class="line">    static func draw()</span><br><span class="line">&#125;</span><br><span class="line">class Person1 : Drawable &#123;</span><br><span class="line">&#x2F;&#x2F;这里可以用class</span><br><span class="line">    class func draw() &#123;</span><br><span class="line">        print(&quot;Person1 draw&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person2 : Drawable &#123;</span><br><span class="line">&#x2F;&#x2F;这里也可以用static</span><br><span class="line">    static func draw() &#123;</span><br><span class="line">        print(&quot;Person2 draw&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h2><p>关于<code>mutating</code>可以参考<a href="https://juejin.im/post/5d2ba7265188252d1d5f9218" target="_blank" rel="noopener">Swift之方法</a></p><ul><li>只有将协议中的实例方法标记为mutating<ul><li>才允许结构体、枚举的具体实现修改自身内存</li><li>类在实现方法时不用加mutating，枚举、结构体才需要加mutating</li></ul></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    mutating func draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Size : Drawable &#123;</span><br><span class="line">    var width: Int &#x3D; 0</span><br><span class="line">    func draw() &#123;</span><br><span class="line">        width &#x3D; 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point : Drawable &#123;</span><br><span class="line">    var x: Int &#x3D; 0</span><br><span class="line">    mutating func draw() &#123;</span><br><span class="line">        x &#x3D; 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><ul><li>协议中还可以定义初始化器init<ul><li>非final类实现时必须加上required</li></ul></li></ul><p>可以这么理解，如果定义的类，有子类，那么子类必须准守初始化器init，所以加上关键字<code>required</code>,但是，如果一个被<code>final</code>修饰的类。就不用加上<code>required</code>.因为被<code>final</code>修饰的类不能被其他类继承。</p><p>关于<code>final</code>可参考<a href="https://juejin.im/post/5d2d9ebbe51d4510634318bf" target="_blank" rel="noopener">Swift之继承</a></p><p>eg: 有协议<code>Drawable</code>,里面定义了初始化器<code>init</code>，类Point遵守这个协议，所以在init 前面加了关键字 <code>required</code>,这样，继承类Point的子类都要实现这个方法，但是类Size没子类。因为加了关键字<code>final</code>，这个类不能被继承。所以<code>init</code>前面不用加<code>required</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    init(x: Int, y: Int)</span><br><span class="line">&#125;</span><br><span class="line">class Point : Drawable &#123;</span><br><span class="line">    required init(x: Int, y: Int) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class Size : Drawable &#123;</span><br><span class="line">    init(x: Int, y: Int) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果从协议实现的初始化器，刚好是重写了父类的指定初始化器<ul><li>那么这个初始化必须同时加required、override</li></ul></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable &#123;</span><br><span class="line">    init(age: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    init(age: Int) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student : Person, Livable &#123;</span><br><span class="line">    required override init(age: Int) &#123;</span><br><span class="line">        super.init(age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init、init-、init"><a href="#init、init-、init" class="headerlink" title="init、init?、init!"></a>init、init?、init!</h2><ul><li>协议中定义的init?、init!，可以用init、init?、init!去实现</li><li>协议中定义的init，可以用init、init!去实现</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;协议</span><br><span class="line">protocol Livable &#123;</span><br><span class="line">    init()</span><br><span class="line">    init?(age: Int)</span><br><span class="line">    init!(no: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类</span><br><span class="line">class Person : Livable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面两种都可以实现init()</span><br><span class="line">    required init() &#123; &#125;</span><br><span class="line">    &#x2F;&#x2F; required init!() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;下面3种都可以实现init?(age: Int)</span><br><span class="line">    required init?(age: Int) &#123; &#125;</span><br><span class="line">    &#x2F;&#x2F; required init!(age: Int) &#123; &#125;</span><br><span class="line">    &#x2F;&#x2F; required init(age: Int) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;下面3种都可以实现 init!(no: Int)</span><br><span class="line">    required init!(no: Int) &#123; &#125;</span><br><span class="line">    &#x2F;&#x2F; required init?(no: Int) &#123; &#125;</span><br><span class="line">    &#x2F;&#x2F; required init(no: Int) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h2><ul><li>一个协议可以继承其他协议</li></ul><p>eg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 协议Runnable</span><br><span class="line">protocol Runnable &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 协议Livable 继承协议 Runnable</span><br><span class="line">protocol Livable : Runnable &#123;</span><br><span class="line">    func breath()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person : Livable &#123;</span><br><span class="line">    func breath() &#123; &#125;</span><br><span class="line">    func run() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h2><ul><li>协议组合，多个协议组合在一起，而且可以包含1个类类型（最多1个）</li></ul><p>eg: 两个协议<code>Livable</code>和<code>Runnable</code>,类<code>Person</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable &#123; &#125; n</span><br><span class="line">protocol Runnable &#123; &#125;</span><br><span class="line">class Person &#123; &#125;</span><br></pre></td></tr></table></figure><p>下面定义了fn0,接收参数必须是Person或者其子类的实例。fn1接收参数必须遵守Livable协议的实例，其他的可以自行看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 接收Person或者其子类的实例</span><br><span class="line">func fn0(obj: Person) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收遵守Livable协议的实例</span><br><span class="line">func fn1(obj: Livable) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收同时遵守Livable、Runnable协议的实例</span><br><span class="line">func fn2(obj: Livable &amp; Runnable) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span><br><span class="line">func fn3(obj: Person &amp; Livable &amp; Runnable) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typealias RealPerson &#x3D; Person &amp; Livable &amp; Runnable</span><br><span class="line">&#x2F;&#x2F; 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span><br><span class="line">func fn4(obj: RealPerson) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="CaseIterable"><a href="#CaseIterable" class="headerlink" title="CaseIterable"></a>CaseIterable</h2><ul><li>让枚举遵守CaseIterable协议，可以实现遍历枚举值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 枚举Season遵守协议CaseIterable</span><br><span class="line">enum Season : CaseIterable &#123;</span><br><span class="line">    case spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取出所有的case</span><br><span class="line">let seasons &#x3D; Season.allCases</span><br><span class="line">print(seasons.count) &#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以遍历</span><br><span class="line">for season in seasons &#123;</span><br><span class="line">    print(season)</span><br><span class="line">&#125; &#x2F;&#x2F; spring summer autumn winter</span><br></pre></td></tr></table></figure><h2 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h2><ul><li>遵守CustomStringConvertible协议，可以自定义实例的打印字符串</li></ul><p>eg: <code>Person</code>类遵守了<code>CustomStringConvertible</code>协议,可以再内部自定义打印<code>description</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person : CustomStringConvertible &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    var name: String</span><br><span class="line">    init(age: Int, name: String) &#123;</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        &quot;age&#x3D;\(age), name&#x3D;\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; Person(age: 10, name: &quot;Jack&quot;)</span><br><span class="line">print(p) &#x2F;&#x2F; age&#x3D;10, name&#x3D;Jack</span><br></pre></td></tr></table></figure><h2 id="Any、AnyObject"><a href="#Any、AnyObject" class="headerlink" title="Any、AnyObject"></a>Any、AnyObject</h2><ul><li>Swift提供了2种特殊的类型：Any、AnyObject<ul><li>Any：可以代表任意类型（枚举、结构体、类，也包括函数类型）</li><li>AnyObject：可以代表任意类类型（在协议后面写上: AnyObject代表只有类能遵守这个协议）</li></ul></li></ul><p>eg: stu属于Any类型,可以赋值为字符串或者对象等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stu: Any &#x3D; 10</span><br><span class="line">stu &#x3D; &quot;Jack&quot;</span><br><span class="line">stu &#x3D; Student()</span><br></pre></td></tr></table></figure><p>eg: 创建1个能存放任意类型的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建1个能存放任意类型的数组</span><br><span class="line">&#x2F;&#x2F; 第一种写法</span><br><span class="line">&#x2F;&#x2F; var data &#x3D; Array&lt;Any&gt;()</span><br><span class="line">&#x2F;&#x2F; 第二种写法</span><br><span class="line">var data &#x3D; [Any]()</span><br><span class="line">data.append(1)</span><br><span class="line">data.append(3.14)</span><br><span class="line">data.append(Student())</span><br><span class="line">data.append(&quot;Jack&quot;)</span><br><span class="line">data.append(&#123; 10 &#125;)</span><br></pre></td></tr></table></figure><h2 id="is、as-、as-、as"><a href="#is、as-、as-、as" class="headerlink" title="is、as?、as!、as"></a>is、as?、as!、as</h2><ul><li>is用来判断是否为某种类型，as用来做强制类型转换</li></ul><p>eg: 定义协议<code>Runnable</code>,类<code>Person</code>和类<code>Student</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123; func run() &#125;</span><br><span class="line">class Person &#123; &#125;</span><br><span class="line">class Student : Person, Runnable &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Student run&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func study() &#123;</span><br><span class="line">        print(&quot;Student study&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用is 的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stu: Any &#x3D; 10</span><br><span class="line">print(stu is Int) &#x2F;&#x2F; true</span><br><span class="line">stu &#x3D; &quot;Jack&quot;</span><br><span class="line">print(stu is String) &#x2F;&#x2F; true</span><br><span class="line">stu &#x3D; Student()</span><br><span class="line">print(stu is Person) &#x2F;&#x2F; true</span><br><span class="line">print(stu is Student) &#x2F;&#x2F; true</span><br><span class="line">print(stu is Runnable) &#x2F;&#x2F; t</span><br></pre></td></tr></table></figure><p>使用as 的时候,如果转换失败，后面都不执行。转换成功，后面才继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stu: Any &#x3D; 10</span><br><span class="line">(stu as? Student)?.study() &#x2F;&#x2F; 没有调用study</span><br><span class="line">stu &#x3D; Student()</span><br><span class="line">(stu as? Student)?.study() &#x2F;&#x2F; Student study</span><br><span class="line">(stu as! Student).study() &#x2F;&#x2F; Student study</span><br><span class="line">(stu as? Runnable)?.run() &#x2F;&#x2F; Student run</span><br></pre></td></tr></table></figure><h2 id="X-self、X-Type、AnyClass"><a href="#X-self、X-Type、AnyClass" class="headerlink" title="X.self、X.Type、AnyClass"></a>X.self、X.Type、AnyClass</h2><ul><li>X.self是一个元类型（metadata）的指针，metadata存放着类型相关信息</li><li>X.self属于X.Type类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义类Person</span><br><span class="line">class Person &#123; &#125;</span><br><span class="line">&#x2F;&#x2F; 定义类Student 继承 Person</span><br><span class="line">class Student : Person &#123; &#125;</span><br><span class="line">&#x2F;&#x2F;perType类型是 Person.Type</span><br><span class="line">var perType: Person.Type &#x3D; Person.self</span><br><span class="line">&#x2F;&#x2F;stuType类型是 Student.Type</span><br><span class="line">var stuType: Student.Type &#x3D; Student.self</span><br><span class="line">&#x2F;&#x2F; Student.self可以赋值给perType</span><br><span class="line">perType &#x3D; Student.self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; anyType可以是任何类型</span><br><span class="line">var anyType: AnyObject.Type &#x3D; Person.self</span><br><span class="line">anyType &#x3D; Student.self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public typealias AnyClass &#x3D; AnyObject.Type</span><br><span class="line">&#x2F;&#x2F;anyType2可以是任何类型</span><br><span class="line">var anyType2: AnyClass &#x3D; Person.self</span><br><span class="line">anyType2 &#x3D; Student.self</span><br></pre></td></tr></table></figure><h2 id="元类型的应用"><a href="#元类型的应用" class="headerlink" title="元类型的应用"></a>元类型的应用</h2><p>eg:<code>Cat</code>类，<code>Dog</code>类，<code>Pig</code>类，都继承自<code>Animal</code>类，我们想同时去初始化，可使用下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123; required init() &#123; &#125; &#125;</span><br><span class="line">class Cat : Animal &#123; &#125;</span><br><span class="line">class Dog : Animal &#123; &#125;</span><br><span class="line">class Pig : Animal &#123; &#125;</span><br><span class="line">func create(_ clses: [Animal.Type]) -&gt; [Animal] &#123;</span><br><span class="line">    var arr &#x3D; [Animal]()</span><br><span class="line">    for cls in clses &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据元类型初始化</span><br><span class="line">        arr.append(cls.init())</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里传入Cat,Dog,Pig进行初始化</span><br><span class="line">print(create([Cat.self, Dog.self, Pig.self]))</span><br></pre></td></tr></table></figure><p><strong>注意上面的required不能省略</strong></p><ul><li>在OC、Java等语言中，任何一个类最终都要继承自某个基类，</li><li>在Swift中没有这个规定，如果一个类不继承任何一个类，那这个类就是基类</li></ul><p>实际上，真的如此么，真的不继承任何类么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">class Student : Person &#123;</span><br><span class="line">    var no: Int &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">print(class_getInstanceSize(Student.self)) &#x2F;&#x2F; 32</span><br><span class="line">print(class_getSuperclass(Student.self)!) &#x2F;&#x2F; Person</span><br><span class="line">print(class_getSuperclass(Person.self)!) &#x2F;&#x2F; Swift._SwiftObject</span><br></pre></td></tr></table></figure><ul><li>从结果可以看得出来，Swift还有个隐藏的基类：Swift._SwiftObject</li><li>可以参考<a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObjec.h" target="_blank" rel="noopener">Swift源码</a></li></ul><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><ul><li>Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型（也可以作为参数类型）</li></ul><p>有点类似OC中的instanType的感觉。eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    func test() -&gt; Self</span><br><span class="line">&#125;</span><br><span class="line">class Person : Runnable &#123;</span><br><span class="line">    required init() &#123; &#125;</span><br><span class="line">    func test() -&gt; Self &#123; type(of: self).init() &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student : Person &#123; &#125;</span><br></pre></td></tr></table></figure><p>调用时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; Person()</span><br><span class="line">&#x2F;&#x2F; 输出Person</span><br><span class="line">print(p.test())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var stu &#x3D; Student()</span><br><span class="line">&#x2F;&#x2F; 输出Student</span><br><span class="line">print(stu.test())</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编深入分析inout本质</title>
    <link href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8/"/>
    <id>https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8/</id>
    <published>2019-09-28T00:32:24.000Z</published>
    <updated>2019-12-12T06:32:35.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于<code>输入输出参数inout</code> 在<a href="https://juejin.im/post/5d1eec54f265da1bb27750ba" target="_blank" rel="noopener">Swift之函数</a>一文中，我们已经有了初步的认识。现在我们再继续深入了解一下</p><h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><ul><li>说了形参只能是let，但是如果我们想再内部修改外部实参的值，可以用 inout 定义输入输出参数</li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func swapValues(_ v1: inout Int, _ v2: inout Int) &#123;</span><br><span class="line">     let tmp &#x3D; v1</span><br><span class="line">     v1 &#x3D; v2</span><br><span class="line">     v2 &#x3D; tmp</span><br><span class="line">     &#x2F;&#x2F;前面三行也可以换成  (v1, v2) &#x3D; (v2, v1) 效果一样</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  var num1 &#x3D; 10</span><br><span class="line">  var num2 &#x3D; 20</span><br><span class="line">  swapValues(&amp;num1, &amp;num2)</span><br><span class="line"> print(&quot;num1 &#x3D; \(num1), num2 &#x3D; \(num2)&quot;)</span><br><span class="line">    </span><br><span class="line">  输出： num1 &#x3D; 20, num2 &#x3D; 10</span><br></pre></td></tr></table></figure><p>注意点:</p><ul><li>可变参数不能标记为inout</li><li>inout参数不能有默认值</li><li>inout参数的本质是地址传递(引用传递)</li><li>inout参数只能传入可以被多次赋值的</li></ul><h2 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h2><p><code>inout</code> 是地址传递，对于不同的情况具体怎么传递呢？汇编拨开云雾</p><p>如下代码，表示等边的多边形，其中<code>width</code>表示边长，<code>side</code>表示多边形边长数量 <code>girth</code>表示周长，我们知道 <code>周长 = 边长 * 边数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct Shape &#123;</span><br><span class="line">    &#x2F;&#x2F; 宽、边长</span><br><span class="line">    var width: Int</span><br><span class="line">    &#x2F;&#x2F; 边的数量</span><br><span class="line">    var side: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSetSide&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSetSide&quot;, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 周长</span><br><span class="line">    var girth: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            &#x2F;&#x2F; 边长 &#x3D; 周长 &#x2F; 边数</span><br><span class="line">            width &#x3D; newValue &#x2F; side</span><br><span class="line">            print(&quot;setGirth&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;getGirth&quot;)</span><br><span class="line">            &#x2F;&#x2F; 周长 &#x3D; 边长 * 边数</span><br><span class="line">            return width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width&#x3D;\(width), side&#x3D;\(side), girth&#x3D;\(girth)&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func test(_ num: inout Int) &#123;</span><br><span class="line"> print(&quot;test&quot;);</span><br><span class="line">    num &#x3D; 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inout-修改存储属性"><a href="#inout-修改存储属性" class="headerlink" title="inout 修改存储属性"></a>inout 修改存储属性</h2><h3 id="先看打印结果"><a href="#先看打印结果" class="headerlink" title="先看打印结果"></a>先看打印结果</h3><p> 如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct Shape &#123;</span><br><span class="line">    &#x2F;&#x2F; 宽、边长</span><br><span class="line">    var width: Int</span><br><span class="line">    &#x2F;&#x2F; 边的数量</span><br><span class="line">    var side: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSetSide&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSetSide&quot;, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 周长</span><br><span class="line">    var girth: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            &#x2F;&#x2F; 边长 &#x3D; 周长 &#x2F; 边数</span><br><span class="line">            width &#x3D; newValue &#x2F; side</span><br><span class="line">            print(&quot;setGirth&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;getGirth&quot;)</span><br><span class="line">            &#x2F;&#x2F; 周长 &#x3D; 边长 * 边数</span><br><span class="line">            return width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width&#x3D;\(width), side&#x3D;\(side), girth&#x3D;\(girth)&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func test(_ num: inout Int) &#123;</span><br><span class="line"> print(&quot;test&quot;);</span><br><span class="line">    num &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s &#x3D; Shape(width: 10, side: 4)</span><br><span class="line">test(&amp;s.width) &#x2F;&#x2F;这里打断点</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">getGirth</span><br><span class="line">width&#x3D;8, side&#x3D;4, girth&#x3D;32</span><br></pre></td></tr></table></figure><p>其中<code>getGirth</code>这句打印是因为后面的<code>show</code>方法需要获取<code>girth</code>的值，如果我们去掉最后一句,只有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; Shape(width: 10, side: 4)</span><br><span class="line">test(&amp;s.width)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>在上面代码中的 <code>test(&amp;s.width)</code>这一句打断点</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef672deebf0?w=1172&h=650&f=png&s=295179" alt=""></p><p>关键代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量0x44be(%rip)的地址给寄存器rdi，rdi是全局变量s的地址</span><br><span class="line"> 0x100000fbb &lt;+107&gt;: leaq   0x44be(%rip), %rdi        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用test函数，其中rdi作为参数传入</span><br><span class="line">0x100000fc2 &lt;+114&gt;: callq  0x100001930               ; testSwift.test(inout Swift.Int) -&gt; () at main.swift:44</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> <strong>把属性<code>s.width</code>的地址值传递过去，进行修改</strong></p><ul><li>全局变量0x44be(%rip)的地址给寄存器rdi，rdi是全局变量s的地址</li><li>调用test函数，其中rdi作为参数传入</li></ul><ul><li><p>为什么我们代码中写的是 s.width ，但汇编传入的是s的地址呢？</p><ul><li>因为，width作为结构体的第一个属性变量，它的地址就是结构体s的地址</li></ul></li><li><p>为什么rdi是作为参数呢？</p><ul><li><a href="https://juejin.im/post/5d19f9816fb9a07f0a2df848" target="_blank" rel="noopener">汇编总结</a>中我们知道 rdi、rsi、rdx、rcx、r8、r9等寄存器常用于存放函数参数。</li></ul></li></ul><h2 id="inout-修改带有属性观察器的存储属性"><a href="#inout-修改带有属性观察器的存储属性" class="headerlink" title="inout 修改带有属性观察器的存储属性"></a>inout 修改带有属性观察器的存储属性</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先分析一下，应该和前面存储属性不一样的，因为如果直接修改存储属性<code>side</code>的值，那怎么调动属性观察器的方法<code>willSet</code>和<code>didSet</code>呢？，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Shape &#123;</span><br><span class="line">    &#x2F;&#x2F; 宽、边长</span><br><span class="line">    var width: Int</span><br><span class="line">    &#x2F;&#x2F; 边的数量</span><br><span class="line">    var side: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSetSide&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSetSide&quot;, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 周长</span><br><span class="line">    var girth: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            &#x2F;&#x2F; 边长 &#x3D; 周长 &#x2F; 边数</span><br><span class="line">            width &#x3D; newValue &#x2F; side</span><br><span class="line">            print(&quot;setGirth&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;getGirth&quot;)</span><br><span class="line">            &#x2F;&#x2F; 周长 &#x3D; 边长 * 边数</span><br><span class="line">            return width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width&#x3D;\(width), side&#x3D;\(side), girth&#x3D;\(girth)&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func test(_ num: inout Int) &#123;</span><br><span class="line">    print(&quot;test&quot;);</span><br><span class="line">    num &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">var s &#x3D; Shape(width: 10, side: 4)</span><br><span class="line"></span><br><span class="line">test(&amp;s.side) &#x2F;&#x2F;这里打断点</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">willSetSide 8</span><br><span class="line">didSetSide 4 8</span><br></pre></td></tr></table></figure><h3 id="查看汇编"><a href="#查看汇编" class="headerlink" title="查看汇编"></a>查看汇编</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef673dc1585?w=2092&h=1244&f=png&s=814277" alt=""></p><p>关键汇编代码分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量0x44e4(%rip)的地址给寄存器rdi，地址是testSwift.Shape + 8也就是size的地址</span><br><span class="line">0x100000f9d &lt;+109&gt;: movq   0x44e4(%rip), %rax        ; testSwift.s : testSwift.Shape + 8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;size的地址给局部变量-0x28(%rbp)</span><br><span class="line">0x100000fa4 &lt;+116&gt;: movq   %rax, -0x28(%rbp)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部变量-0x28(%rbp)的值给寄存器 %rdi</span><br><span class="line">0x100000fa8 &lt;+120&gt;: leaq   -0x28(%rbp), %rdi</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用test函数，寄存器 %rdi作为参数传入</span><br><span class="line">0x100000fac &lt;+124&gt;: callq  0x100001930               ; testSwift.test(inout Swift.Int) -&gt; () at main.swift:44</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此时已经修改完了局部变量 -0x28(%rbp)对应的值 并把局部变量 -0x28(%rbp)的值传给rdi,</span><br><span class="line">0x100000fb1 &lt;+129&gt;: movq   -0x28(%rbp), %rdi</span><br><span class="line">0x100000fb5 &lt;+133&gt;: leaq   0x44c4(%rip), %r13        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从截图中也可以看到此时%rdi里面是8，也就是 test函数中的  num &#x3D; 8</span><br><span class="line">0x100000fbc &lt;+140&gt;: callq  0x100001240               ; testSwift.Shape.side.setter : Swift.Int at &lt;compiler-generated&gt;</span><br></pre></td></tr></table></figure><h3 id="testSwift-Shape-side-setter函数中，调用side-willset-和-side-didset"><a href="#testSwift-Shape-side-setter函数中，调用side-willset-和-side-didset" class="headerlink" title="testSwift.Shape.side.setter函数中，调用side.willset 和 side.didset"></a><code>testSwift.Shape.side.setter</code>函数中，调用<code>side.willset</code> 和 <code>side.didset</code></h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef675ec0101?w=1988&h=1154&f=png&s=538327" alt=""></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>对于带有属性观察器的存储属性<code>size</code></p><ul><li>首先把<code>size</code>的地址放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>size</code></li></ul><h2 id="inout-修改计算属性girth"><a href="#inout-修改计算属性girth" class="headerlink" title="inout 修改计算属性girth"></a>inout 修改计算属性<code>girth</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先分析一下，应该和前面存储属性不一样的，因为计算属性<code>girth</code>没有自己的内存地址，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Shape &#123;</span><br><span class="line">    &#x2F;&#x2F; 宽、边长</span><br><span class="line">    var width: Int</span><br><span class="line">    &#x2F;&#x2F; 边的数量</span><br><span class="line">    var side: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSetSide&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSetSide&quot;, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 周长</span><br><span class="line">    var girth: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            &#x2F;&#x2F; 边长 &#x3D; 周长 &#x2F; 边数</span><br><span class="line">            width &#x3D; newValue &#x2F; side</span><br><span class="line">            print(&quot;setGirth&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;getGirth&quot;)</span><br><span class="line">            &#x2F;&#x2F; 周长 &#x3D; 边长 * 边数</span><br><span class="line">            return width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width&#x3D;\(width), side&#x3D;\(side), girth&#x3D;\(girth)&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func test(_ num: inout Int) &#123;</span><br><span class="line">    print(&quot;test&quot;);</span><br><span class="line">    num &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">var s &#x3D; Shape(width: 10, side: 4)</span><br><span class="line"></span><br><span class="line">test(&amp;s.girth) &#x2F;&#x2F;这里打断点</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getGirth</span><br><span class="line">test</span><br><span class="line">setGirth 8</span><br></pre></td></tr></table></figure><h3 id="查看汇编-1"><a href="#查看汇编-1" class="headerlink" title="查看汇编"></a>查看汇编</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef676ac3806?w=2008&h=1198&f=png&s=568740" alt=""></p><h3 id="汇编分析-1"><a href="#汇编分析-1" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>关键汇编代码分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用testSwift.Shape.girth.getter 方法，返回值放在rax中</span><br><span class="line">0x100000fab &lt;+123&gt;: callq  0x100001580               ; testSwift.Shape.girth.getter : Swift.Int at main.swift:33</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把getter的返回值放在 局部变量-0x28(%rbp)中</span><br><span class="line">0x100000fb0 &lt;+128&gt;: movq   %rax, -0x28(%rbp)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部变量-0x28(%rbp)的地址值 放在寄存器rdi</span><br><span class="line">0x100000fb4 &lt;+132&gt;: leaq   -0x28(%rbp), %rdi</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;寄存器rdi的地址值传到testSwift.test函数中，进行修改</span><br><span class="line">0x100000fb8 &lt;+136&gt;: callq  0x100001930               ; testSwift.test(inout Swift.Int) -&gt; () at main.swift:44</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 局部变量-0x28(%rbp)的值，传到寄存器rdi中</span><br><span class="line">0x100000fbd &lt;+141&gt;: movq   -0x28(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x100000fc1 &lt;+145&gt;: leaq   0x44b8(%rip), %r13        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 寄存器rdi里面放的是局部变量-0x28(%rbp)的值 传入到Shape.girth.setter中</span><br><span class="line">0x100000fc8 &lt;+152&gt;: callq  0x1000012f0               ;  testSwift.Shape.girth.setter : Swift.Int at main.swift:28</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>因为计算属性本身没有地址值，所以过程略显复杂</p><p>对于<code>inout</code>修改计算属性<code>girth</code></p><ul><li>首先调用<code>getter</code>方法，把返回值放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>girth</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="针对本文代码的总结"><a href="#针对本文代码的总结" class="headerlink" title="针对本文代码的总结"></a>针对本文代码的总结</h3><p>输入输出参数inout 本质就是引用传递，也就是地址传递，根据传过来的地址，修改对应的值。针对不同的情况，其他处理不同，</p><ul><li>普通存储属性，直接把地址值传过来修改就可以了。</li><li>对于<code>inout</code>带有属性观察器的存储属性<code>size</code><ul><li>首先把<code>size</code>的地址放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>size</code></li></ul></li><li>对于<code>inout</code>修改计算属性<code>girth</code><ul><li>首先调用<code>getter</code>方法，把返回值放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>girth</code></li></ul></li></ul><h3 id="针对inout的总结"><a href="#针对inout的总结" class="headerlink" title="针对inout的总结"></a>针对inout的总结</h3><ul><li>如果实参有物理内存地址，且没有设置属性观察器    <ul><li>直接将实参的内存地址传入函数（实参进行引用传递）</li><li>如果实参是计算属性 或者 设置了属性观察器</li></ul></li><li>采取了Copy In Copy Out的做法<ul><li>调用该函数时，先复制实参的值，产生副本【get】</li><li>将副本的内存地址传入函数（副本进行引用传递），在函数内部可以修改副本的值</li><li>函数返回后，再将副本的值覆盖实参的值【set】</li></ul></li><li>总结：inout的本质就是引用传递（地址传递）</li></ul><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html&quot;&gt;个人博客&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之继承</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%A7%E6%89%BF/</id>
    <published>2019-09-18T00:32:24.000Z</published>
    <updated>2019-12-12T06:31:53.459Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%A7%E6%89%BF.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同其他语言一样，Swift中也是有继承的</p><ul><li>值类型（枚举、结构体）不支持继承，只有类支持继承</li><li>没有父类的类，称为：基类<ul><li>Swift并没有像OC、Java那样的规定：任何类最终都要继承自某个基类</li></ul></li><li>子类可以重写父类的下标、方法、属性，重写必须加上<code>override</code>关键字</li></ul><h2 id="类继承的内存结构"><a href="#类继承的内存结构" class="headerlink" title="类继承的内存结构"></a>类继承的内存结构</h2><ul><li>有如下<code>Animal类</code>,其中<code>Dog 类</code>继承<code>Animal类</code> ，其中<code>ErHa 类</code>继承<code>Dog类</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var age &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">class Dog : Animal &#123;</span><br><span class="line">    var weight &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">class ErHa : Dog &#123;</span><br><span class="line">    var iq &#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Animal类的内存"><a href="#Animal类的内存" class="headerlink" title="Animal类的内存"></a><code>Animal类</code>的内存</h3><p>如下代码查看类的内存大小和相应内存的值，需要用到工具<a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">Mems</a><br>关于的使用可以看<a href="https://juejin.im/post/5d1eeca3f265da1ba6480cc7" target="_blank" rel="noopener">Swift之枚举</a>一文，或者直接看github上<a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">Mems</a>的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Animal()</span><br><span class="line">a.age &#x3D; 5</span><br><span class="line">print(Mems.size(ofRef: a))</span><br><span class="line">print(Mems.memStr(ofRef: a))</span><br></pre></td></tr></table></figure><p><code>Animal类</code>的内存大小和内容，分别为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">0x00000001000084d8 &#x2F;&#x2F;存放类的相关信息</span><br><span class="line">0x0000000000000002 &#x2F;&#x2F;引用技术</span><br><span class="line">0x0000000000000005  &#x2F;&#x2F; age数值5</span><br><span class="line">0x0000000000000000&#x2F;&#x2F;没用到</span><br></pre></td></tr></table></figure><h3 id="Animal类的内存分析"><a href="#Animal类的内存分析" class="headerlink" title="Animal类的内存分析"></a><code>Animal类</code>的内存分析</h3><ul><li>首先类本身就要占用16个字节，其中8个存放类的信息，8个存放引用技术，具体分析见<a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a></li><li>然后是 age的值5 占用8个字节，总共24个字节，</li><li>因为内存对齐的原因，必须是16的倍数，所以需要32个字节，其中最后8个字节用不到，全是0</li></ul><h3 id="Dog类的内存"><a href="#Dog类的内存" class="headerlink" title="Dog类的内存"></a><code>Dog类</code>的内存</h3><p>如下代码查看类的内存大小和相应内存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let d &#x3D; Dog()</span><br><span class="line">d.age &#x3D; 6</span><br><span class="line">d.weight &#x3D; 7</span><br><span class="line">print(Mems.size(ofRef: d))</span><br><span class="line">print(Mems.memStr(ofRef: d))</span><br></pre></td></tr></table></figure><p><code>Dog类</code>的内存大小和内容，分别为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">0x0000000100008588 &#x2F;&#x2F;存放类的相关信息</span><br><span class="line">0x0000000000000002 &#x2F;&#x2F;引用技术</span><br><span class="line">0x0000000000000006  &#x2F;&#x2F; age数值6</span><br><span class="line">0x0000000000000007&#x2F;&#x2F;weight的值7</span><br></pre></td></tr></table></figure><h3 id="Dog类的内存分析"><a href="#Dog类的内存分析" class="headerlink" title="Dog类的内存分析"></a><code>Dog类</code>的内存分析</h3><ul><li>首先类本身就要占用16个字节，其中8个存放类的信息，8个存放引用技术，具体分析见<a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a></li><li>然后是 age的值6 占用8个字节，weight的值7 占用8个字节， 总共32个字节，</li><li>因为内存对齐的原因，必须是16的倍数，但是32正好是16的倍数，所以总共需要32个字</li></ul><h3 id="ErHa类的内存"><a href="#ErHa类的内存" class="headerlink" title="ErHa类的内存"></a><code>ErHa类</code>的内存</h3><p>如下代码查看类的内存大小和相应内存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let e &#x3D; ErHa()</span><br><span class="line">e.age &#x3D; 8</span><br><span class="line">e.weight &#x3D; 9</span><br><span class="line">e.iq &#x3D; 10</span><br><span class="line">print(Mems.size(ofRef: e))</span><br><span class="line">print(Mems.memStr(ofRef: e))</span><br></pre></td></tr></table></figure><p><code>ErHa类</code>的内存大小和内容，分别为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">48</span><br><span class="line">0x0000000100008658 &#x2F;&#x2F;存放类的相关信息</span><br><span class="line">0x0000000000000002 &#x2F;&#x2F;引用技术</span><br><span class="line">0x0000000000000008  &#x2F;&#x2F; age数值8</span><br><span class="line">0x0000000000000009&#x2F;&#x2F;weight的值9</span><br><span class="line">0x000000000000000a&#x2F;&#x2F;iq的值10</span><br><span class="line">0x0000000000000000&#x2F;&#x2F;内存对齐增加的，没用到</span><br></pre></td></tr></table></figure><h3 id="ErHa类的内存分析"><a href="#ErHa类的内存分析" class="headerlink" title="ErHa类的内存分析"></a><code>ErHa类</code>的内存分析</h3><ul><li>首先类本身就要占用16个字节，其中8个存放类的信息，8个存放引用技术，具体分析见<a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a></li><li>然后是 age,weight,iq分别占用8个字节，16+24 = 40个字节了</li><li>因为内存对齐的原因，必须是16的倍数，所以需要48个字节</li></ul><h2 id="重写实例方法、下标"><a href="#重写实例方法、下标" class="headerlink" title="重写实例方法、下标"></a>重写实例方法、下标</h2><p>子类可以重写父类的实例方法、下标</p><p>有个<code>Animal</code> 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    func speak() &#123;</span><br><span class="line">        print(&quot;Animal speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类<code>Cat</code>继承<code>Animal</code>,如果重写示例方法，下标，必须用关键字<code>override</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    func speak() &#123;</span><br><span class="line">        print(&quot;Animal speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat : Animal &#123;</span><br><span class="line">    override func speak() &#123;</span><br><span class="line">        super.speak()</span><br><span class="line">        print(&quot;Cat speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return super[index] + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写类型方法、下标"><a href="#重写类型方法、下标" class="headerlink" title="重写类型方法、下标"></a>重写类型方法、下标</h2><p>上面的实例方法、下标。如果是类型方法、下标的话，有些许不同，</p><ul><li>被class修饰的类型方法、下标，允许被子类重写</li><li>被static修饰的类型方法、下标，不允许被子类重写</li></ul><p>eg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">&#x2F;&#x2F;static修饰</span><br><span class="line">    static func speak() &#123;</span><br><span class="line">        print(&quot;Animal speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; class修饰</span><br><span class="line">    class subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(Animal[6])</span><br><span class="line">class Cat : Animal &#123;</span><br><span class="line">&#x2F;&#x2F;编译报错 Cannot override static method</span><br><span class="line">    override class func speak() &#123;</span><br><span class="line">        super.speak()</span><br><span class="line">        print(&quot;Cat speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;编译成功</span><br><span class="line">    override class subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return super[index] + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示<code>static</code>修饰的时候，子类重写，直接报错<code>Cannot override static method</code>。而<code>class</code>修饰时候，编译正常</p><h2 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h2><ul><li>子类可以将父类的属性（存储、计算）重写为计算属性</li><li>子类不可以将父类属性重写为存储属性</li><li>只能重写var属性，不能重写let属性</li><li>重写时，属性名、类型要一致</li><li>子类重写后的属性权限 不能小于 父类属性的权限<ul><li>如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的</li><li>如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的</li></ul></li></ul><h3 id="重写类型属性"><a href="#重写类型属性" class="headerlink" title="重写类型属性"></a>重写类型属性</h3><p> 重写类型属性，比较简单，不做赘述</p><h3 id="重写类型属性-1"><a href="#重写类型属性-1" class="headerlink" title="重写类型属性"></a>重写类型属性</h3><p><strong>注意的是：如果子类把父类的存储属性int 重写为计算属性，子类中依然有8个字节存储该int属性</strong></p><p><strong>再次需要注意的是，和重写类型方法、下标类似 如果重写类型属性</strong></p><ul><li>被class修饰的类型方法、下标，允许被子类重写</li><li>被static修饰的类型方法、下标，不允许被子类重写</li></ul><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><h3 id="可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性"><a href="#可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性" class="headerlink" title="可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性"></a>可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器，依然是存储属性</h3><p>eg，子类<code>SubCircle</code>给父类<code>Circle</code>的存储属性<code>radius</code>增加属性观察器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：子类增加属性观察器之后，依然是存储属性</strong></p><h3 id="如果父类本身就有属性观察器"><a href="#如果父类本身就有属性观察器" class="headerlink" title="如果父类本身就有属性观察器"></a>如果父类本身就有属性观察器</h3><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int &#x3D; 1 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;Circle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;Circle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var circle &#x3D; SubCircle()</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubCircle willSetRadius 10</span><br><span class="line">Circle willSetRadius 10</span><br><span class="line">Circle didSetRadius 1 10</span><br><span class="line">SubCircle didSetRadius 1 10</span><br></pre></td></tr></table></figure><h3 id="重写父类的计算属性"><a href="#重写父类的计算属性" class="headerlink" title="重写父类的计算属性"></a>重写父类的计算属性</h3><p>如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;Circle setRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;Circle getRadius&quot;)</span><br><span class="line">            return 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var circle &#x3D; SubCircle()</span><br><span class="line">circle.radius &#x3D; 10</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Circle getRadius</span><br><span class="line">SubCircle willSetRadius 10</span><br><span class="line">Circle setRadius 10</span><br><span class="line">Circle getRadius</span><br><span class="line">SubCircle didSetRadius 20 20</span><br></pre></td></tr></table></figure><p>输出结果分析</p><ul><li>调用<code>circle.radius = 10</code>的时候，先获取了<code>oldValue</code>，调用父类的<code>get</code>输出<code>Circle getRadius</code></li><li>然后调用子类<code>willSetRadius</code>准备赋值</li><li>调用父类<code>setRadius</code></li><li>准备调用子类的<code>print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</code>之前，要先获取<code>radius</code>的值，所以，需要先执行父类的<code>getRadius</code></li><li>执行子类的<code>didSet</code>方法</li></ul><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul><li>被final修饰的方法、下标、属性，禁止被重写</li><li>被final修饰的类，禁止被继承</li></ul><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%A7%E6%89%BF.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之方法</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E6%96%B9%E6%B3%95/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E6%96%B9%E6%B3%95/</id>
    <published>2019-08-30T00:32:24.000Z</published>
    <updated>2019-12-12T06:33:40.310Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E6%96%B9%E6%B3%95.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>方法，也就是函数。同其他语言一样，在Swift中，也是分为实例方法和类型方法</p><h2 id="枚举、结构体、类都可以定义实例方法、类型方法"><a href="#枚举、结构体、类都可以定义实例方法、类型方法" class="headerlink" title="枚举、结构体、类都可以定义实例方法、类型方法"></a>枚举、结构体、类都可以定义实例方法、类型方法</h2><h3 id="实例方法（Instance-Method）：通过实例对象调用"><a href="#实例方法（Instance-Method）：通过实例对象调用" class="headerlink" title="实例方法（Instance Method）：通过实例对象调用"></a>实例方法（Instance Method）：通过实例对象调用</h3><h3 id="类型方法（Type-Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法"><a href="#类型方法（Type-Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法" class="headerlink" title="类型方法（Type Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法"></a>类型方法（Type Method）：通过类型调用，用static或者class关键字定义，类似OC中的类方法</h3><p>例如有个类Car,有实例方法<code>getnNum</code>和类型方法<code>getCount</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    static var cout &#x3D; 0</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    init() &#123;</span><br><span class="line">        Car.cout +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 类型方法</span><br><span class="line">    static func getCount() -&gt; Int &#123; cout &#125;</span><br><span class="line">    &#x2F;&#x2F; 实例方法</span><br><span class="line">    func getnNum() -&gt; Int &#123;</span><br><span class="line">        num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let c0 &#x3D; Car()</span><br><span class="line">let c1 &#x3D; Car()</span><br><span class="line">let c2 &#x3D; Car()</span><br><span class="line">print(Car.getCount()) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">c0.num &#x3D; 10</span><br><span class="line">c1.num &#x3D; 11</span><br><span class="line"></span><br><span class="line">print(c1.num) &#x2F;&#x2F;11</span><br><span class="line">print(c2.num) &#x2F;&#x2F;0</span><br></pre></td></tr></table></figure><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>不管是实例方法，还是类型方法，里面都可以调用 <code>self</code></p><ul><li>在实例方法中代表实例对象</li><li>在类型方法中代表类型<ul><li>在类型方法static func getCount中</li><li>cout等价于self.cout、Car.self.cout、Car.cout</li></ul></li></ul><p>例如上面的代码可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    static var cout &#x3D; 0</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    init() &#123;</span><br><span class="line">        Car.cout +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 类型方法</span><br><span class="line">    static func getCount() -&gt; Int &#123;</span><br><span class="line">        self.cout &#x2F;&#x2F;self代表类型</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func getnNum() -&gt; Int &#123;</span><br><span class="line">        self.num &#x2F;&#x2F;self代表实例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字mutating"><a href="#关键字mutating" class="headerlink" title="关键字mutating"></a>关键字<code>mutating</code></h2><ul><li>结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改</li><li>在func关键字前加mutating可以允许这种修改行为</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">     func moveBy(deltaX: Double, deltaY: Double) &#123;</span><br><span class="line">        x +&#x3D; deltaX &#x2F;&#x2F;编译报错 Left side of mutating operator isn&#39;t mutable: &#39;self&#39; is immutable</span><br><span class="line">        y +&#x3D; deltaY &#x2F;&#x2F;编译报错 Left side of mutating operator isn&#39;t mutable: &#39;self&#39; is immutable</span><br><span class="line">         self &#x3D; Point(x: x + deltaX, y: y + deltaY) &#x2F;&#x2F;编译报错 Cannot assign to value: &#39;self&#39; is immutable</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum StateSwitch &#123;</span><br><span class="line">    case low, middle, high</span><br><span class="line">     func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .low:</span><br><span class="line">            self &#x3D; .middle&#x2F;&#x2F;编译报错 Cannot assign to value: &#39;self&#39; is immutable</span><br><span class="line">        case .middle:</span><br><span class="line">            self &#x3D; .high&#x2F;&#x2F;编译报错 Cannot assign to value: &#39;self&#39; is immutable</span><br><span class="line">        case .high:</span><br><span class="line">            self &#x3D; .low&#x2F;&#x2F;编译报错 Cannot assign to value: &#39;self&#39; is immutable</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加上关键字<code>mutating</code>之后就可以了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    mutating func moveBy(deltaX: Double, deltaY: Double) &#123;</span><br><span class="line">        x +&#x3D; deltaX </span><br><span class="line">        y +&#x3D; deltaY </span><br><span class="line">        self &#x3D; Point(x: x + deltaX, y: y + deltaY) </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum StateSwitch &#123;</span><br><span class="line">    case low, middle, high</span><br><span class="line">   mutating  func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .low:</span><br><span class="line">            self &#x3D; .middle</span><br><span class="line">        case .middle:</span><br><span class="line">            self &#x3D; .high</span><br><span class="line">        case .high:</span><br><span class="line">            self &#x3D; .low        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字-discardableResult"><a href="#关键字-discardableResult" class="headerlink" title="关键字@discardableResult"></a>关键字<code>@discardableResult</code></h2><ul><li>在func前面加个@discardableResult，可以消除：函数调用后返回值未被使用的警告⚠</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">     mutating func moveX(deltaX: Double) -&gt; Double &#123;</span><br><span class="line">        x +&#x3D; deltaX</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; Point()</span><br><span class="line">p.moveX(deltaX: 10)</span><br></pre></td></tr></table></figure><p>因为方法<code>moveX</code>的返回值没有使用，编译器会报警告</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/15/16bf284e958adef2?w=871&h=216&f=png&s=50207" alt=""></p><ul><li>如果加了关键字<code>@discardableResult</code>就不会警告了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    @discardableResult mutating </span><br><span class="line">    func moveX(deltaX: Double) -&gt; Double &#123;</span><br><span class="line">        x +&#x3D; deltaX</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; Point()</span><br><span class="line">p.moveX(deltaX: 10)</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E6%96%B9%E6%B3%95.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之属性</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%B1%9E%E6%80%A7/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E5%B1%9E%E6%80%A7/</id>
    <published>2019-08-20T00:32:24.000Z</published>
    <updated>2019-12-12T06:26:53.513Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift之属性.html">我的个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面了解了 <a href="https://juejin.im/post/5d216d6bf265da1b957079d8" target="_blank" rel="noopener">Swift之类</a>  和 <a href="https://juejin.im/post/5d216e1ff265da1bb27752aa" target="_blank" rel="noopener">Swift之结构体</a>  </p><p>这篇文章分享一下Swift中的属性</p><h2 id="Swift中跟实例相关的属性可以分为2大类"><a href="#Swift中跟实例相关的属性可以分为2大类" class="headerlink" title="Swift中跟实例相关的属性可以分为2大类"></a>Swift中跟实例相关的属性可以分为2大类</h2><h3 id="存储属性（Stored-Property）"><a href="#存储属性（Stored-Property）" class="headerlink" title="存储属性（Stored Property）"></a>存储属性（Stored Property）</h3><ul><li>类似于成员变量这个概念</li><li>存储在实例的内存中</li><li>结构体、类可以定义存储属性</li><li>枚举不可以定义存储属性<ul><li>关于枚举不可以定义存储属性，根据之前的<a href="https://juejin.im/post/5d1eeca3f265da1ba6480cc7" target="_blank" rel="noopener">Swift枚举</a>一文可知，<br>枚举中存储关联值或者keys，不存储属性的。</li></ul></li></ul><h4 id="关于存储属性，Swift有个明确的规定"><a href="#关于存储属性，Swift有个明确的规定" class="headerlink" title="关于存储属性，Swift有个明确的规定"></a>关于存储属性，Swift有个明确的规定</h4><ul><li>在创建类 或 结构体的实例时，必须为所有的存储属性设置一个合适的初始值<ul><li>可以在初始化器里为存储属性设置一个初始值</li><li>可以分配一个默认的属性值作为属性定义的一部分</li></ul></li></ul><p>关于这个规定，我们在<a href="https://juejin.im/post/5d216e1ff265da1bb27752aa" target="_blank" rel="noopener">Swift之结构体</a>   一文中已经说过了，这里稍微提一下，比如下面代码，x和y都是存储属性，当初始化的时候，如果没值，编译器会直接报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">var p2 &#x3D; Point(y: 20) &#x2F;&#x2F;报错 Missing argument for parameter &#39;x&#39; in call</span><br><span class="line">var p3 &#x3D; Point(x: 10) &#x2F;&#x2F;报错 Missing argument for parameter &#39;y&#39; in call</span><br><span class="line">var p4 &#x3D; Point()    &#x2F;&#x2F;报错 Missing argument for parameter &#39;x&#39; in call</span><br></pre></td></tr></table></figure><h3 id="计算属性（Computed-Property）"><a href="#计算属性（Computed-Property）" class="headerlink" title="计算属性（Computed Property）"></a>计算属性（Computed Property）</h3><ul><li>本质就是方法（函数）</li><li>不占用实例的内存</li><li>枚举、结构体、类都可以定义计算属性</li><li>set传入的新值默认叫做newValue，也可以自定义</li></ul><p>如下面结构体<code>Circle</code>包括了存储属性<code>radius</code>和计算属性<code>diameter</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">truct Circle &#123;</span><br><span class="line">    &#x2F;&#x2F; 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    &#x2F;&#x2F; 计算属性</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            radius &#x3D; newValue &#x2F; 2</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">           return radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var circle &#x3D; Circle(radius: 5)</span><br><span class="line">print(circle.radius) &#x2F;&#x2F; 5.0</span><br><span class="line">print(circle.diameter) &#x2F;&#x2F; 10.0</span><br><span class="line">circle.diameter &#x3D; 12</span><br><span class="line">print(circle.radius) &#x2F;&#x2F; 6.0</span><br><span class="line">print(circle.diameter) &#x2F;&#x2F; 12.0</span><br></pre></td></tr></table></figure><ul><li>只读计算属性：只有get，没有set<br>如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    var radius: Double</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读计算属性可以简写，例如上面的代码可以如下表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    var radius: Double</span><br><span class="line">    var diameter: Double &#123; radius * 2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算属性不占用实例的内存"><a href="#计算属性不占用实例的内存" class="headerlink" title="计算属性不占用实例的内存"></a>计算属性不占用实例的内存</h4><p>关于不占用实例的内存，可以如下代码证明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    &#x2F;&#x2F; 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    &#x2F;&#x2F; 计算属性</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            radius &#x3D; newValue &#x2F; 2</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">           return radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;Double占用字节&quot;, MemoryLayout&lt;Double&gt;.stride)</span><br><span class="line">print(&quot;Circle占用字节&quot;,MemoryLayout&lt;Circle&gt;.stride) &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double占用字节 8</span><br><span class="line">Circle占用字节 8</span><br></pre></td></tr></table></figure><p>也就是说<code>Circle</code>占用的仅仅是其存储属性<code>radius</code>所占用的内存。和计算属性无关的，读者也可以多写几个计算属性，自行验证。</p><h3 id="汇编分析存储属性和计算属性的区别"><a href="#汇编分析存储属性和计算属性的区别" class="headerlink" title="汇编分析存储属性和计算属性的区别"></a>汇编分析存储属性和计算属性的区别</h3><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    &#x2F;&#x2F; 存储属性</span><br><span class="line">    var radius: Int</span><br><span class="line">    &#x2F;&#x2F; 计算属性</span><br><span class="line">    var diameter: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            radius &#x3D; newValue &#x2F; 2</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">           return radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var circle &#x3D; Circle(radius: 9)</span><br><span class="line">circle.radius &#x3D; 5 </span><br><span class="line">circle.diameter &#x3D; 8 &#x2F;&#x2F;这里打断点</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad12510f0?w=1114&h=800&f=png&s=400156" alt=""></p><ul><li><p>5存储到了全局变量<code>0x3e96(%rip)</code>,全局变量只有<code>circle</code>，所以也就是说存储属性的值，被直接放在了结构体的内存中。</p></li><li><p>8赋值给寄存器<code>%r8d</code>，又给寄存器%edi，作为参数调用函数<code>0x100001ae0</code>的时候传入，而函数<code>0x100001ae0</code>就是<code>testSwift.Circle.diameter.setter</code>这就是存储属性和计算属性的区别</p></li></ul><h2 id="枚举rawValue的原理"><a href="#枚举rawValue的原理" class="headerlink" title="枚举rawValue的原理"></a>枚举rawValue的原理</h2><p>在<a href="https://juejin.im/post/5d1eeca3f265da1ba6480cc7" target="_blank" rel="noopener">Swift枚举</a>一文中，我们说过枚举原始值是不占用内存的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Season: Int&#123;</span><br><span class="line">    case test1 &#x3D; 1, test2, test3, test4</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s &#x3D; Season.test2</span><br><span class="line">print(s.rawValue) &#x2F;&#x2F;输出2</span><br></pre></td></tr></table></figure><p>上面代码输出为2。<br>这些原始值 test1 = 1, test2, test3, test4，系统内部完全可以写成只读计算属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enum Season: Int&#123;</span><br><span class="line">    case test1 &#x3D; 1, test2, test3, test4</span><br><span class="line">    </span><br><span class="line">    var rawValue : Int &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .test1:</span><br><span class="line">            return 11</span><br><span class="line">        case .test2:</span><br><span class="line">            return 12</span><br><span class="line">        case .test3:</span><br><span class="line">            return 13</span><br><span class="line">        case .test4:</span><br><span class="line">            return 14</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s &#x3D; Season.test2</span><br><span class="line">print(s.rawValue) &#x2F;&#x2F;输出12</span><br></pre></td></tr></table></figure><p>上面代码输出为12，这样就完成了获取枚举的原始值的时候，直接获取的是只读计算属性。光看结果是不够令人信服的，那就看汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Season: Int&#123;</span><br><span class="line">    case test1 &#x3D; 1, test2, test3, test4</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s &#x3D; Season.test2</span><br><span class="line">print(s.rawValue) &#x2F;&#x2F;这里打断点</span><br></pre></td></tr></table></figure><p>上述代码在最后一行打断点</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad1350252?w=1077&h=611&f=png&s=261495" alt=""></p><p>可以看到，确实调用了<code>rawValue.getter</code>。</p><p>所以汇编才是看出本质的神器。</p><h2 id="延迟存储属性（Lazy-Stored-Property）"><a href="#延迟存储属性（Lazy-Stored-Property）" class="headerlink" title="延迟存储属性（Lazy Stored Property）"></a>延迟存储属性（Lazy Stored Property）</h2><h3 id="使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化"><a href="#使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化" class="headerlink" title="使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化"></a>使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化</h3><ul><li>lazy属性必须是var，不能是let<ul><li>let必须在实例的初始化方法完成之前就拥有值</li></ul></li><li>如果多条线程同时第一次访问lazy属性<ul><li>无法保证属性只被初始化1次</li></ul></li></ul><p>eg:有类 Car和类Person ，car作为Person的延迟存储属性，那么当使用car的是，才会调用car的初始化方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        print(&quot;Car init!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Car is running!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    lazy var car &#x3D; Car()</span><br><span class="line">    init() &#123;</span><br><span class="line">        print(&quot;Person init!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func goOut() &#123;</span><br><span class="line">        car.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D; Person()</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">p.goOut()</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person init!</span><br><span class="line">--------</span><br><span class="line">Car init!</span><br><span class="line">Car is running!</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h3><ul><li>当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性<ul><li>因为延迟属性初始化时需要改变结构体的内存</li></ul></li></ul><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><ul><li>可以为非lazy的var存储属性设置属性观察器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    var radius: Double &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSet&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSet&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        self.radius &#x3D; 1.0</span><br><span class="line">        print(&quot;Circle init!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var circle &#x3D; Circle()&#x2F;&#x2F; 输出 Circle init!</span><br><span class="line"></span><br><span class="line">circle.radius &#x3D; 10.5 </span><br><span class="line">&#x2F;&#x2F; 输出 willSet 10.5 </span><br><span class="line">&#x2F;&#x2F; didSet 1.0 10.5</span><br><span class="line"></span><br><span class="line">print(circle.radius) &#x2F;&#x2F;输出 10.5</span><br></pre></td></tr></table></figure><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul><li>willSet会传递新值，默认叫newValue</li><li>didSet会传递旧值，默认叫oldValue</li><li>在初始化器中设置属性值不会触发willSet和didSet</li><li>在属性定义时设置初始值也不会触发willSet和didSet</li></ul><h2 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h2><ul><li>属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量身上</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var num: Int &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        return 10</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">        print(&quot;setNum&quot;, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num &#x3D; 11 &#x2F;&#x2F; setNum 11</span><br><span class="line">print(num) &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    var age &#x3D; 10 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSet&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSet&quot;, oldValue, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    age &#x3D; 11</span><br><span class="line">    &#x2F;&#x2F; willSet 11</span><br><span class="line">    &#x2F;&#x2F; didSet 10 11</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h2 id="类型属性（Type-Property）"><a href="#类型属性（Type-Property）" class="headerlink" title="类型属性（Type Property）"></a>类型属性（Type Property）</h2><h3 id="类型属性分类"><a href="#类型属性分类" class="headerlink" title="类型属性分类"></a>类型属性分类</h3><ol><li>实例属性（Instance Property）：只能通过实例去访问<ul><li>存储实例属性（Stored Instance Property）：存储在实例的内存中，每个实例都有1份</li><li>计算实例属性（Computed Instance Property）</li></ul></li><li>类型属性（Type Property）：只能通过类型去访问<ul><li>存储类型属性（Stored Type Property）：整个程序运行过程中，就只有1份内存（类似于全局变量）</li><li>计算类型属性（Computed Type Property）</li></ul></li><li>可以通过static定义类型属性<ul><li>如果是类，也可以用关键字class</li></ul></li></ol><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Car &#123;</span><br><span class="line">    static var count: Int &#x3D; 0</span><br><span class="line">    init() &#123;</span><br><span class="line">        Car.count +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let c1 &#x3D; Car()</span><br><span class="line">let c2 &#x3D; Car()</span><br><span class="line">let c3 &#x3D; Car()</span><br><span class="line">print(Car.count) &#x2F;&#x2F; 输出3</span><br></pre></td></tr></table></figure><h3 id="类型属性细节"><a href="#类型属性细节" class="headerlink" title="类型属性细节"></a>类型属性细节</h3><ol><li>不同于存储实例属性，你必须给存储类型属性设定初始值<ul><li>因为类型没有像实例那样的init初始化器来初始化存储属性</li></ul></li><li>存储类型属性默认就是lazy，会在第一次使用的时候才初始化<ul><li>就算被多个线程同时访问，保证只会初始化一次</li><li>存储类型属性可以是let</li></ul></li><li>枚举类型也可以定义类型属性（存储类型属性、计算类型属性）</li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>关于单例模式，可以参考我的另一篇文章<a href="https://juejin.im/post/5d295106e51d45105d63a5b2" target="_blank" rel="noopener">你真的懂单例模式么</a></p><p>不同语言的单例模式，都是类似的，这里给出Swift版本单例的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">public class FileManager &#123;</span><br><span class="line">&#x2F;&#x2F;单例模式</span><br><span class="line">    public static let shared &#x3D; FileManager()</span><br><span class="line">    private init() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果单例里面代码过多，可以写成如下</span><br><span class="line">public class FileManager &#123;</span><br><span class="line">    public static let shared &#x3D; &#123;</span><br><span class="line">        &#x2F;&#x2F; ....</span><br><span class="line">        &#x2F;&#x2F; ....</span><br><span class="line">        return FileManager()</span><br><span class="line">    &#125;()</span><br><span class="line">    private init() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇编分析-static"><a href="#汇编分析-static" class="headerlink" title="汇编分析 static"></a>汇编分析 static</h2><p>下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">public class YZPerson &#123;</span><br><span class="line">    static  var count &#x3D; 3 &#x2F;&#x2F;这里打断点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YZPerson.count &#x3D; 6</span><br></pre></td></tr></table></figure><p>如下图所示，可以看出，会调用 <code>swift_once</code>函数，来到这个调用位置，si汇编调试指令，一直跟进去</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad15fe540?w=1950&h=678&f=png&s=272688" alt=""></p><p>最终会来到这里，调用<code>dispatch_once_f</code><br><img src="https://user-gold-cdn.xitu.io/2019/7/14/16bee94ad1e7961e?w=1932&h=790&f=png&s=288329" alt=""></p><p>也就是说<code>static</code>内部封装了<code>dispatch_once_</code> 而<code>dispatch_once_</code>能保证线程安全的，只能被初始化一次，所以单例的时候可以用<code>static</code> 关于 <code>dispatch_once</code>的分析，可以看这篇文章<a href="https://juejin.im/post/5d295106e51d45105d63a5b2" target="_blank" rel="noopener">你真的懂单例模式么</a></p><ul><li>同样的，我们可以从代码角度，汇编角度分别证明 <code>static</code> 修饰的变量，属于全局变量。读者有兴趣自己证明。这里不再赘述。</li></ul><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p><p><a href="https://juejin.im/post/5d295106e51d45105d63a5b2" target="_blank" rel="noopener">你真的懂单例模式么</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift之属性.html&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之通过汇编探究闭包本质</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8E%A2%E7%A9%B6%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8E%A2%E7%A9%B6%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8/</id>
    <published>2019-08-10T00:32:24.000Z</published>
    <updated>2019-12-12T06:22:54.825Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8E%A2%E7%A9%B6%E9%97%AD%E5%8C%85%E6%9C%AC%E8%B4%A8.html">我的个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先回顾一下，上一篇  <a href="https://juejin.im/post/5d229738f265da1b715317b7" target="_blank" rel="noopener">Swift之闭包(Closure)</a>中对闭包的解释</p><ul><li>一个函数和它所捕获的变量\常量环境组合起来，称为闭包<ul><li>一般指定义在函数内部的函数</li><li>一般它捕获的是外层函数的局部变量\常量</li></ul></li><li>可以把闭包想象成是一个类的实例对象<ul><li>内存在堆空间</li><li>捕获的局部变量\常量就是对象的成员(存储属性) </li><li>组成闭包的函数就是类内部定义的方法</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先看下面一段代码，猜猜会输出什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn &#x3D; (Int) -&gt; Int</span><br><span class="line">func getFn() -&gt; Fn&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部变量</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    func plus(_ i: Int) -&gt; Int&#123;</span><br><span class="line">        num +&#x3D; i</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line">    return plus(_:)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; getFn()</span><br><span class="line">print(fn(1)) &#x2F;&#x2F; 1</span><br><span class="line">print(fn(2))&#x2F;&#x2F; 3</span><br><span class="line">print(fn(3))&#x2F;&#x2F; 6</span><br><span class="line">print(fn(4))&#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure><p>结果是输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>那么，问题来了，为什么输出的是10呢？因为按照常识，var num = 0 是局部变量，执行完就销毁了，怎么能再后面继续使用呢？</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们先从简单的说起<br>首先是下面一端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn &#x3D; (Int) -&gt; Int</span><br><span class="line">func getFn() -&gt; Fn&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部变量</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    func plus(_ i: Int) -&gt; Int&#123;</span><br><span class="line">        return i </span><br><span class="line">    &#125;</span><br><span class="line">    return plus(_:) &#x2F;&#x2F; 这里打断点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; getFn()</span><br><span class="line">print(fn(1))</span><br></pre></td></tr></table></figure><p>先不适用num ,直接 return i 并在这里打断点，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">testSwift&#96;getFn():</span><br><span class="line">    0x100001f70 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100001f71 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100001f74 &lt;+4&gt;:  movq   $0x0, -0x8(%rbp)</span><br><span class="line">-&gt;  0x100001f7c &lt;+12&gt;: leaq   0xd(%rip), %rax           ; plus #1 (Swift.Int) -&gt; Swift.Int in testSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at main.swift:23</span><br><span class="line">    0x100001f83 &lt;+19&gt;: xorl   %ecx, %ecx</span><br><span class="line">    0x100001f85 &lt;+21&gt;: movl   %ecx, %edx</span><br><span class="line">    0x100001f87 &lt;+23&gt;: popq   %rbp</span><br><span class="line">    0x100001f88 &lt;+24&gt;: retq</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/7/8/16bcf1fb505d92c2?w=1243&h=825&f=png&s=356842" alt=""></p><p>可知，0xd(%rip), %rax  这段代码，把地址值，也就是getFn() 函数的地址值给了rax,<br>根本没有alloc malloc等代码，也就是说，没有开辟堆空间。那么接下来我们看下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn &#x3D; (Int) -&gt; Int</span><br><span class="line">func getFn() -&gt; Fn&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部变量</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    func plus(_ i: Int) -&gt; Int&#123;</span><br><span class="line"> num +&#x3D; i</span><br><span class="line"> return num </span><br><span class="line">    &#125;</span><br><span class="line">    return plus(_:) &#x2F;&#x2F; 这里打断点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; getFn()</span><br><span class="line">print(fn(1))</span><br><span class="line">print(fn(2))</span><br><span class="line">print(fn(3))</span><br></pre></td></tr></table></figure><p>断点如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">testSwift&#96;getFn():</span><br><span class="line">    0x100001de0 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100001de1 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100001de4 &lt;+4&gt;:  subq   $0x20, %rsp</span><br><span class="line">    0x100001de8 &lt;+8&gt;:  leaq   0x3301(%rip), %rdi</span><br><span class="line">    0x100001def &lt;+15&gt;: movl   $0x18, %esi</span><br><span class="line">    0x100001df4 &lt;+20&gt;: movl   $0x7, %edx</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 这里swift_allocObject 说明产生了堆空间</span><br><span class="line">    0x100001df9 &lt;+25&gt;: callq  0x1000046f8        ; symbol stub for: swift_allocObject</span><br><span class="line">    0x100001dfe &lt;+30&gt;: movq   %rax, %rdx</span><br><span class="line">    0x100001e01 &lt;+33&gt;: addq   $0x10, %rdx</span><br><span class="line">    0x100001e05 &lt;+37&gt;: movq   %rdx, %rsi</span><br><span class="line">    0x100001e08 &lt;+40&gt;: movq   $0x0, 0x10(%rax)</span><br><span class="line">-&gt;  0x100001e10 &lt;+48&gt;: movq   %rax, %rdi</span><br><span class="line">    0x100001e13 &lt;+51&gt;: movq   %rax, -0x8(%rbp)</span><br><span class="line">    0x100001e17 &lt;+55&gt;: movq   %rdx, -0x10(%rbp)</span><br><span class="line">    0x100001e1b &lt;+59&gt;: callq  0x100004758         ; symbol stub for: swift_retain</span><br><span class="line">    0x100001e20 &lt;+64&gt;: movq   -0x8(%rbp), %rdi</span><br><span class="line">    0x100001e24 &lt;+68&gt;: movq   %rax, -0x18(%rbp)</span><br><span class="line">    0x100001e28 &lt;+72&gt;: callq  0x100004752         ; symbol stub for: swift_release</span><br><span class="line">    0x100001e2d &lt;+77&gt;: movq   -0x10(%rbp), %rax</span><br><span class="line">    0x100001e31 &lt;+81&gt;: leaq   0x178(%rip), %rax   ; partial apply forwarder for plus #1 (Swift.Int) -&gt; Swift.Int in testSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at &lt;compiler-generated&gt;</span><br><span class="line">    0x100001e38 &lt;+88&gt;: movq   -0x8(%rbp), %rdx</span><br><span class="line">    0x100001e3c &lt;+92&gt;: addq   $0x20, %rsp</span><br><span class="line">    0x100001e40 &lt;+96&gt;: popq   %rbp</span><br><span class="line">    0x100001e41 &lt;+97&gt;: retq</span><br></pre></td></tr></table></figure><p>进一步验证，下面的代码是因为，写文章的时候，重新跑了一遍，所以函数 getFn() 函数的抵制和截图不一致，是</p><blockquote><p>rax = 0x0000000101849fd0</p></blockquote><p>这次我们在 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn &#x3D; (Int) -&gt; Int</span><br><span class="line">func getFn() -&gt; Fn&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部变量</span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    func plus(_ i: Int) -&gt; Int&#123;</span><br><span class="line"> num +&#x3D; i</span><br><span class="line"> return num  &#x2F;&#x2F; 第二次这里打断点 查看getFn()地址的内容</span><br><span class="line">    &#125;</span><br><span class="line">    return plus(_:) &#x2F;&#x2F; 第一次这里打断点 获取getFn()地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; getFn()</span><br><span class="line">print(fn(1)) </span><br><span class="line">print(fn(2))</span><br><span class="line">print(fn(3))</span><br></pre></td></tr></table></figure><p>因为调用了三次 fn分别为 fn(1) 、 fn(2)、fn(3)，所以在 return num 地方，会断三次<br>我们分别查看函数getFn() 函数地址的内容</p><p>结果如图<br><img src="https://user-gold-cdn.xitu.io/2019/7/8/16bcf1fb506737cb?w=1139&h=886&f=png&s=362546" alt=""></p><p>图中可知，确实是操作同一块堆空间，而且之前<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%B1%BB.html">Swift之类</a>中讲过，前面16个字节，分别存放 类的信息，引用技术，然后后面才是值，可知，</p><p>刚开始分配完，堆空间里面是垃圾数据<br>执行完 print(fn(1))  之后，堆空间里面放的是1<br>执行完 print(fn(2))  之后，堆空间里面放的是3<br>执行完 print(fn(3))  之后，堆空间里面放的是6</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这也解释了，文章开头的那个疑问，因为闭包捕获了局部变量，在堆中开辟空间，然后后面调用的时候，操作的是堆空间的内存，所以结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>关于汇编的调试指令可以参考</p><p><a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93.html">汇编总结</a></p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p><p><a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93.html">汇编总结</a></p><p><a href="https://juejin.im/post/5d229738f265da1b715317b7" target="_blank" rel="noopener">Swift之闭包(Closure)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8E%A2%E7%A9%B6%E9%97%AD%E5%8C%85%E6%9C%A
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之闭包(Closure)</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/</id>
    <published>2019-07-25T00:32:24.000Z</published>
    <updated>2019-12-12T06:21:30.208Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E9%97%AD%E5%8C%85(Closure).html">我的个人博客</a></p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><ul><li>一个函数和它所捕获的变量\常量环境组合起来，称为闭包<ul><li>一般指定义在函数内部的函数</li><li>一般它捕获的是外层函数的局部变量\常量</li></ul></li><li>可以把闭包想象成是一个类的实例对象<ul><li>内存在堆空间</li><li>捕获的局部变量\常量就是对象的成员(存储属性) </li><li>组成闭包的函数就是类内部定义的方法</li></ul></li></ul><p>eg:<br>我们有一个函数 sum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数</span><br><span class="line">func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">sum(10, 20)</span><br></pre></td></tr></table></figure><p>如果用闭包表达式定义一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; &#123;</span><br><span class="line">    (v1: Int, v2: Int) -&gt; Int in</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">fn(10, 20)</span><br></pre></td></tr></table></figure><p>当然了，也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (v1: Int, v2: Int) -&gt; Int in</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;(10, 20)</span><br></pre></td></tr></table></figure><p>总结起来就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (参数列表) -&gt; 返回值类型 in 函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包表达式的简写"><a href="#闭包表达式的简写" class="headerlink" title="闭包表达式的简写"></a>闭包表达式的简写</h2><p>我们定义如下的函数 exec ，它接收三个参数，分别为两个Int 和一个函数，而且这个函数，接收两个Int 参数，返回一个Int结果，exec 的作用就是，把前两个参数传给第三个参数(也就是函数)去执行，然后结果打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数 我们定义如下的函数 exec ，它接收三个参数，分别为两个Int 和一个函数，而且这个函数，接收两个Int 参数，返回一个Int结果，exec 的作用就是，把前两个参数传给第三个参数(也就是函数)去执行，然后结果打印出来</span><br><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1, v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用闭包表达式来定义的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 闭包表达式</span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123;</span><br><span class="line">    (v1: Int, v2: Int) -&gt; Int in</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然了，我们可以省略很多，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略参数类型 因为swift可以自己推断类型</span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123;</span><br><span class="line">    v1, v2 in return v1 + v2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; return 也可以省略</span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123;</span><br><span class="line">    v1, v2 in v1 + v2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略掉参数列表，用$0代表第0个参数，$1代表第1个参数</span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123;</span><br><span class="line">    $0 + $1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 终极省略</span><br><span class="line">exec(v1: 10, v2: 20, fn: +)</span><br></pre></td></tr></table></figure><h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul><li>如果将一个很长的闭包表达式作为函数的最后一个实参，使用尾随闭包可以增强函数的可读性<ul><li>尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式</li></ul></li></ul><p>有如下的函数 闭包表达式作为函数的最后一个实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1, v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用尾随闭包为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec(v1: 10, v2: 20) &#123;</span><br><span class="line">    $0 + $1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，那就不需要在函数名后边写圆括号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个闭包表达式表达式是函数的唯一实参</span><br><span class="line">func exec(fn: (Int, Int) -&gt; Int) &#123; </span><br><span class="line">print(fn(1, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用尾随闭包如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用尾随闭包如下三种都可以</span><br><span class="line">exec(fn: &#123; $0 + $1 &#125;)</span><br><span class="line">exec() &#123; $0 + $1 &#125;</span><br><span class="line">exec &#123; $0 + $1 &#125;</span><br></pre></td></tr></table></figure><h2 id="尾随闭包实战"><a href="#尾随闭包实战" class="headerlink" title="尾随闭包实战"></a>尾随闭包实战</h2><h3 id="系统自带的排序"><a href="#系统自带的排序" class="headerlink" title="系统自带的排序"></a>系统自带的排序</h3><p>假设我们有个包含Int元素的数组，想对立面的元素进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func numberSort()  &#123;</span><br><span class="line">    var arr &#x3D; [6, 8, 1, 10]</span><br><span class="line">    arr.sort()</span><br><span class="line">    print(arr) &#x2F;&#x2F;[1, 6, 8, 10]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numberSort()</span><br></pre></td></tr></table></figure><p>打印结果为</p><blockquote><p>[1, 6, 8, 10]</p></blockquote><p>查看官方对sort的源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 官方代码</span><br><span class="line">func sort(by areInIncreasingOrder: (Element, Element) -&gt; Bool)</span><br></pre></td></tr></table></figure><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><p>假如我们想自定义排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 返回true: i1排在i2前面</span><br><span class="line">&#x2F;&#x2F;&#x2F; 返回false: i1排在i2后面</span><br><span class="line">func cmp(i1: Int, i2: Int) -&gt; Bool &#123;</span><br><span class="line">    &#x2F;&#x2F; 大的排在前面</span><br><span class="line">    return i1 &gt; i2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var nums &#x3D; [6, 8, 1, 10]</span><br><span class="line">nums.sort(by: cmp)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure><p>打印结果为</p><blockquote><p>[10, 8, 6, 1]</p></blockquote><h3 id="用尾随闭包书写"><a href="#用尾随闭包书写" class="headerlink" title="用尾随闭包书写"></a>用尾随闭包书写</h3><p>上面的代码 </p><p>可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nums.sort(by: &#123;</span><br><span class="line">    (i1: Int, i2: Int) -&gt; Bool in</span><br><span class="line">    return i1 &gt; i2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以等价于下面几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nums.sort(by: &#123; i1, i2 in return i1 &gt; i2 &#125;)</span><br><span class="line">nums.sort(by: &#123; i1, i2 in i1 &gt; i2 &#125;)</span><br><span class="line">nums.sort(by: &#123; $0 &gt; $1 &#125;)</span><br><span class="line">nums.sort(by: &gt; )</span><br><span class="line">nums.sort() &#123; $0 &gt; $1 &#125;</span><br><span class="line">nums.sort &#123; $0 &gt; $1 &#125;</span><br></pre></td></tr></table></figure><h2 id="忽略参数"><a href="#忽略参数" class="headerlink" title="忽略参数"></a>忽略参数</h2><p>Swift中，很多时候，如果我们对于参数不做处理，可以用 下划线 _ 来代替</p><p>例如下面的闭包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func exec(fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(1, 2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(exec&#123;_,_ in 100 &#125;)  &#x2F;&#x2F; 100</span><br></pre></td></tr></table></figure><p>输出  </p><blockquote><p>100</p></blockquote><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>假设我们定义一个这样的函数，要求 如果第1个数大于0，返回第一个数。否则返回第2个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func getFirstPositive(_ v1: Int, _ v2:  Int) -&gt; Int? &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">getFirstPositive(10, 20) &#x2F;&#x2F; 10</span><br><span class="line">getFirstPositive(-2, 20) &#x2F;&#x2F; 20</span><br><span class="line">getFirstPositive(0, -4) &#x2F;&#x2F; -4</span><br></pre></td></tr></table></figure><p>现在假如说，我们这么传入的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func getNum() -&gt; Int &#123;</span><br><span class="line">&#x2F;&#x2F; 这里每次都执行</span><br><span class="line">    let a &#x3D; 100</span><br><span class="line">    let b &#x3D; 200</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getFirstPositive2(_ v1: Int, _ v2:  Int) -&gt; Int? &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10, getNum())</span><br></pre></td></tr></table></figure><h3 id="改成函数类型的参数"><a href="#改成函数类型的参数" class="headerlink" title="改成函数类型的参数"></a>改成函数类型的参数</h3><p>因为第一个参数已经是10 大于0了，第二个参数，也就是getNum() 根本没必要去执行，浪费性能，所以，有没有什么办法能做到，当第一个参数不满足时候，才去执行getNum()呢？答案是有的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 改成函数类型的参数，可以让v2延迟加载</span><br><span class="line">func getFirstPositive2(_ v1: Int, _ v2: () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">&#x2F;&#x2F; 这里判断 v1 &gt; 0 不会调用 v2()</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10, &#123;</span><br><span class="line">&#x2F;&#x2F; 第一个参数大于0的时候，这里不会执行</span><br><span class="line">    let a &#x3D; 100</span><br><span class="line">    let b &#x3D; 200</span><br><span class="line">    return a + b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>如果改成这样写就报错了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; 改成函数类型的参数，可以让v2延迟加载</span><br><span class="line">func getFirstPositive2(_ v1: Int, _ v2: () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">&#x2F;&#x2F; 这里判断 v1 &gt; 0 不会调用 v2()</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10,  20) &#x2F;&#x2F;报错 Cannot convert value of type &#39;Int&#39; to expected argument type &#39;() -&gt; Int&#39;</span><br></pre></td></tr></table></figure><p>因为需要的是() -&gt; Int类型，给的是Int</p><p>我们可以写成下面两种都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; 改成函数类型的参数，可以让v2延迟加载</span><br><span class="line">func getFirstPositive2(_ v1: Int, _ v2: () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">&#x2F;&#x2F; 这里判断 v1 &gt; 0 不会调用 v2()</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10) &#123; 20&#125;</span><br><span class="line"></span><br><span class="line">getFirstPositive2(10, &#123;20&#125;)</span><br></pre></td></tr></table></figure><h3 id="autoclosure"><a href="#autoclosure" class="headerlink" title="@autoclosure"></a>@autoclosure</h3><p>上面的也可以用自动闭包技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func getFirstPositive3(_ v1: Int, _ v2: @autoclosure () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line">getFirstPositive3(-4, 20)</span><br></pre></td></tr></table></figure><h3 id="需要的注意点："><a href="#需要的注意点：" class="headerlink" title="需要的注意点："></a>需要的注意点：</h3><ul><li>为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行</li><li>@autoclosure 会自动将 20 封装成闭包 { 20 }</li><li>@autoclosure 只支持 () -&gt; T 格式的参数 n@autoclosure 并非只支持最后1个参数</li><li>空合并运算符 ?? 使用了 @autoclosure 技术</li><li>有@autoclosure、无@autoclosure，构成了函数重载</li></ul><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E9%97%AD%E5%8C%85(Closure).html&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot;
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之结构体</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2019-07-16T00:32:24.000Z</published>
    <updated>2019-12-12T06:20:27.548Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift之结构体.html">我的个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分 <ul><li>比如Bool、Int、Double、 String、Array、Dictionary等常见类型都是结构体</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Date &#123;</span><br><span class="line">var year: Int</span><br><span class="line">var month: Int</span><br><span class="line">var day: Int</span><br><span class="line">&#125;</span><br><span class="line">var date &#x3D; Date(year: 2019, month: 6, day: 23)</span><br></pre></td></tr></table></figure><ul><li>所有的结构体都有一个编译器自动生成的初始化器(initializer，初始化方法、构造器、构造方法) <ul><li>在最后一行调用的，可以传入所有成员值，用以初始化所有成员(存储属性，Stored Property)</li></ul></li></ul><h2 id="结构体的初始化器"><a href="#结构体的初始化器" class="headerlink" title="结构体的初始化器"></a>结构体的初始化器</h2><ul><li>编译器会根据情况，可能会为结构体生成多个初始化器，宗旨是:保证所有成员都有初始值</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">var p2 &#x3D; Point(y: 20) &#x2F;&#x2F;报错 Missing argument for parameter &#39;x&#39; in call</span><br><span class="line">var p3 &#x3D; Point(x: 10) &#x2F;&#x2F;报错 Missing argument for parameter &#39;y&#39; in call</span><br><span class="line">var p4 &#x3D; Point()    &#x2F;&#x2F;报错 Missing argument for parameter &#39;x&#39; in call</span><br></pre></td></tr></table></figure><p>如果给定一个初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int &#x3D; 10</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">var p2 &#x3D; Point(y: 20)</span><br><span class="line">var p3 &#x3D; Point(x: 10) &#x2F;&#x2F;报错 Missing argument for parameter &#39;y&#39; in call</span><br><span class="line">var p4 &#x3D; Point()    &#x2F;&#x2F;报错 Missing argument for parameter &#39;y&#39; in call</span><br></pre></td></tr></table></figure><p>如果x 和 y都有初始值的话，就怎么都不会报错了，因为 所有成员都有初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int &#x3D; 10</span><br><span class="line">    var y: Int &#x3D; 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">var p2 &#x3D; Point(y: 20)</span><br><span class="line">var p3 &#x3D; Point(x: 10) </span><br><span class="line">var p4 &#x3D; Point()</span><br></pre></td></tr></table></figure><p>初始值为nil的话，也可以编译通过，比如下面这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int?</span><br><span class="line">    var y: Int?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">var p2 &#x3D; Point(y: 20)</span><br><span class="line">var p3 &#x3D; Point(x: 10) </span><br><span class="line">var p4 &#x3D; Point()</span><br></pre></td></tr></table></figure><h2 id="自定义初始化器"><a href="#自定义初始化器" class="headerlink" title="自定义初始化器"></a>自定义初始化器</h2><ul><li>一旦在定义结构体时自定义了初始化器，编译器就不会再帮它自动生成其他初始化器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point&#123;</span><br><span class="line">    var x: Int &#x3D; 10</span><br><span class="line">    var y: Int &#x3D; 20</span><br><span class="line">    init(x: Int, y: Int) &#123;</span><br><span class="line">        self.x &#x3D; x</span><br><span class="line">        self.y &#x3D; y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">var p2 &#x3D; Point(y: 20) &#x2F;&#x2F;报错 Missing argument for parameter &#39;x&#39; in call</span><br><span class="line">var p3 &#x3D; Point(x: 10) &#x2F;&#x2F;报错 Missing argument for parameter &#39;y&#39; in call</span><br><span class="line">var p4 &#x3D; Point()    &#x2F;&#x2F;报错 Missing argument for parameter &#39;x&#39; in call</span><br></pre></td></tr></table></figure><h2 id="窥探初始化器的本质"><a href="#窥探初始化器的本质" class="headerlink" title="窥探初始化器的本质"></a>窥探初始化器的本质</h2><h3 id="以下2段代码完全等效"><a href="#以下2段代码完全等效" class="headerlink" title="以下2段代码完全等效"></a>以下2段代码完全等效</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int &#x3D; 0</span><br><span class="line">var y: Int &#x3D; 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">init() &#123; </span><br><span class="line">x&#x3D;0 </span><br><span class="line">y&#x3D;0</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func test()&#123;</span><br><span class="line">    struct Point &#123;</span><br><span class="line">        var x: Int &#x3D; 0</span><br><span class="line">        var y: Int &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    let p &#x3D; Point() &#x2F;&#x2F;这一行打断点</span><br><span class="line">    print(p)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func test()&#123;</span><br><span class="line">    struct Point &#123;</span><br><span class="line">        var x: Int </span><br><span class="line">        var y: Int </span><br><span class="line">      init() &#123;</span><br><span class="line">           x&#x3D;0</span><br><span class="line">            y&#x3D;0</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let p &#x3D; Point() &#x2F;&#x2F;这一行打断点</span><br><span class="line">    print(p)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>查看汇编，两段代码都是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">testSwift&#96;init() in Point #1 in test():</span><br><span class="line">-&gt;  0x100001d50 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100001d51 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100001d54 &lt;+4&gt;:  xorps  %xmm0, %xmm0</span><br><span class="line">    0x100001d57 &lt;+7&gt;:  movaps %xmm0, -0x10(%rbp)</span><br><span class="line">    0x100001d5b &lt;+11&gt;: movq   $0x0, -0x10(%rbp)</span><br><span class="line">    0x100001d63 &lt;+19&gt;: movq   $0x0, -0x8(%rbp)</span><br><span class="line">    0x100001d6b &lt;+27&gt;: xorl   %eax, %eax</span><br><span class="line">    0x100001d6d &lt;+29&gt;: movl   %eax, %ecx</span><br><span class="line">    0x100001d6f &lt;+31&gt;: movq   %rcx, %rax</span><br><span class="line">    0x100001d72 &lt;+34&gt;: movq   %rcx, %rdx</span><br><span class="line">    0x100001d75 &lt;+37&gt;: popq   %rbp</span><br><span class="line">    0x100001d76 &lt;+38&gt;: retq</span><br></pre></td></tr></table></figure><p>这两段代码的汇编一样的，也就是说，这两段代码完全等效</p><h2 id="结构体的内存结构"><a href="#结构体的内存结构" class="headerlink" title="结构体的内存结构"></a>结构体的内存结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">       var x: Int &#x3D; 0</span><br><span class="line">       var y: Int &#x3D; 0</span><br><span class="line">       var origin: Bool &#x3D; true</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">print(MemoryLayout&lt;Point&gt;.size)</span><br><span class="line">print(MemoryLayout&lt;Point&gt;.stride)</span><br><span class="line">print(MemoryLayout&lt;Point&gt;.alignment)</span><br></pre></td></tr></table></figure><p>打印结果为</p><blockquote><p>17</p></blockquote><blockquote><p>24</p></blockquote><blockquote><p>8</p></blockquote><p>是因为内存对齐的缘故，17是因为 实际使用的是 8+8+1 = 17<br>24 是因为，要内存对齐，8*3 = 24</p><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p><p><a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift之结构体.html&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之类</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E7%B1%BB/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E7%B1%BB/</id>
    <published>2019-07-08T00:32:24.000Z</published>
    <updated>2019-12-12T06:19:53.749Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发于<a href="https://ityongzhen.github.io/Swift之类.html">我的个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器<br>eg 如下代码不会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int &#x3D; 0</span><br><span class="line">var y: Int &#x3D; 0 </span><br><span class="line">&#125;</span><br><span class="line">let p1 &#x3D; Point()</span><br><span class="line">let p2 &#x3D; Point(x: 10, y: 20)</span><br><span class="line">let p3 &#x3D; Point(x: 10)</span><br><span class="line">let p4 &#x3D; Point(y: 20)</span><br></pre></td></tr></table></figure><p>但是如果改成了类就不能编译通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x: Int &#x3D; 0</span><br><span class="line">    var y: Int &#x3D; 0</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">let p1 &#x3D; Point()</span><br><span class="line">let p2 &#x3D; Point(x: 10, y: 20)&#x2F;&#x2F;报错Argument passed to call that takes no arguments</span><br><span class="line">let p3 &#x3D; Point(x: 10)&#x2F;&#x2F;报错Argument passed to call that takes no arguments</span><br><span class="line">let p4 &#x3D; Point(y: 20)&#x2F;&#x2F;报错Argument passed to call that takes no arguments</span><br></pre></td></tr></table></figure><h2 id="类的初始化器"><a href="#类的初始化器" class="headerlink" title="类的初始化器"></a>类的初始化器</h2><ul><li>如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器  </li><li>成员的初始化是在这个初始化器中完成的</li></ul><h3 id="以下2段代码完全等效"><a href="#以下2段代码完全等效" class="headerlink" title="以下2段代码完全等效"></a>以下2段代码完全等效</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int &#x3D; 0</span><br><span class="line">var y: Int &#x3D; 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">init() &#123; </span><br><span class="line">x&#x3D;0 </span><br><span class="line">y&#x3D;0</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体与类的本质区别"><a href="#结构体与类的本质区别" class="headerlink" title="结构体与类的本质区别"></a>结构体与类的本质区别</h2><h3 id="结构体是值类型-枚举也是值类型-，类是引用类型-指针类型"><a href="#结构体是值类型-枚举也是值类型-，类是引用类型-指针类型" class="headerlink" title="结构体是值类型(枚举也是值类型)，类是引用类型(指针类型)"></a>结构体是值类型(枚举也是值类型)，类是引用类型(指针类型)</h3><p>eg:我们有如下的结构体point 和类 size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类size</span><br><span class="line">class Size &#123;</span><br><span class="line">    var width &#x3D; 1</span><br><span class="line">    var height &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类 Point</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 3</span><br><span class="line">    var y &#x3D; 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 变量 size 接收类Size</span><br><span class="line">var size &#x3D; Size()</span><br><span class="line">&#x2F;&#x2F; 变量 point 接收结构体point</span><br><span class="line">var point &#x3D; Point()</span><br></pre></td></tr></table></figure><p>我们假设 执行完test() 之后，point的内存地址为 0x10000 size的内存地址为 0x10010<br>可以用一幅图来表示</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bca935cf3172a9?w=923&h=410&f=png&s=139924" alt=""></p><p>上图表示，point是值拷贝，直接把  3 和 4 放在了point对应的内存中，而 指针变量size是引用拷贝，是放了 Size() 的指针 0x90000 ，而对应的 堆空间 0x90000中才真正的存放1和2，当然了，前面有16个字节，存放了类的信息，和引用计数，因为Swift和OC一样使用的引用计数来内存管理的，所以Size对象用了32个字节</p><h3 id="汇编验证"><a href="#汇编验证" class="headerlink" title="汇编验证"></a>汇编验证</h3><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unc test1()&#123;</span><br><span class="line">    &#x2F;&#x2F; 类size</span><br><span class="line">    class Size &#123;</span><br><span class="line">        var width &#x3D; 1</span><br><span class="line">        var height &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 类 Point</span><br><span class="line">    struct Point &#123;</span><br><span class="line">        var x &#x3D; 3</span><br><span class="line">        var y &#x3D; 4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 变量 point 接收结构体point</span><br><span class="line">    var point &#x3D; Point()</span><br><span class="line">     &#x2F;&#x2F; 变量 size 接收类Size</span><br><span class="line">    var size &#x3D; Size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><h4 id="汇编验证验证结构体"><a href="#汇编验证验证结构体" class="headerlink" title="汇编验证验证结构体"></a>汇编验证验证结构体</h4><p>上面的代码，先在 var point = Point() 处打断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">testSwift&#96;__allocating_init() in Size #1 in test1():</span><br><span class="line">    0x100001030 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100001031 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100001034 &lt;+4&gt;:  pushq  %r13</span><br><span class="line">    0x100001036 &lt;+6&gt;:  subq   $0x18, %rsp</span><br><span class="line">    0x10000103a &lt;+10&gt;: xorl   %eax, %eax</span><br><span class="line">    0x10000103c &lt;+12&gt;: movl   %eax, %edi</span><br><span class="line">-&gt;  0x10000103e &lt;+14&gt;: callq  0x100001250               ; type metadata accessor for Size #1 in testSwift.test1() -&gt; () at &lt;compiler-generated&gt;</span><br><span class="line">    0x100001043 &lt;+19&gt;: movl   $0x20, %ecx</span><br><span class="line">    0x100001048 &lt;+24&gt;: movl   %ecx, %esi</span><br><span class="line">    0x10000104a &lt;+26&gt;: movl   $0x7, %ecx</span><br><span class="line">    0x10000104f &lt;+31&gt;: movl   %ecx, %edi</span><br><span class="line">    0x100001051 &lt;+33&gt;: movq   %rdi, -0x10(%rbp)</span><br><span class="line">    0x100001055 &lt;+37&gt;: movq   %rax, %rdi</span><br><span class="line">    0x100001058 &lt;+40&gt;: movq   -0x10(%rbp), %rax</span><br><span class="line">    0x10000105c &lt;+44&gt;: movq   %rdx, -0x18(%rbp)</span><br><span class="line">    0x100001060 &lt;+48&gt;: movq   %rax, %rdx</span><br><span class="line">    0x100001063 &lt;+51&gt;: callq  0x100005046               ; symbol stub for: swift_allocObject</span><br><span class="line">    0x100001068 &lt;+56&gt;: movq   %rax, %r13</span><br><span class="line">    0x10000106b &lt;+59&gt;: callq  0x100001e30               ; init() -&gt; Size #1 in testSwift.test1() -&gt; () in Size #1 in testSwift.test1() -&gt; () at main.swift:15</span><br><span class="line">    0x100001070 &lt;+64&gt;: addq   $0x18, %rsp</span><br><span class="line">    0x100001074 &lt;+68&gt;: popq   %r13</span><br><span class="line">    0x100001076 &lt;+70&gt;: popq   %rbp</span><br><span class="line">    0x100001077 &lt;+71&gt;: retq</span><br></pre></td></tr></table></figure><p>从 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x10000103e &lt;+14&gt;: callq  0x100001250 ; type metadata accessor for Size #1 in testSwift.test1() -&gt; () at &lt;compiler-generated&gt;</span><br></pre></td></tr></table></figure><p>处执行lldb命令 si 跟踪进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">testSwift&#96;init() in Point #1 in test1():</span><br><span class="line">-&gt;  0x100001030 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100001031 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100001034 &lt;+4&gt;:  xorps  %xmm0, %xmm0</span><br><span class="line">    0x100001037 &lt;+7&gt;:  movaps %xmm0, -0x10(%rbp)</span><br><span class="line">    0x10000103b &lt;+11&gt;: movq   $0x3, -0x10(%rbp)</span><br><span class="line">    0x100001043 &lt;+19&gt;: movq   $0x4, -0x8(%rbp)</span><br><span class="line">    0x10000104b &lt;+27&gt;: movl   $0x3, %eax</span><br><span class="line">    0x100001050 &lt;+32&gt;: movl   $0x4, %ecx</span><br><span class="line">    0x100001055 &lt;+37&gt;: movl   %ecx, %edx</span><br><span class="line">    0x100001057 &lt;+39&gt;: popq   %rbp</span><br><span class="line">    0x100001058 &lt;+40&gt;: retq</span><br></pre></td></tr></table></figure><p>可以看到赋值操作 直接是把 $0x3 和 $0x4 赋值给栈空间 (-0x10(%rbp) 和 -0x8(%rbp) )的，没有调用malloc alloc 等方法，也就是没有开辟堆空间</p><h4 id="汇编验证验证类"><a href="#汇编验证验证类" class="headerlink" title="汇编验证验证类"></a>汇编验证验证类</h4><p>上面的代码，先在 var size = Size() 处打断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0x100000fe0 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100000fe1 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100000fe4 &lt;+4&gt;:  pushq  %r13</span><br><span class="line">    0x100000fe6 &lt;+6&gt;:  subq   $0x28, %rsp</span><br><span class="line">    0x100000fea &lt;+10&gt;: movq   $0x0, -0x10(%rbp)</span><br><span class="line">    0x100000ff2 &lt;+18&gt;: xorps  %xmm0, %xmm0</span><br><span class="line">    0x100000ff5 &lt;+21&gt;: movaps %xmm0, -0x20(%rbp)</span><br><span class="line">    0x100000ff9 &lt;+25&gt;: xorl   %eax, %eax</span><br><span class="line">    0x100000ffb &lt;+27&gt;: movl   %eax, %edi</span><br><span class="line">-&gt;  0x100000ffd &lt;+29&gt;: callq  0x100001250               ; type metadata accessor for Size #1 in testSwift.test1() -&gt; () at &lt;compiler-generated&gt;</span><br><span class="line">    0x100001002 &lt;+34&gt;: movq   %rax, %r13</span><br><span class="line">    0x100001005 &lt;+37&gt;: movq   %rdx, -0x28(%rbp)</span><br><span class="line">    0x100001009 &lt;+41&gt;: callq  0x100001030               ; __allocating_init() -&gt; Size #1 in testSwift.test1() -&gt; () in Size #1 in testSwift.test1() -&gt; () at main.swift:15</span><br><span class="line">    0x10000100e &lt;+46&gt;: movq   %rax, -0x10(%rbp)</span><br><span class="line">    0x100001012 &lt;+50&gt;: callq  0x100001080               ; init() -&gt; Point #1 in testSwift.test1() -&gt; () in Point #1 in testSwift.test1() -&gt; () at main.swift:21</span><br><span class="line">    0x100001017 &lt;+55&gt;: movq   %rax, -0x20(%rbp)</span><br><span class="line">    0x10000101b &lt;+59&gt;: movq   %rdx, -0x18(%rbp)</span><br><span class="line">    0x10000101f &lt;+63&gt;: movq   -0x10(%rbp), %rdi</span><br><span class="line">    0x100001023 &lt;+67&gt;: callq  0x1000050ac               ; symbol stub for: swift_release</span><br><span class="line">    0x100001028 &lt;+72&gt;: addq   $0x28, %rsp</span><br><span class="line">    0x10000102c &lt;+76&gt;: popq   %r13</span><br><span class="line">    0x10000102e &lt;+78&gt;: popq   %rbp</span><br><span class="line">    0x10000102f &lt;+79&gt;: retq</span><br></pre></td></tr></table></figure><p>进入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x100001009 &lt;+41&gt;: callq  0x100001030               ; __allocating_init() -&gt; Size #1 in testSwift.test1() -&gt; () in Size #1 in testSwift.test1() -&gt; () at main.swift:15</span><br></pre></td></tr></table></figure><p>一路跟踪进入，最终来到了如下图所示位置</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bca935cf4541ea?w=812&h=499&f=png&s=235950" alt=""></p><p>也就是确实分配了堆空间，验证了我们前面的结论</p><h2 id="对象的堆空间申请过程"><a href="#对象的堆空间申请过程" class="headerlink" title="对象的堆空间申请过程"></a>对象的堆空间申请过程</h2><ul><li>在Swift中，创建类的实例对象，要向堆空间申请内存，大概流程如下 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.__allocating_init() </span><br><span class="line">libswiftCore.dylib:_swift_allocObject_ </span><br><span class="line">libswiftCore.dylib:swift_slowAlloc </span><br><span class="line">libsystem_malloc.dylib:malloc</span><br></pre></td></tr></table></figure><ul><li>在Mac、iOS中的malloc函数分配的内存大小总是16的倍数</li><li>通过class_getInstanceSize可以得知:类的对象至少需要占用多少内存</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point  &#123;</span><br><span class="line">    var x &#x3D; 11</span><br><span class="line">    var test &#x3D; true</span><br><span class="line">var y &#x3D; 22 </span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; Point() </span><br><span class="line">class_getInstanceSize(type(of: p)) &#x2F;&#x2F; 40</span><br><span class="line">class_getInstanceSize(Point.self) &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><ul><li><p>值类型赋值给var、let或者给函数传参，是直接将所有内容拷贝一份 </p></li><li><p>类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝(deep copy)</p></li><li><p>在Swift标准库中，为了提升性能，String、Array、Dictionary、Set采取了Copy On Write的技术 </p><ul><li>比如仅当有“写”操作时，才会真正执行拷贝操作<ul><li>对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</li></ul></li></ul></li><li><p>建议:不需要修改的，尽量定义成let</p></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>引用赋值给var、let或者给函数传参，是将内存地址拷贝一份 </li><li>类似于制作一个文件的替身(快捷方式、链接)，指向的是同一个文件。属于浅拷贝(shallow copy)</li></ul><h2 id="枚举、结构体、类都可以定义方法"><a href="#枚举、结构体、类都可以定义方法" class="headerlink" title="枚举、结构体、类都可以定义方法"></a>枚举、结构体、类都可以定义方法</h2><h3 id="一般把定义在枚举、结构体、类内部的函数，叫做方法"><a href="#一般把定义在枚举、结构体、类内部的函数，叫做方法" class="headerlink" title="一般把定义在枚举、结构体、类内部的函数，叫做方法"></a>一般把定义在枚举、结构体、类内部的函数，叫做方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类中定义方法</span><br><span class="line">class Size &#123;</span><br><span class="line">    var width &#x3D; 10</span><br><span class="line">    var height &#x3D; 10</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width&#x3D;\(width), height&#x3D;\(height)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s &#x3D; Size()</span><br><span class="line">s.show() &#x2F;&#x2F; width&#x3D;10, height&#x3D;10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结构体中定义方法</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x &#x3D; 10</span><br><span class="line">    var y &#x3D; 10</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;x&#x3D;\(x), y&#x3D;\(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D; Point()</span><br><span class="line">p.show() &#x2F;&#x2F; x&#x3D;10, y&#x3D;10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 枚举中定义方法</span><br><span class="line">enum grade : Character &#123;</span><br><span class="line">    case a &#x3D; &quot;a&quot;</span><br><span class="line">    case b &#x3D; &quot;b&quot;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;res is \(rawValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let g &#x3D; grade.a</span><br><span class="line">g.show() &#x2F;&#x2F; res is a</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p><p><a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift之类.html&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之可选项</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8F%AF%E9%80%89%E9%A1%B9/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8F%AF%E9%80%89%E9%A1%B9/</id>
    <published>2019-06-30T00:32:24.000Z</published>
    <updated>2019-12-12T06:19:04.296Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>可选项，一般也叫可选类型，它允许将值设置为nil </li><li>在类型名称后面加个问号? 来定义一个可选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name: String? &#x3D; &quot;Jack&quot;</span><br><span class="line">name &#x3D; nil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var age: Int? &#x2F;&#x2F; 默认就是nil </span><br><span class="line">age &#x3D; 10</span><br><span class="line">age &#x3D; nil</span><br></pre></td></tr></table></figure><h2 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h2><ul><li>可选项是对其他类型的一层包装，可以将它理解为一个盒子 <ul><li>如果为nil，那么它是个空盒子 </li><li>如果不为nil，那么盒子里装的是:被包装类型的数据</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var age: Int? &#x2F;&#x2F; 默认就是nil </span><br><span class="line">age &#x3D; 10</span><br><span class="line">age &#x3D; nil</span><br></pre></td></tr></table></figure><ul><li>如果要从可选项中取出被包装的数据(将盒子里装的东西取出来)，需要使用感叹号! 进行强制解包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var age: Int? &#x3D; 10</span><br><span class="line">let ageInt: Int &#x3D; age!</span><br><span class="line">ageInt +&#x3D; 10</span><br></pre></td></tr></table></figure><ul><li>如果对值为nil的可选项(空盒子)进行强制解包，将会产生运行时错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var age: Int?</span><br><span class="line">age!&#x2F;&#x2F; 报错：Fatal error: Unexpectedly found nil while unwrapping an Optional value</span><br></pre></td></tr></table></figure><h2 id="判断可选项是否包含值"><a href="#判断可选项是否包含值" class="headerlink" title="判断可选项是否包含值"></a>判断可选项是否包含值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let number &#x3D; Int(&quot;123&quot;)</span><br><span class="line">if number !&#x3D; nil &#123;</span><br><span class="line">print(&quot;字符串转换整数成功:\(number!)&quot;) </span><br><span class="line">&#125; else &#123;</span><br><span class="line">print(&quot;字符串转换整数失败&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串转换整数成功:123</span><br></pre></td></tr></table></figure><h2 id="可选项绑定"><a href="#可选项绑定" class="headerlink" title="可选项绑定"></a>可选项绑定</h2><ul><li>可以使用可选项绑定来判断可选项是否包含值<ul><li>如果包含就自动解包，把值赋给一个临时的常量(let)或者变量(var)，并返回true，否则返回false</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if let number &#x3D; Int(&quot;123&quot;) &#123;</span><br><span class="line">   print(&quot;字符串转换整数成功:\(number)&quot;) </span><br><span class="line">    &#x2F;&#x2F; number是强制解包之后的Int值</span><br><span class="line">&#x2F;&#x2F; number作用域仅限于这个大括号</span><br><span class="line">&#125; else &#123; </span><br><span class="line">print(&quot;字符串转换整数失败&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串转换整数成功:123</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring &#x3D; 1, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line">if let season &#x3D; Season(rawValue: 6) &#123;</span><br><span class="line">switch season &#123; </span><br><span class="line">case .spring:</span><br><span class="line">        print(&quot;the season is spring&quot;)</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;the season is other&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;no such season&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; no such season</span><br></pre></td></tr></table></figure><h2 id="等价写法"><a href="#等价写法" class="headerlink" title="等价写法"></a>等价写法</h2><p>可选项绑定中，如果多个条件比如下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> if let first &#x3D; Int(&quot;4&quot;) &#123;</span><br><span class="line">    if let second &#x3D; Int(&quot;42&quot;) &#123;</span><br><span class="line">        if first &lt; second &amp;&amp; second &lt; 100 &#123;</span><br><span class="line">            print(&quot;\(first) &lt; \(second) &lt; 100&quot;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 4 &lt; 42 &lt; 100</span><br></pre></td></tr></table></figure><p>可以用 , 分割开，看起来更简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> if let first &#x3D; Int(&quot;4&quot;),</span><br><span class="line">    let second &#x3D; Int(&quot;42&quot;),</span><br><span class="line">    first &lt; second &amp;&amp; second &lt; 100 &#123;</span><br><span class="line">    print(&quot;\(second) &lt; \(second) &lt; 100&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 4 &lt; 42 &lt; 100</span><br></pre></td></tr></table></figure><h2 id="while循环中使用可选项绑定"><a href="#while循环中使用可选项绑定" class="headerlink" title="while循环中使用可选项绑定"></a>while循环中使用可选项绑定</h2><ul><li>有如下需求<br>//遍历数组，将遇到的正数都加起来，如果遇到负数或者非数字，停止遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;遍历数组，将遇到的正数都加起来，如果遇到负数或者非数字，停止遍历</span><br><span class="line">&#x2F;&#x2F; var strs &#x3D; [&quot;10&quot;, &quot;20&quot;, &quot;abc&quot;, &quot;-20&quot;, &quot;30&quot;]</span><br><span class="line"></span><br><span class="line">var index &#x3D; 0</span><br><span class="line">var sum &#x3D; 0</span><br><span class="line">while let num &#x3D; Int(strs[index]), num &gt; 0 &#123;</span><br><span class="line">sum +&#x3D; num</span><br><span class="line">index +&#x3D; 1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h2 id="空合并运算符-Nil-Coalescing-Operator"><a href="#空合并运算符-Nil-Coalescing-Operator" class="headerlink" title="空合并运算符 ??(Nil-Coalescing Operator)"></a>空合并运算符 ??(Nil-Coalescing Operator)</h2><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T?) rethrows -&gt; T?</span><br><span class="line">public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T</span><br></pre></td></tr></table></figure><ul><li>a ?? b<ul><li>a 是可选项</li><li>b 是可选项 或者 不是可选项</li><li>b 跟 a 的存储类型必须相同</li><li>如果 a 不为nil，就返回 a</li><li>如果 a 为nil，就返回 b</li><li>如果 b 不是可选项，返回 a 时会自动解包</li></ul></li></ul><p><strong>规律： 返回的类型取决于b</strong></p><p>举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: Int? &#x3D; 1</span><br><span class="line">let b: Int? &#x3D; 2</span><br><span class="line">let c &#x3D; a ?? b &#x2F;&#x2F; c是Int? , Optional(1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a: Int? &#x3D; 1</span><br><span class="line">let b: Int &#x3D; 2</span><br><span class="line">let c &#x3D; a ?? b &#x2F;&#x2F; c是Int , 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a: Int? &#x3D; nil</span><br><span class="line">let b: Int &#x3D; 2</span><br><span class="line">let c &#x3D; a ?? b &#x2F;&#x2F; c是Int , 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a: Int? &#x3D; nil</span><br><span class="line">let b: Int? &#x3D; 2</span><br><span class="line">let c &#x3D; a ?? b &#x2F;&#x2F; c是Int? , Optional(2)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a: Int? &#x3D; nil </span><br><span class="line">let b: Int &#x3D; 2</span><br><span class="line">&#x2F;&#x2F; 如果不使用??运算符 </span><br><span class="line">let c: Int</span><br><span class="line">if let tmp &#x3D; a &#123;</span><br><span class="line">    c &#x3D; tmp</span><br><span class="line">&#125; else &#123; </span><br><span class="line">c&#x3D;b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 ？？ 运算符</span><br><span class="line">let c &#x3D; a ?? b &#x2F;&#x2F; c是Int? , nil</span><br></pre></td></tr></table></figure><h2 id="多个-一起使用"><a href="#多个-一起使用" class="headerlink" title="多个 ?? 一起使用"></a>多个 ?? 一起使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a: Int? &#x3D; 1</span><br><span class="line">let b: Int? &#x3D; 2</span><br><span class="line">let c &#x3D; a ?? b ?? 3 &#x2F;&#x2F; c是Int , 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: Int? &#x3D; nil</span><br><span class="line">let b: Int? &#x3D; 2</span><br><span class="line">let c &#x3D; a ?? b ?? 3 &#x2F;&#x2F; c是Int , 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: Int? &#x3D; nil</span><br><span class="line">let b: Int? &#x3D; nil</span><br><span class="line">let c &#x3D; a ?? b ?? 3 &#x2F;&#x2F; c是Int , 3</span><br></pre></td></tr></table></figure><h2 id="跟if-let配合使用"><a href="#跟if-let配合使用" class="headerlink" title="??跟if let配合使用"></a>??跟if let配合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a: Int? &#x3D; nil</span><br><span class="line">let b: Int? &#x3D; 2</span><br><span class="line">if let c &#x3D; a ?? b &#123;</span><br><span class="line">print(c) </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 类似于if a !&#x3D; nil || b !&#x3D; nil</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if let c &#x3D; a, let d &#x3D; b &#123;</span><br><span class="line">    print(c)</span><br><span class="line">print(d) </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 类似于if a !&#x3D; nil &amp;&amp; b !&#x3D; nil</span><br></pre></td></tr></table></figure><h2 id="guard语句"><a href="#guard语句" class="headerlink" title="guard语句"></a>guard语句</h2><ul><li>当guard语句的条件为false时，就会执行大括号里面的代码 </li><li>当guard语句的条件为true时，就会跳过guard语句</li><li>guard语句特别适合用来“提前退出”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">guard 条件 else &#123;</span><br><span class="line">&#x2F;&#x2F; do something....</span><br><span class="line">退出当前作用域</span><br><span class="line">&#x2F;&#x2F; return、break、continue、throw error &#125;</span><br></pre></td></tr></table></figure><ul><li>当使用guard语句进行可选项绑定时，绑定的常量(let)、变量(var)也能在外层作用域中使用</li></ul><p>假设我们有个登陆的需求，要求输入账号，密码。缺一不可。</p><h3 id="用if语句书写"><a href="#用if语句书写" class="headerlink" title="用if语句书写"></a>用if语句书写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;if语句实现登陆</span><br><span class="line">func login(_ info: [String : String]) &#123; </span><br><span class="line">let username: String</span><br><span class="line">if let tmp &#x3D; info[&quot;username&quot;] &#123;</span><br><span class="line">        username &#x3D; tmp</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">print(&quot;请输入用户名&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let password: String</span><br><span class="line">if let tmp &#x3D; info[&quot;password&quot;] &#123;</span><br><span class="line">        password &#x3D; tmp</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">print(&quot;请输入密码&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 能来到这里，说明，username和password都是有值的</span><br><span class="line">&#x2F;&#x2F; if username ....</span><br><span class="line">&#x2F;&#x2F; if password ....</span><br><span class="line">print(&quot;用户名:\(username)&quot;, &quot;密码:\(password)&quot;, &quot;登陆ing&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">login([&quot;username&quot; : &quot;jack&quot;, &quot;password&quot; : &quot;123456&quot;]) &#x2F;&#x2F; 用户名:jack 密码:123456 登陆ing </span><br><span class="line"></span><br><span class="line">login([&quot;password&quot; : &quot;123456&quot;]) &#x2F;&#x2F; 请输入密码</span><br><span class="line"></span><br><span class="line">login([&quot;username&quot; : &quot;jack&quot;]) &#x2F;&#x2F; 请输入用户名</span><br></pre></td></tr></table></figure><h3 id="如果用guard来书写"><a href="#如果用guard来书写" class="headerlink" title="如果用guard来书写"></a>如果用guard来书写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func login(_ info: [String : String]) &#123;</span><br><span class="line">guard let username &#x3D; info[&quot;username&quot;] else &#123;</span><br><span class="line">print(&quot;请输入用户名&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let password &#x3D; info[&quot;password&quot;] else &#123;</span><br><span class="line">print(&quot;请输入密码&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if username ....</span><br><span class="line">&#x2F;&#x2F; if password ....</span><br><span class="line">print(&quot;用户名:\(username)&quot;, &quot;密码:\(password)&quot;, &quot;登陆ing&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式解包-Implicitly-Unwrapped-Optional"><a href="#隐式解包-Implicitly-Unwrapped-Optional" class="headerlink" title="隐式解包(Implicitly Unwrapped Optional)"></a>隐式解包(Implicitly Unwrapped Optional)</h2><ul><li>在某些情况下，可选项一旦被设定值之后，就会一直拥有值</li><li>在这种情况下，可以去掉检查，也不必每次访问的时候都进行解包，因为它能确定每次访问的时候都有值 </li><li>可以在类型后面加个感叹号 ! 定义一个隐式解包的可选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let num1: Int! &#x3D; 10</span><br><span class="line">let num2: Int &#x3D; num1</span><br><span class="line">if num1 !&#x3D; nil &#123;</span><br><span class="line">    print(num1 + 6) &#x2F;&#x2F; 16</span><br><span class="line">&#125;</span><br><span class="line">if let num3 &#x3D; num1 &#123;</span><br><span class="line">    print(num3) &#x2F;&#x2F;10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意不能设置为nil</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num1: Int! &#x3D; nil</span><br><span class="line">&#x2F;&#x2F; Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value</span><br><span class="line">let num2: Int &#x3D; num1</span><br></pre></td></tr></table></figure><p><strong>尽量不要使用这个强制解包。<br>除非你设计接口，不希望接收空值，如果别人传Nil过来，直接报错</strong></p><h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><ul><li>可选项在字符串插值或者直接打印时，编译器会发出警告</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var age: Int? &#x3D; 10</span><br><span class="line">print(&quot;My age is \(age)&quot;)</span><br></pre></td></tr></table></figure><ul><li>至少有3种方法消除警告</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> print(&quot;My age is \(age!)&quot;)</span><br><span class="line">&#x2F;&#x2F; My age is 10</span><br><span class="line"></span><br><span class="line"> print(&quot;My age is \(String(describing: age))&quot;)</span><br><span class="line">&#x2F;&#x2F; My age is Optional(10)</span><br><span class="line"></span><br><span class="line"> print(&quot;My age is \(age ?? 0)&quot;)</span><br><span class="line">&#x2F;&#x2F; My age is 10</span><br></pre></td></tr></table></figure><h2 id="多重可选项"><a href="#多重可选项" class="headerlink" title="多重可选项"></a>多重可选项</h2><ul><li>可以使用lldb指令 frame variable –R 或者 fr v –R 查看区别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num1: Int? &#x3D; 10</span><br><span class="line">var num2: Int?? &#x3D; num1</span><br><span class="line">var num3: Int?? &#x3D; 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(num2 &#x3D;&#x3D; num3) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>还有下面这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num1: Int? &#x3D; nil</span><br><span class="line">var num2: Int?? &#x3D; num1</span><br><span class="line">var num3: Int?? &#x3D; nil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(num2 &#x3D;&#x3D; num3) &#x2F;&#x2F; false</span><br><span class="line">(num2 ?? 1) ?? 2 &#x2F;&#x2F; 2</span><br><span class="line">(num3 ?? 1) ?? 2 &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/categories/Swift/&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之枚举</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E6%9E%9A%E4%B8%BE/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E6%9E%9A%E4%B8%BE/</id>
    <published>2019-06-20T00:32:24.000Z</published>
    <updated>2019-12-12T06:18:31.474Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举的基本用法"><a href="#枚举的基本用法" class="headerlink" title="枚举的基本用法"></a>枚举的基本用法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义方向的枚举</span><br><span class="line">enum Direction &#123;</span><br><span class="line">     case north</span><br><span class="line">     case south</span><br><span class="line"> case east</span><br><span class="line"> case west </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面也可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    case north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dir &#x3D; Direction.west </span><br><span class="line">dir &#x3D; Direction.east </span><br><span class="line">dir &#x3D; .north</span><br><span class="line">print(dir) &#x2F;&#x2F; north</span><br></pre></td></tr></table></figure><p>也可以在switch中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch dir &#123; </span><br><span class="line">case .north:</span><br><span class="line">print(&quot;north&quot;) </span><br><span class="line">case .south:</span><br><span class="line">    print(&quot;south&quot;) </span><br><span class="line">case .east:</span><br><span class="line">print(&quot;east&quot;) </span><br><span class="line">case .west:</span><br><span class="line">    print(&quot;west&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><h3 id="有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中"><a href="#有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中" class="headerlink" title="有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中"></a>有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用，可以认为将值直接存入到枚举的内存中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  enum Score &#123;</span><br><span class="line">    case points(Int)</span><br><span class="line">    case grade(Character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var score &#x3D; Score.points(88) </span><br><span class="line">score &#x3D; .grade(&quot;A&quot;)</span><br></pre></td></tr></table></figure><p>如果我们想使用枚举的具体值，可以如下用 i 来保存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  switch score &#123;</span><br><span class="line">case let .points(i):</span><br><span class="line">print(i, &quot;points&quot;) </span><br><span class="line">case let .grade(i):</span><br><span class="line">    print(&quot;grade&quot;, i)</span><br><span class="line">&#125; &#x2F;&#x2F; grade A</span><br></pre></td></tr></table></figure><p>再比如我们想定义日期的枚举值，可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Date &#123;</span><br><span class="line">    case digit(year: Int, month: Int, day: Int)</span><br><span class="line">    case string(String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用的时候，可以直接传年月日，或者传字符串</span><br><span class="line"></span><br><span class="line">var date &#x3D; Date.digit(year: 2011, month: 9, day: 10) </span><br><span class="line">date &#x3D; .string(&quot;2011-09-10&quot;)</span><br><span class="line">switch date &#123;</span><br><span class="line">case .digit(let year, let month, let day):</span><br><span class="line">rint(year, month, day) </span><br><span class="line">case let .string(value):</span><br><span class="line">    print(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="必要时let也可以改为var"><a href="#必要时let也可以改为var" class="headerlink" title="必要时let也可以改为var"></a>必要时let也可以改为var</h3><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><h3 id="枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做-原始值"><a href="#枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做-原始值" class="headerlink" title="枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做:原始值"></a>枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做:原始值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义枚举</span><br><span class="line">enum Grade : String &#123;</span><br><span class="line">    case perfect &#x3D; &quot;A&quot;</span><br><span class="line">    case great &#x3D; &quot;B&quot;</span><br><span class="line">    case good &#x3D; &quot;C&quot;</span><br><span class="line">    case bad &#x3D; &quot;D&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">print(Grade.perfect.rawValue) &#x2F;&#x2F; A </span><br><span class="line">print(Grade.great.rawValue) &#x2F;&#x2F; B </span><br><span class="line">print(Grade.good.rawValue) &#x2F;&#x2F; C </span><br><span class="line">print(Grade.bad.rawValue) &#x2F;&#x2F; D</span><br></pre></td></tr></table></figure><h3 id="注意-原始值不占用枚举变量的内存"><a href="#注意-原始值不占用枚举变量的内存" class="headerlink" title="注意:原始值不占用枚举变量的内存"></a>注意:原始值不占用枚举变量的内存</h3><h2 id="隐式原始值-Implicitly-Assigned-Raw-Values"><a href="#隐式原始值-Implicitly-Assigned-Raw-Values" class="headerlink" title="隐式原始值(Implicitly Assigned Raw Values)"></a>隐式原始值(Implicitly Assigned Raw Values)</h2><h3 id="如果枚举的原始值类型是Int、String，Swift会自动分配原始值"><a href="#如果枚举的原始值类型是Int、String，Swift会自动分配原始值" class="headerlink" title="如果枚举的原始值类型是Int、String，Swift会自动分配原始值"></a>如果枚举的原始值类型是Int、String，Swift会自动分配原始值</h3><h3 id="原始值是-String-类型枚举值"><a href="#原始值是-String-类型枚举值" class="headerlink" title="原始值是 String 类型枚举值"></a>原始值是 String 类型枚举值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义枚举值</span><br><span class="line">  enum Direction : String &#123;</span><br><span class="line">    case north &#x3D; &quot;north&quot;</span><br><span class="line">    case south &#x3D; &quot;south&quot;</span><br><span class="line">    case east &#x3D; &quot;east&quot;</span><br><span class="line">    case west &#x3D; &quot;west&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">enum Direction : String &#123;</span><br><span class="line">    case north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">print(Direction.north) &#x2F;&#x2F; north </span><br><span class="line">print(Direction.north.rawValue) &#x2F;&#x2F; north</span><br></pre></td></tr></table></figure><h3 id="原始值是-Int-类型枚举值"><a href="#原始值是-Int-类型枚举值" class="headerlink" title="原始值是 Int 类型枚举值"></a>原始值是 Int 类型枚举值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line">print(Season.spring.rawValue) &#x2F;&#x2F; 0 </span><br><span class="line">print(Season.summer.rawValue) &#x2F;&#x2F; 1 </span><br><span class="line">print(Season.autumn.rawValue) &#x2F;&#x2F; 2 </span><br><span class="line">print(Season.winter.rawValue) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><h3 id="如果自己指定了原始值"><a href="#如果自己指定了原始值" class="headerlink" title="如果自己指定了原始值"></a>如果自己指定了原始值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring &#x3D; 1, summer, autumn &#x3D; 8, winter</span><br><span class="line">&#125;</span><br><span class="line">print(Season.spring.rawValue) &#x2F;&#x2F; 1 </span><br><span class="line">print(Season.summer.rawValue) &#x2F;&#x2F; 2 </span><br><span class="line">print(Season.autumn.rawValue) &#x2F;&#x2F; 8 </span><br><span class="line">print(Season.winter.rawValue) &#x2F;&#x2F; 9</span><br></pre></td></tr></table></figure><h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><h3 id="递归枚举要加上关键字-indirect"><a href="#递归枚举要加上关键字-indirect" class="headerlink" title="递归枚举要加上关键字 indirect"></a>递归枚举要加上关键字 indirect</h3><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 递归枚举</span><br><span class="line">indirect enum ArithExpr &#123;</span><br><span class="line">case number(Int)</span><br><span class="line">case sum(ArithExpr, ArithExpr)</span><br><span class="line">case difference(ArithExpr, ArithExpr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面的递归枚举和下面的等效</span><br><span class="line"></span><br><span class="line">enum ArithExpr &#123;</span><br><span class="line">case number(Int)</span><br><span class="line">indirect case sum(ArithExpr, ArithExpr) </span><br><span class="line">indirect case difference(ArithExpr, ArithExpr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下列几种使用枚举都是可以的</span><br><span class="line"></span><br><span class="line">let five &#x3D; ArithExpr.number(5)</span><br><span class="line">let four &#x3D; ArithExpr.number(4)</span><br><span class="line">let two &#x3D; ArithExpr.number(2)</span><br><span class="line">let sum &#x3D; ArithExpr.sum(five, four)</span><br><span class="line">let difference &#x3D; ArithExpr.difference(sum, two)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自己写个 calculate 方法，</span><br><span class="line">func calculate(_ expr: ArithExpr) -&gt; Int &#123; </span><br><span class="line">switch expr &#123;</span><br><span class="line">case let .number(value): </span><br><span class="line">return value</span><br><span class="line">case let .sum(left, right):</span><br><span class="line">return calculate(left) + calculate(right)</span><br><span class="line">case let .difference(left, right):</span><br><span class="line">return calculate(left) - calculate(right)</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最终调用，计算差值</span><br><span class="line">calculate(difference)</span><br></pre></td></tr></table></figure><h2 id="MemoryLayout"><a href="#MemoryLayout" class="headerlink" title="MemoryLayout"></a>MemoryLayout</h2><h3 id="可以使用MemoryLayout获取数据类型占用的内存大小"><a href="#可以使用MemoryLayout获取数据类型占用的内存大小" class="headerlink" title="可以使用MemoryLayout获取数据类型占用的内存大小"></a>可以使用MemoryLayout获取数据类型占用的内存大小</h3><h4 id="关联值-1"><a href="#关联值-1" class="headerlink" title="关联值"></a>关联值</h4><ul><li>将关联值直接存入到枚举内存中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义枚举</span><br><span class="line"> enum Password &#123;</span><br><span class="line">    case number(Int, Int, Int, Int)</span><br><span class="line">    case other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Password&gt;.stride &#x2F;&#x2F; 40, 分配占用的空间大小 </span><br><span class="line">MemoryLayout&lt;Password&gt;.size &#x2F;&#x2F; 33, 实际用到的空间大小 4*8 + 1 &#x3D; 33</span><br><span class="line">MemoryLayout&lt;Password&gt;.alignment &#x2F;&#x2F; 8, 对齐参数</span><br></pre></td></tr></table></figure><p>定义变量来使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var pwd &#x3D; Password.number(9, 8, 6, 4)</span><br><span class="line"></span><br><span class="line">MemoryLayout.stride(ofValue: pwd) &#x2F;&#x2F; 40</span><br><span class="line">MemoryLayout.size(ofValue: pwd) &#x2F;&#x2F; 33 </span><br><span class="line">MemoryLayout.alignment(ofValue: pwd) &#x2F;&#x2F; 8</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 如果改变了pwd</span><br><span class="line"> pwd &#x3D; .other </span><br><span class="line">MemoryLayout.stride(ofValue: pwd) &#x2F;&#x2F; 40</span><br><span class="line">MemoryLayout.size(ofValue: pwd) &#x2F;&#x2F; 33 </span><br><span class="line">MemoryLayout.alignment(ofValue: pwd) &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure><h4 id="原始值-1"><a href="#原始值-1" class="headerlink" title="原始值"></a>原始值</h4><ul><li>原始值不会直接存入到枚举内存中</li><li>如果是下面这种枚举，只需要1个字节就可以了</li><li>一个字节可以存放 FF 也就是 0~255个枚举值。如果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring, summer, autumn &#x3D; 8, winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Season&gt;.stride &#x2F;&#x2F; 1, 分配占用的空间大小 </span><br><span class="line">MemoryLayout&lt;Season&gt;.size &#x2F;&#x2F; 1, 实际用到的空间大小 1</span><br><span class="line">MemoryLayout&lt;Season&gt;.alignment &#x2F;&#x2F; 1, 对齐参数</span><br></pre></td></tr></table></figure><h2 id="窥探内存"><a href="#窥探内存" class="headerlink" title="窥探内存"></a>窥探内存</h2><p>使用 <a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a> 我们可以很轻松的获取swift中，这些枚举值的内存地址</p><h3 id="简单枚举内存"><a href="#简单枚举内存" class="headerlink" title="简单枚举内存"></a>简单枚举内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum TestEnum&#123;</span><br><span class="line">    case k0,k1,k2,k3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var t &#x3D; TestEnum.k1</span><br><span class="line">print(Mems.ptr(ofVal: &amp;t)) </span><br><span class="line"></span><br><span class="line">t &#x3D; TestEnum.k2</span><br></pre></td></tr></table></figure><p>执行完 print(Mems.ptr(ofVal: &amp;t))  代码之后<br>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000001000054b8</span><br></pre></td></tr></table></figure><p>此时去查看 0x00000001000054b8地址的数据，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>执行完 t = TestEnum.k2 之后</p><p>此时去查看 0x00000001000054b8地址的数据，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><h3 id="具体查看内存"><a href="#具体查看内存" class="headerlink" title="具体查看内存"></a>具体查看内存</h3><p>假设我们有这么下面带代码，考虑下内存怎么布局呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum TestEnum &#123;</span><br><span class="line">        case test1(Int, Int, Int)</span><br><span class="line">        case test2(Int, Int)</span><br><span class="line">        case test3(Int)</span><br><span class="line">        case test4(Bool)</span><br><span class="line">        case test5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.size)  &#x2F;&#x2F; 25, 分配占用的空间大小</span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.stride)    &#x2F;&#x2F;32, 实际用到的空间大小</span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.alignment)&#x2F;&#x2F; 8, 对齐参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var e &#x3D; TestEnum.test1(1, 2, 3)</span><br><span class="line">print(Mems.ptr(ofVal: &amp;e))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">e &#x3D; .test2(4, 5)</span><br><span class="line">print(Mems.memStr(ofVal: &amp;e))</span><br><span class="line">    </span><br><span class="line">e &#x3D; .test3(6)</span><br><span class="line">     </span><br><span class="line">e &#x3D; .test4(true)</span><br><span class="line">      </span><br><span class="line">e &#x3D; .test5</span><br></pre></td></tr></table></figure><p>执行完之后,可知 </p><p>TestEnum 这个占用内存为：</p><ul><li>print(MemoryLayout<TestEnum>.size)  // 25, 分配占用的空间大小</li><li>print(MemoryLayout<TestEnum>.stride)    //32, 实际用到的空间大小</li><li>print(MemoryLayout<TestEnum>.alignment)// 8, 对齐参数</li></ul><p>具体内存里面存的是什么呢？可以借助上面说的 <a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a> 打印出来内存，然后利用Xcode的 view Memory 查看具体内存的值</p><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum &#123;</span><br><span class="line">       case test1(Int, Int, Int)</span><br><span class="line">       case test2(Int, Int)</span><br><span class="line">       case test3(Int)</span><br><span class="line">       case test4(Bool)</span><br><span class="line">       case test5</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   print(MemoryLayout&lt;TestEnum&gt;.size)  &#x2F;&#x2F; 25, 分配占用的空间大小</span><br><span class="line">   print(MemoryLayout&lt;TestEnum&gt;.stride)    &#x2F;&#x2F;32, 实际用到的空间大小</span><br><span class="line">   print(MemoryLayout&lt;TestEnum&gt;.alignment)&#x2F;&#x2F; 8, 对齐参数</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 1个字节存储成员值</span><br><span class="line">   &#x2F;&#x2F; N个字节存储关联值（N取占用内存最大的关联值），任何一个case的关联值都共用这N个字节</span><br><span class="line">   &#x2F;&#x2F; 共用体</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 小端：高高低低</span><br><span class="line">   &#x2F;&#x2F; 01 00 00 00 00 00 00 00  &#x2F;&#x2F;对应的TestEnum.test1传入的数值</span><br><span class="line">   &#x2F;&#x2F; 02 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 03 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00                &#x2F;&#x2F; TestEnum.test1在第0个位置</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00</span><br><span class="line">   var e &#x3D; TestEnum.test1(1, 2, 3)</span><br><span class="line">   print(Mems.ptr(ofVal: &amp;e))</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 04 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 05 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 01 &#x2F;&#x2F; TestEnum.test1在第1个位置</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00</span><br><span class="line">   e &#x3D; .test2(4, 5)</span><br><span class="line">   print(Mems.memStr(ofVal: &amp;e))</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 06 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 02</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00</span><br><span class="line">   e &#x3D; .test3(6)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 01 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 03</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00</span><br><span class="line">   e &#x3D; .test4(true)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00 00</span><br><span class="line">   &#x2F;&#x2F; 04</span><br><span class="line">   &#x2F;&#x2F; 00 00 00 00 00 00 00</span><br><span class="line">   e &#x3D; .test5</span><br></pre></td></tr></table></figure><h3 id="只有一个case"><a href="#只有一个case" class="headerlink" title="只有一个case"></a>只有一个case</h3><p>假如只有一个case,其占用的空间为0，不需要存值来区分是哪个case</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum &#123;</span><br><span class="line">    case spring</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.size)      &#x2F;&#x2F; 0, 分配占用的空间大小</span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.stride)    &#x2F;&#x2F;1, 实际用到的空间大小</span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.alignment)&#x2F;&#x2F; 1, 对齐参数</span><br></pre></td></tr></table></figure><h3 id="只有一个case，有关联值"><a href="#只有一个case，有关联值" class="headerlink" title="只有一个case，有关联值"></a>只有一个case，有关联值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum &#123;</span><br><span class="line">    case spring(Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.size)      &#x2F;&#x2F; 8, 分配占用的空间大小</span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.stride)    &#x2F;&#x2F;8, 实际用到的空间大小</span><br><span class="line">print(MemoryLayout&lt;TestEnum&gt;.alignment)&#x2F;&#x2F; 8, 对齐参数</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p><p><a href="https://github.com/CoderMJLee/Mems" target="_blank" rel="noopener">窥探内存细节的小工具</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/categories/Swift/&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之函数</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E5%87%BD%E6%95%B0/</id>
    <published>2019-06-10T00:32:24.000Z</published>
    <updated>2019-12-12T06:17:38.542Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><ul><li>形参默认是let 并且只能是let</li></ul><ol><li><p>无参无返回值</p><p>可以省略Void 也可以不省略，如下三种都可以</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func sayHello()&#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayHello() -&gt; ()&#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayHello() -&gt; (Void)&#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>无参有返回值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func pi() -&gt; Double &#123;</span><br><span class="line">      return 3.1415</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>有参有返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h2><ul><li>如果函数体是个单一表达式，那么函数会返回这个表达式<br>比如上面的代码可以去掉 return 写成</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回元组：可以实现多返回值"><a href="#返回元组：可以实现多返回值" class="headerlink" title="返回元组：可以实现多返回值"></a>返回元组：可以实现多返回值</h2><p>例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func calculate(a: Int, b: Int) -&gt; (sum: Int, average: Int) &#123;</span><br><span class="line">      let sum &#x3D; a + b</span><br><span class="line">      return (sum, sum &gt;&gt; 1)</span><br><span class="line"> &#125;</span><br><span class="line"> 调用 calculate(a: 2, b: 8)</span><br><span class="line"> 返回 (sum: 10, average: 5)</span><br></pre></td></tr></table></figure><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul><li>把光标定位到需要添加注释文档的对象起始行，或上方的空白行。按下“command + Option + /”，即“⌘ + ⌥ + /”。（如果是 Windows 键盘则为“Win键 + ALT + /”）</li></ul><p>例如上文代码增加注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 计算两个数之和</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; - Parameters:</span><br><span class="line">  &#x2F;&#x2F;&#x2F;   - a: 第一个参数</span><br><span class="line">  &#x2F;&#x2F;&#x2F;   - b: 第二个参数</span><br><span class="line">  &#x2F;&#x2F;&#x2F; - Returns: 返回两个参数之和</span><br><span class="line">  func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">      return a + b</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h2><ul><li>可以修改参数标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func goToWork(at time: String) -&gt; () &#123;</span><br><span class="line">       print(&quot;this time is \(time)&quot;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>可以使用下划线 _ 省略参数标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sum2(_ a: Int, _ b: Int) -&gt; Int &#123;</span><br><span class="line">       return a + b</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><ul><li>同C++ 中一样参数可以有默认值</li><li>但是C++里面默认参数有个限制：必须从右向左设置。而Swift中拥有参数标签，所以没有这个限制    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义：func check(name: String &#x3D; &quot;jack&quot;, age: Int, job: String &#x3D; &quot;teacher&quot;) &#123;</span><br><span class="line">       print(&quot;name &#x3D; \(name), age &#x3D; \(age), job &#x3D; \(job)&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">调用：check(age: 22)</span><br><span class="line"></span><br><span class="line">输出： name &#x3D; jack, age &#x3D; 22, job &#x3D; teacher</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func sum(_ numbers: Int...) -&gt; Int&#123;</span><br><span class="line">       var total &#x3D; 0</span><br><span class="line">       for num in numbers &#123;</span><br><span class="line">           total +&#x3D; num</span><br><span class="line">       &#125;</span><br><span class="line">       return total</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">调用: sum(1,2,3)</span><br></pre></td></tr></table></figure><ul><li>一个函数最多只能有一个可变参数</li><li>紧跟着可变参数后面的参数不能省略参数标签(否则编译起来有歧义)</li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 参数string 不能省略标签</span><br><span class="line"> func test(_ numers: Int..., string: String) -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><ul><li>前面说了形参只能是let，但是如果我们想再内部修改外部实参的值，可以用 inpot 定义输入输出参数</li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func swapValues(_ v1: inout Int, _ v2: inout Int) &#123;</span><br><span class="line">     let tmp &#x3D; v1</span><br><span class="line">     v1 &#x3D; v2</span><br><span class="line">     v2 &#x3D; tmp</span><br><span class="line">     &#x2F;&#x2F;前面三行也可以换成  (v1, v2) &#x3D; (v2, v1) 效果一样</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  var num1 &#x3D; 10</span><br><span class="line">  var num2 &#x3D; 20</span><br><span class="line">  swapValues(&amp;num1, &amp;num2)</span><br><span class="line"> print(&quot;num1 &#x3D; \(num1), num2 &#x3D; \(num2)&quot;)</span><br><span class="line">    </span><br><span class="line">  输出： num1 &#x3D; 20, num2 &#x3D; 10</span><br></pre></td></tr></table></figure><p>注意点:</p><ul><li>可变参数不能标记为input</li><li>input参数不能有默认值</li><li>input参数的本质是地址传递(引用传递)</li><li>input参数只能传入可以被多次赋值的</li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>函数名相同</li><li>参数个数不同 或者 参数类型不同 或者 参数标签不同</li></ul><p>注意点是：</p><ul><li>返回值类型与函数重载无关</li><li>默认参数值和函数重载一起使用产生二义性时候，编译器不会报错(c++中会报错)</li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">      v1 + v2</span><br><span class="line">  &#125;</span><br><span class="line">  func sum(v1: Int, v2: Int, v3: Int &#x3D; 10) -&gt; Int &#123;</span><br><span class="line">      v1 + v2 + v3</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 会调用sum(v1: Int, v2: Int) </span><br><span class="line">  sum(v1: 10, v2: 20)</span><br></pre></td></tr></table></figure><ul><li>可变参数、省略参数标签、函数重载一起使用产生二义性时，编译器有可能会报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123; v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2 &#125;</span><br><span class="line">func sum(_ numbers: Int...) -&gt; Int &#123; var total &#x3D; 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total +&#x3D; number</span><br><span class="line">    &#125;</span><br><span class="line">    return total</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; error: ambiguous use of &#39;sum&#39;</span><br><span class="line">sum(10, 20)</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul><li>每一个函数都是有类型的，函数类型由形式参数类型、返回值类型组成</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123; &#125; &#x2F;&#x2F; () -&gt; Void 或者 () -&gt; ()</span><br><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125; &#x2F;&#x2F; (Int, Int) -&gt; Int</span><br><span class="line">&#x2F;&#x2F; 定义变量</span><br><span class="line">var fn: (Int, Int) -&gt; Int &#x3D; sum</span><br><span class="line">调用: fn(2, 3)</span><br></pre></td></tr></table></figure><h2 id="函数类型作为函数参数"><a href="#函数类型作为函数参数" class="headerlink" title="函数类型作为函数参数"></a>函数类型作为函数参数</h2><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">       v1 + v2</span><br><span class="line">   &#125;</span><br><span class="line">   func difference(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">       v1 - v2</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 用一个函数类型作为参数 上面两个函数类型都是 (Int, Int) -&gt; Int</span><br><span class="line">   func printResult(_ mathFn: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print(&quot;Result: \(mathFn(a, b))&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 调用</span><br><span class="line">   printResult(sum, 5, 2) &#x2F;&#x2F; Result: 7</span><br><span class="line">   printResult(difference, 5, 2) &#x2F;&#x2F; Result: 3</span><br></pre></td></tr></table></figure><h2 id="返回值是函数类型的函数"><a href="#返回值是函数类型的函数" class="headerlink" title="返回值是函数类型的函数"></a>返回值是函数类型的函数</h2><ul><li>返回值是函数类型的函数，叫做高阶函数(Higher-Order Function)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func next(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    input + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func previous(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    input - 1 </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func forward(_ forward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    forward ? next : previous</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">forward(true)(3) &#x2F;&#x2F;  4  相当于 调用 next(3)</span><br><span class="line">forward(false)(3) &#x2F;&#x2F; 2 相当于 调用 previous(3)</span><br></pre></td></tr></table></figure><h2 id="typealias-别名"><a href="#typealias-别名" class="headerlink" title="typealias 别名"></a>typealias 别名</h2><ul><li>用来给类型起别名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> typealias Date &#x3D; (year: Int, month: Int, day: Int)</span><br><span class="line">   func test(_ date: Date) &#123;</span><br><span class="line">       print(date.0)</span><br><span class="line">       print(date.year)</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 调用</span><br><span class="line">&#x2F;&#x2F; test((2011, 9, 10))</span><br></pre></td></tr></table></figure><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><ul><li>将函数定义在函数内部</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func forward(_ forward: Bool) -&gt; (Int) -&gt; Int &#123; func next(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    input + 1 &#125;</span><br><span class="line">    func previous(_ input: Int) -&gt; Int &#123; input - 1</span><br><span class="line">    &#125;</span><br><span class="line">    return forward ? next : previous</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forward(true)(3) &#x2F;&#x2F; 4</span><br><span class="line">forward(false)(3) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/categories/Swift/&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之流程控制</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2019-05-30T00:32:24.000Z</published>
    <updated>2019-12-12T06:17:02.042Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><ul><li>if后面的条件可以省略小括号</li><li>条件后面的大括号不可以省略</li></ul><p>下面的代码是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let score &#x3D; 70</span><br><span class="line">if score &gt;&#x3D; 80 &#123;</span><br><span class="line">    print(&quot;优秀&quot;)</span><br><span class="line">&#125;else if score &gt;&#x3D; 60&#123;</span><br><span class="line">    print(&quot;及格&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;不及格&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if后面的条件只能是bool类型</li></ul><p>例如下面是不可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if score &#123;</span><br><span class="line">    print(&quot;aa&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>先看如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 5</span><br><span class="line">while num &gt; 0 &#123;</span><br><span class="line">    print(&quot;num is \(num)&quot;)</span><br><span class="line">    num -&#x3D; 1</span><br><span class="line">&#125;&#x2F;&#x2F; 会打印五次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var num &#x3D; 5</span><br><span class="line">repeat &#123;</span><br><span class="line">    print(&quot;num is \(num)&quot;)</span><br><span class="line">     num -&#x3D; 1</span><br><span class="line">&#125;while num &gt; 0&#x2F;&#x2F; 会打印五次</span><br></pre></td></tr></table></figure><ul><li>repeat-while 相当于C语言中的 do-while</li><li>上面代码中没有用num–，是因为从Swift3开始，去掉了自增(++)、自减(–)运算符</li></ul><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><h3 id="闭区间运算符-a…b，代表着-a-lt-取值-lt-b"><a href="#闭区间运算符-a…b，代表着-a-lt-取值-lt-b" class="headerlink" title="闭区间运算符: a…b，代表着: a &lt;= 取值 &lt;= b"></a>闭区间运算符: a…b，代表着: a &lt;= 取值 &lt;= b</h3><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wanger&quot;,&quot;mazi&quot;]</span><br><span class="line">for i in 0...3 &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;zhangsan</span><br><span class="line">&#x2F;&#x2F;lisi</span><br><span class="line">&#x2F;&#x2F;wanger</span><br><span class="line">&#x2F;&#x2F;mazi</span><br></pre></td></tr></table></figure><ul><li>我们也可以用range来表示区间，例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wanger&quot;,&quot;mazi&quot;]</span><br><span class="line">let range &#x3D; 0...3</span><br><span class="line">for i in range &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;zhangsan</span><br><span class="line">&#x2F;&#x2F;lisi</span><br><span class="line">&#x2F;&#x2F;wanger</span><br><span class="line">&#x2F;&#x2F;mazi</span><br></pre></td></tr></table></figure><ul><li>我们也可以用变量来表示区间，例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wanger&quot;,&quot;mazi&quot;]</span><br><span class="line">let before &#x3D; 0</span><br><span class="line">var end &#x3D; 3</span><br><span class="line">for i in before...end &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;zhangsan</span><br><span class="line">&#x2F;&#x2F;lisi</span><br><span class="line">&#x2F;&#x2F;wanger</span><br><span class="line">&#x2F;&#x2F;mazi</span><br></pre></td></tr></table></figure><ul><li>我们也可以用变量和数值共同使用来表示区间，例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wanger&quot;,&quot;mazi&quot;]</span><br><span class="line">for i in before...3 &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;zhangsan</span><br><span class="line">&#x2F;&#x2F;lisi</span><br><span class="line">&#x2F;&#x2F;wanger</span><br><span class="line">&#x2F;&#x2F;mazi</span><br></pre></td></tr></table></figure><h3 id="半开区间运算符：a-lt-b-表示-a-lt-取值-lt-b"><a href="#半开区间运算符：a-lt-b-表示-a-lt-取值-lt-b" class="headerlink" title="半开区间运算符：a..&lt;b 表示 a &lt;= 取值 &lt; b"></a>半开区间运算符：a..&lt;b 表示 a &lt;= 取值 &lt; b</h3><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wanger&quot;,&quot;mazi&quot;]</span><br><span class="line">for i in 1..&lt;3 &#123;</span><br><span class="line">    print(persons[i])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;lisi</span><br><span class="line">&#x2F;&#x2F;wanger</span><br></pre></td></tr></table></figure><ol start="3"><li>区间运算符用在数组上<br>例如</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let nums &#x3D; [1,2,3,4]</span><br><span class="line">for num in nums[0...3] &#123;</span><br><span class="line">    print(num)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;1</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;3</span><br><span class="line">&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><ul><li>单侧区间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let nums &#x3D; [1,2,3,4]</span><br><span class="line">for num in nums[0...] &#123;</span><br><span class="line">    print(num)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;1</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;3</span><br><span class="line">&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let nums &#x3D; [1,2,3,4]</span><br><span class="line">for num in nums[..&lt;4] &#123;</span><br><span class="line">    print(num)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果为</span><br><span class="line">&#x2F;&#x2F;1</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">&#x2F;&#x2F;3</span><br><span class="line">&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><h2 id="区间类型"><a href="#区间类型" class="headerlink" title="区间类型"></a>区间类型</h2><p>如下三种</p><ul><li>let range1: ClosedRange<Int> = 1…3</li><li>let range2: Range<Int> = 1..&lt;3</li><li>let range3: PartialRangeThrough<Int> = …5</li></ul><p>字符、字符串也可以使用区间运算符，但默认不能使用在for-in中<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这样写是可以的</span><br><span class="line">let strRange &#x3D; &quot;a&quot;...&quot;f&quot;</span><br><span class="line">strRange.contains(&quot;d&quot;) &#x2F;&#x2F; true</span><br><span class="line">strRange.contains(&quot;l&quot;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">但是下面是会报错的</span><br><span class="line">for i in strRange &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>\0 到 “~” 包括了所有的要用到的ASCII字符<br>例如我们要判断一个字符是否是ASCII字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let characterRange: ClosedRange&lt;Character&gt; &#x3D; &quot;\0&quot;...&quot;~&quot;</span><br><span class="line">&#x2F;&#x2F;想判断s是否是ASCII字符可以</span><br><span class="line">characterRange.contains(&quot;s&quot;) &#x2F;&#x2F;返回true</span><br></pre></td></tr></table></figure><h3 id="带间隔的区间值"><a href="#带间隔的区间值" class="headerlink" title="带间隔的区间值"></a>带间隔的区间值</h3><p>用到了 stride<br>看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let all &#x3D; 100</span><br><span class="line">let interval &#x3D; 20</span><br><span class="line">&#x2F;&#x2F; res的取值为从 10 开始 每次间隔 20，直到100结束，</span><br><span class="line">for res in stride(from: 10, to: all, by: interval) &#123;</span><br><span class="line">    print(res)</span><br><span class="line">&#125;&#x2F;&#x2F; 结果为</span><br><span class="line">&#x2F;&#x2F;10</span><br><span class="line">&#x2F;&#x2F;30</span><br><span class="line">&#x2F;&#x2F;50</span><br><span class="line">&#x2F;&#x2F;70</span><br><span class="line">&#x2F;&#x2F;90</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul><li>case、default 后面不能写大括号{}</li><li>默认可以不写break，并不会贯穿到后面的条件</li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var res &#x3D; 1</span><br><span class="line">switch res &#123;</span><br><span class="line">case 0:</span><br><span class="line">    print(&quot;res &#x3D; 0&quot;)</span><br><span class="line">case 1:</span><br><span class="line">    print(&quot;res &#x3D; 1&quot;)</span><br><span class="line">case 2:</span><br><span class="line">    print(&quot;res &#x3D; 2&quot;)</span><br><span class="line">default:</span><br><span class="line">     print(&quot;other res&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出为 res &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>关键字 fallthrough</strong></p><p>如果我们想让其贯穿下去，就是用 fallthrough 这个关键字<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var res &#x3D; 1</span><br><span class="line">switch res &#123;</span><br><span class="line">case 0:</span><br><span class="line">    print(&quot;res &#x3D; 0&quot;)</span><br><span class="line">case 1:</span><br><span class="line">    print(&quot;res &#x3D; 1&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">case 2:</span><br><span class="line">    print(&quot;res &#x3D; 2&quot;)</span><br><span class="line">default:</span><br><span class="line">     print(&quot;other res&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出为</span><br><span class="line">&#x2F;&#x2F; res &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; res &#x3D; 2</span><br></pre></td></tr></table></figure><h3 id="switch中支持-字符串，字符类型"><a href="#switch中支持-字符串，字符类型" class="headerlink" title="switch中支持 字符串，字符类型"></a>switch中支持 字符串，字符类型</h3><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">字符串</span><br><span class="line">let string &#x3D; &quot;aaa&quot;</span><br><span class="line">switch string &#123;</span><br><span class="line">case &quot;aaa&quot;:</span><br><span class="line">    print(&quot;string is aaa&quot;)</span><br><span class="line">case &quot;bbb&quot;:</span><br><span class="line">    print(&quot;string is bbb&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125; &#x2F;&#x2F; string is aaa</span><br><span class="line"></span><br><span class="line">字符类型</span><br><span class="line">let character: Character &#x3D; &quot;a&quot;</span><br><span class="line">switch character &#123;</span><br><span class="line">case &quot;a&quot;,&quot;A&quot;:</span><br><span class="line">     print(&quot;string is a or A&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;string is not a or A&quot;)</span><br><span class="line">&#125; &#x2F;&#x2F;string is a or A</span><br></pre></td></tr></table></figure><h3 id="区间、元组匹配"><a href="#区间、元组匹配" class="headerlink" title="区间、元组匹配"></a>区间、元组匹配</h3><ul><li>可以用下划线_ 忽略某个值</li><li>可以对区间，和元组进行匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let count &#x3D; 8</span><br><span class="line">switch count &#123;</span><br><span class="line">case 0:</span><br><span class="line">    print(&quot;0&quot;)</span><br><span class="line">case 1..&lt;5:</span><br><span class="line">    print(&quot;1到4&quot;)</span><br><span class="line">case 5..&lt;10:</span><br><span class="line">    print(&quot;5到10&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;5到10</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let point &#x3D; (1,0)</span><br><span class="line">switch point &#123;</span><br><span class="line">case (0, 0):</span><br><span class="line">    print(&quot;原点&quot;)</span><br><span class="line">case (_, 0):</span><br><span class="line">    print(&quot;x轴&quot;)</span><br><span class="line">case (0, _):</span><br><span class="line">    print(&quot;y轴&quot;)</span><br><span class="line">case (-2...2, -2...2):</span><br><span class="line">    print(&quot;区间&quot;)</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">     print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;x轴</span><br></pre></td></tr></table></figure><h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let point2 &#x3D; (1,0)</span><br><span class="line">switch point2 &#123;</span><br><span class="line">case (0, 0):</span><br><span class="line">    print(&quot;原点&quot;)</span><br><span class="line">case (let x, 0):</span><br><span class="line">    print(&quot;x轴 x是 \(x)&quot;)</span><br><span class="line">case (0, let y):</span><br><span class="line">    print(&quot;y轴 y是 \(y)&quot;)</span><br><span class="line">case let (x, y):</span><br><span class="line">    print(&quot;somewhere else at (\(x),\(y))&quot;)</span><br><span class="line">    </span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; x轴 x是 1</span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers &#x3D; [1,2,3,4,5,]</span><br><span class="line">var sum &#x3D; 0</span><br><span class="line">for num in numbers where num &gt; 2 &#123;</span><br><span class="line">    sum +&#x3D; num</span><br><span class="line">&#125;</span><br><span class="line">print(sum) &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure><h2 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h2><p>标签语句用于执行的时候，跳转到标签的位置</p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">outer: for i in 1...4&#123;</span><br><span class="line">    for k in 1...4 &#123;</span><br><span class="line">        if k &#x3D;&#x3D; 2 &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        if i &#x3D;&#x3D; 3 &#123;</span><br><span class="line">            break outer</span><br><span class="line">        &#125;</span><br><span class="line">         print(&quot;i &#x3D;&#x3D; \(i), k &#x3D;&#x3D; \(k)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出为 </span><br><span class="line">i &#x3D;&#x3D; 1, k &#x3D;&#x3D; 1</span><br><span class="line">i &#x3D;&#x3D; 1, k &#x3D;&#x3D; 3</span><br><span class="line">i &#x3D;&#x3D; 1, k &#x3D;&#x3D; 4</span><br><span class="line">i &#x3D;&#x3D; 2, k &#x3D;&#x3D; 1</span><br><span class="line">i &#x3D;&#x3D; 2, k &#x3D;&#x3D; 3</span><br><span class="line">i &#x3D;&#x3D; 2, k &#x3D;&#x3D; 4</span><br></pre></td></tr></table></figure><p>如果加了标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">outer: for i in 1...4&#123;</span><br><span class="line">    for k in 1...4 &#123;</span><br><span class="line">        if k &#x3D;&#x3D; 2 &#123;</span><br><span class="line">            continue outer</span><br><span class="line">        &#125;</span><br><span class="line">        if i &#x3D;&#x3D; 3 &#123;</span><br><span class="line">            break outer</span><br><span class="line">        &#125;</span><br><span class="line">         print(&quot;i &#x3D;&#x3D; \(i), k &#x3D;&#x3D; \(k)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">输出为 </span><br><span class="line">i &#x3D;&#x3D; 1, k &#x3D;&#x3D; 1</span><br><span class="line">i &#x3D;&#x3D; 2, k &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/categories/Swift/&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;if-else&quot;&gt;&lt;a href=&quot;#if-else&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之基本运算、数据类型、元组</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%85%83%E7%BB%84/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%85%83%E7%BB%84/</id>
    <published>2019-05-15T00:32:24.000Z</published>
    <updated>2019-12-12T06:15:56.041Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/categories/Swift/">我的个人博客</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>  Swift编程语言，支持多编程范式和编译式，用来撰写基于macOS/OS X、iOS、watchOS和tvOS的软件。 苹果公司于2014年在苹果开发者年会（WWDC）发布了Swift编程语言。从设计上苹果公司让Swift与Objective-C共存在苹果公司的操作系统上</p></blockquote><blockquote><p>苹果宣称Swift的特点是：快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译，可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果，能让Swift源代码在撰写过程中能即时显示出其运行结果</p></blockquote><blockquote><p>2015年6月8日，苹果于WWDC2015上宣布，Swift将开放源代码，包括编译器和标准库<br>2015年12月3日，苹果宣布<a href="https://github.com/apple/Swift" target="_blank" rel="noopener">开源Swift</a>，并支持Linux，苹果在新网站Swift.org和托管网站Github上开源了Swift，但苹果的app store并不支持开源的Swift，只支持苹果官方的Swift版本，官方版本会在新网站Swift.org上定期与开源版本同步</p></blockquote><p>之前由于每个版本都不兼容，所以对开发者不友好，每次新版本，就像学了一门新的语言。但是从Swift5开始，API终于稳定下来了。可以来总结，学习一下Swift了。</p><h2 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h2><ul><li>生成语法树: Swiftc -dump-ast main.Swift </li><li>生成最简洁的SIL代码:Swiftc -emit-sil main.Swift </li><li>生成LLVM IR代码: Swiftc -emit-ir main.Swift -o main.ll </li><li>生成汇编代码: Swiftc -emit-assembly main.Swift -o main.s</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>不用编写main函数，Swift将全局范围内的首句可执行代码作为程序入口</li><li>一句代码尾部可以省略分号(;)</li><li>多句代码写到同一行时必须用分号(;)隔开 </li><li>用var定义变量，let定义常量，编译器能自动推断出变量\常量的类型</li><li>Playground可以快速预览代码效果，是学习语法的好帮手 <ul><li>Command + Shift + Enter: 运行整个Playground </li><li>Shift + Enter:运行截止到某一行代码</li></ul></li></ul><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 10</span><br><span class="line">a &#x3D; 20</span><br><span class="line">let b &#x3D; 88</span><br><span class="line">let c &#x3D; 12 ; let d &#x3D; 40</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>创建对象，例如view视图，控制器等也更简单</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>和OC一样，有单行注释，多行注释<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单行注释</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> 多行注释</span><br><span class="line"> </span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>但是，Swift中增加了，注释的嵌套，比如这样是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> 多行注释</span><br><span class="line"> &#x2F;*</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 单行注释</span><br><span class="line"> </span><br><span class="line"> 嵌套多行注释</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><strong><em>Playound的注释是支持markup(类似Markdown)语法的</em></strong></p><ul><li>开启markup:Editor-&gt;Show Rendered Markup</li><li>只能在Playground中使用</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>只能赋值1次</li><li>常量的值不要求在编译的时候确定，只要在使用之前赋值一次就可以了<br>例如下面都是可以的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 10</span><br><span class="line">num +&#x3D; 20</span><br><span class="line">num +&#x3D; 30</span><br><span class="line">let age &#x3D; num</span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line">func getAge() -&gt; Int &#123;</span><br><span class="line">    return 10</span><br><span class="line">&#125;</span><br><span class="line">let age2 &#x3D; getAge()</span><br><span class="line">print(age2)</span><br></pre></td></tr></table></figure><p>但是下面这种是不可以的，因为在初始化之前，是不可以使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let number: Int</span><br><span class="line">print(number)</span><br></pre></td></tr></table></figure><p>当然了，这种也是不行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let number</span><br><span class="line">number &#x3D; 25</span><br></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>比如常量名，变量名，函数名等标识符</p><ul><li>标识符不能数字开头，不能包含空白字符，制表符，箭头灯特殊字符。</li><li>除此之外，几乎可以使用任何字符。</li></ul><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><ol><li>值类型(value type)<ul><li>枚举(enum): optional</li><li>结构体(struct): Float、 Double、Float、Int、Character、String、Array、Dictionary、Set</li></ul></li><li>引用类型(reference type)<ul><li>类(class)</li></ul></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>不同类型之间的转换，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 整数转换</span><br><span class="line">let a: UInt16 &#x3D; 2_000</span><br><span class="line">let b: UInt8 &#x3D; 10</span><br><span class="line">let c &#x3D; a + UInt16(b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;整数和浮点数转换</span><br><span class="line">let intNumber &#x3D; 3</span><br><span class="line">let doubleNumber &#x3D; 0.1415926</span><br><span class="line">let pi &#x3D; Double(intNumber) + doubleNumber</span><br><span class="line">let intPi &#x3D; Int(pi)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字面量可以直接相加，因为字面量没有明确的类型</span><br><span class="line">let res &#x3D; 3 + 2.565</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元祖可以把多个值保存在一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式: (数值1, 数值2, 数值3)</span><br><span class="line">let numbers &#x3D; (10, 20, 30)</span><br><span class="line">&#x2F;&#x2F; 可以通过索引访问</span><br><span class="line">numbers.0</span><br><span class="line">numbers.1</span><br><span class="line">numbers.2</span><br></pre></td></tr></table></figure><p>元祖中还可以保存不同的数据类型的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; (name: &quot;lnj&quot;, age: 30, score: 100.0)</span><br><span class="line">&#x2F;&#x2F; 可以通过名称访问</span><br><span class="line">person.name</span><br><span class="line">person.age</span><br><span class="line">person.score</span><br></pre></td></tr></table></figure><p>我们甚至可以这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 相当于同时定义了三个变量</span><br><span class="line">let (name, age, score) &#x3D; (&quot;lnj&quot;, 30, 80)</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">score</span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/categories/Swift/&quot;&gt;我的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS逆向流程</title>
    <link href="https://ityongzhen.github.io/iOS%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://ityongzhen.github.io/iOS%E9%80%86%E5%90%91%E6%B5%81%E7%A8%8B/</id>
    <published>2019-04-28T00:32:24.000Z</published>
    <updated>2019-12-12T05:59:36.249Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于 <a href="https://ityongzhen.github.io/categories">个人博客</a></p><h3 id="iOS逆向"><a href="#iOS逆向" class="headerlink" title="iOS逆向"></a>iOS逆向</h3><h5 id="准备：完美越狱iPhone"><a href="#准备：完美越狱iPhone" class="headerlink" title="准备：完美越狱iPhone"></a>准备：完美越狱iPhone</h5><p>逆向APP思路：1，代码分析</p><p>2，对Mach-O文件的静态分析MachOView、class-dump、Hopper Disassembler、ida等</p><p>3，动态调试 对运行中的APP进行代码调试 p debugserver、LLDB</p><p>4，代码编写</p><p>5，注入代码到APP中</p><p>6，必要时还可能需要重新签名、打包ipa</p><h4 id="一、Mac远程登录iPhone"><a href="#一、Mac远程登录iPhone" class="headerlink" title="一、Mac远程登录iPhone"></a>一、Mac远程登录iPhone</h4><ul><li><p>SSH (Secure Shell) 是“安全外壳协议”</p><p>OpenSSH 是SSH协议的免费开源实现 (在iPhone上通过Cydia安装OpenSSH工具(软件源<a href="http://apt.saurik.com" target="_blank" rel="noopener">http://apt.saurik.com</a>))</p><p>可以通过OpenSSH的方式让Mac远程登录到iPhone</p></li><li><p>SSH是通过TCP协议通信，所以要确保Mac和iPhone在同一局域网下，比如连接着同一个WiFi下</p><p>在终端输入</p></li></ul><p>ssh 账户名@服务器主机地址</p><p>例如：</p><p>ssh <a href="mailto:root@192.168.8.157">root@192.168.8.157</a>  然后输入密码(默认是alpine ) </p><p>这种方式wifi登录，受到网速限制</p><ul><li>usb连接 （不需要网络，速度快，安全） 1.1 sh usb.sh （注： python2 usbmuxd-1.0.8/python-client/tcprelay.py -t 22:10010 8888:8888）</li></ul><p>1.2  sh login.sh (注：ssh -p 10010 root@localhost)</p><p>上面的命令生效是因为已经把 usb.sh 和 login.sh 两个文件做了端口映射并放到了根目录 (映射需要usbmuxd工具包)</p><p>另外： 1.echo $PATH 查看设置的根目录，如果自己想写脚本在其他地方都能执行，也可以放在PATH路径下</p><p>2.手机和电脑能连接是因为，手机的授权文件 /var/root/.ssh/authorized_keys 中 添加了电脑的公钥 ~/.ssh/id_rsa.pub</p><p>Mac上有个服务程序usbmuxd（它会开机自动启动），可以将Mac的数据通过USB传输到iPhone</p><p>/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd</p><p>下载usbmuxd工具包（下载v1.0.8版本，主要用到里面的一个python脚本：<a href="http://tcprelay.py" target="_blank" rel="noopener">tcprelay.py</a>）</p><p><a href="https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz" target="_blank" rel="noopener">https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz</a></p><h4 id="二、获取手机上软件的ipa包"><a href="#二、获取手机上软件的ipa包" class="headerlink" title="二、获取手机上软件的ipa包"></a>二、获取手机上软件的ipa包</h4><ul><li><p>Cycript 安装到手机上</p><p>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物，可以用来探索、修改、调试正在运行的Mac\iOS APP</p><p>官网： <a href="http://www.cycript.org/" target="_blank" rel="noopener">http://www.cycript.org/</a></p><p>文档： <a href="http://www.cycript.org/manual/" target="_blank" rel="noopener">http://www.cycript.org/manual/</a></p><p>通过Cydia安装Cycript，即可在iPhone上调试运行中的APP</p><p>使用： cycript -p 进程ID 比如：cycript -p NewsBoard</p><p>cycript -p 进程名称</p><p>取消输入:Ctrl + C</p><p>退出:Ctrl + D</p><p>清屏:Command + R</p><p>Github 上有基于cycript封装了一些函数 参考</p><p><a href="https://github.com/CoderMJLee/mjcript" target="_blank" rel="noopener">https://github.com/CoderMJLee/mjcript</a></p><p>@import mjcript —&gt;MJAppId、MJFrontVC()、MJDocPath、MJAppPath 等</p></li><li><p>Clutch -i 获取加壳软件的appid</p></li><li><p>PS命令 （手机上安装adv-cmds）</p><p>ps –A 列出所有的进程</p></li></ul><p>ps命令是process status</p><p>可以过滤关键词，比如 : ps -A | grep WeChat</p><ul><li><p>也可以用github 上工具获取 <a href="https://github.com/CoderMJLee/MJAppTools" target="_blank" rel="noopener">https://github.com/CoderMJLee/MJAppTools</a></p><p>MJAppTools 可以获取到架构，名称，是否加壳，安装包路径，数据库路径等</p></li></ul><h4 id="三、脱壳"><a href="#三、脱壳" class="headerlink" title="三、脱壳"></a>三、脱壳</h4><ul><li>iOS中有很多好用的脱壳工具</li></ul><p>Clutch:<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch</a></p><p>dumpdecrypted:<a href="https://github.com/stefanesser/dumpdecrypted/" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted/</a></p><p>AppCrackr、Crackulous</p><ul><li><p>Clutch -i 获取到appid之后，Clutch -d (APP序号) 导出app包 eg: Clutch -d 1 会打印出脱壳路径</p></li><li><p>DYLD_INSERT_LIBRARIES 脱壳</p><p>例如：MJAppTools 获取 到 【网易新闻】 &lt;com.netease.news&gt;  /private/var/mobile/Containers/Bundle/Application/64F0B25C-062E-4A89-8834-3F534C24E70D/NewsBoard.app</p><p>执行：</p><blockquote><blockquote><p>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /private/var/mobile/Containers/Bundle/Application/64F0B25C-062E-4A89-8834-3F534C24E70D/NewsBoard.app/NewsBoard</p></blockquote></blockquote><p>获取到的脱壳文件再当前目录下 (Device/var/root)</p></li><li><p>查看是否脱壳</p><p>otool -l 名称 | grep crypt 例如： otool -l NewsBoard | grep crypt 查看网易新闻是否脱壳</p></li></ul><p>也可以用hopper看是否脱壳</p><p>cryptid 0 为脱壳 cryptid 1 是加壳</p><h4 id="四、反编译出头文件"><a href="#四、反编译出头文件" class="headerlink" title="四、反编译出头文件"></a>四、反编译出头文件</h4><ul><li><p>class-dump</p><p>顾名思义，它的作用就是把Mach-O文件的class信息给dump出来(把类信息给导出来)，生成对应的.h头文件</p></li></ul><p>官方地址:<a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">http://stevenygard.com/projects/class-dump/</a></p><p>下载完工具包后将class-dump文件复制到Mac的/usr/local/bin目录，这样在终端就能识别class-dump命令了</p><p>常用格式：</p><p>class-dump -H Mach-O文件路径 -o 头文件存放目录 -H表示要生成头文件 -o用于制定头文件的存放目录</p><p>例如：当前目录下 class-dump -H NewsBoard -o Header (新建一个Header的文件夹) 这时候可以用hopper 等分析代码了</p><h4 id="五、theos"><a href="#五、theos" class="headerlink" title="五、theos"></a>五、theos</h4><ul><li><p>􏰂􏰃􏰄安装签名工具ldid</p><p>1.先确保安装brew<br>$(curl -fsSL<br><a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p></li></ul><p>2.利用brew安装ldid</p><p>$ brew install ldid</p><ul><li><p>修改环境变量</p><ol><li>编辑用户配置文件</li></ol><p>$ vim ~/.bash_profile</p><p>2.在􏰝..bash_profie􏰛 文件后面加入下面两行</p><blockquote><p>export THEOS=~/theos<br>export PATH=$THEOS/bin:$PATH</p></blockquote><p>3,让.bash_profie配置的环境变量立即生效(或者重新打开终端)</p><blockquote><p>$ source ~/.bash_profile</p></blockquote></li><li><p>􏰣􏰵下载theos</p><p>建议在$PATH 目录下载代码(就是刚才配置的)</p><blockquote><p>$ git clone –recursive <a href="https://github.com/theos/theos.git" target="_blank" rel="noopener">https://github.com/theos/theos.git</a> $THEOS</p></blockquote></li><li><p>新建tweak 项目</p><p>1，cd到放文件的目录下（比如桌面</p><blockquote><p>$ cd ~/Desktop<br>$ nic.pl</p></blockquote><p>2，选择􏱋􏱌[13.] iphone/tweak</p><p>3，填写项目信息</p><p>名称 项目ID随便写， MobileSubstrate Bundle filter 写应用的id 其他回车</p></li></ul><h4 id="六、编写代码"><a href="#六、编写代码" class="headerlink" title="六、编写代码"></a>六、编写代码</h4><p>具体情况具体分析</p><h4 id="七、打包编译安装"><a href="#七、打包编译安装" class="headerlink" title="七、打包编译安装"></a>七、打包编译安装</h4><p>当前tweak文件目录下make clean &amp;&amp; make &amp;&amp; make package &amp;&amp; make install （已经写好了文件，可以直接 sh ~/tweak.sh</p><p>自己做的插件在 Device/Library/MobileSubstrate/DynamicLibraries</p><h4 id="八、theos资料"><a href="#八、theos资料" class="headerlink" title="八、theos资料"></a>八、theos资料</h4><ul><li><p>目录结构： <a href="https://github.com/theos/theos/wiki/Structure" target="_blank" rel="noopener">https://github.com/theos/theos/wiki/Structure</a></p></li><li><p>环境变量：<a href="http://iphonedevwiki.net/index.php/Theos" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/Theos</a></p></li><li><p>Logoes语法: <a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/Logos</a></p><ul><li><p>%hook %end : hook一个类的开始和结束</p></li><li><p>%log : 打印方法调用详情</p><p>可以 􏱧􏰢􏱨􏱩Xcode -&gt; Window -&gt; Devices and Simulators􏱪􏱫􏳕􏳖 中查看</p></li><li><p>HBDebugLog 类似NSLog</p></li><li><p>%new : 添加一个新的方法</p></li><li><p>%c(className)： 生成一个class对象，比如Class%c(NSObject) ，类似于NSStringFromClass()􏰁、objc_getClass()</p></li><li><p>%orig :  函数调用原来的逻辑</p></li><li><p>%ctor ： 在加载动态库时候调用</p></li><li><p>%dtor : 程序退出时调用</p></li><li><p>logify.pl： 可以将一个头文件快速转成已经包含打印信息的xm文件</p><blockquote><p>logify.pl xx.h &gt; xx.xm</pre></p></blockquote><pre><code>1，在 UserCenterViewController.h 目录下执行logify.pl UserCenterViewController.h &gt; UserCenterViewController.xm2， UserCenterViewController.xm 拷贝到Makefile(Tweak.xm) 所在目录3, 新建一个src目录，把.xm文件放进去，修改路径 YZRongxin_FILES = $(wildcard src/*.xm)4，不认识的类 替换为void 删除__weak 删除协议5, 不想太详细 %log 换成NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));6，HBLogDebug(@&quot; = 0x%x&quot;, (unsigned int)r) 改为 HBLogDebug(@&quot; = 0x%@&quot;, r)</code></pre></li></ul></li></ul><h4 id="九、MAC、IPhone-软件破解"><a href="#九、MAC、IPhone-软件破解" class="headerlink" title="九、MAC、IPhone 软件破解"></a>九、MAC、IPhone 软件破解</h4><p>例：PC软件破解 ./YZCTest</p><p>例：网易新闻去广告 NTESNBNewsListController hasAd</p><p>例：优酷去掉90s开头广告 XAdEnginePreAdModule setupVideoAd  needAd</p><p>如果是未越狱的IPhone 则还需要打包签名等操作。</p><h4 id="十、动态调试"><a href="#十、动态调试" class="headerlink" title="十、动态调试"></a>十、动态调试</h4><h4 id="十一、签名打包"><a href="#十一、签名打包" class="headerlink" title="十一、签名打包"></a>十一、签名打包</h4><ul><li><h4 id="准备一个embedded-mobileprovision文件（必须是付费证书产生的，appid-device一定要匹配）并放入到-app包中。"><a href="#准备一个embedded-mobileprovision文件（必须是付费证书产生的，appid-device一定要匹配）并放入到-app包中。" class="headerlink" title="准备一个embedded.mobileprovision文件（必须是付费证书产生的，appid,device一定要匹配）并放入到.app包中。"></a>准备一个embedded.mobileprovision文件（必须是付费证书产生的，appid,device一定要匹配）并放入到.app包中。</h4><ul><li><p>可以通过Xcode自动生成，然后再编译后的APP包中找到</p></li><li><p>可以去开发者网站生成证书下载</p></li></ul></li><li><p>从embedded.mobileprovision文件中提取出entitlements.plist权限文件</p><ul><li><p>security  cms  -D -i embedded.mobileprovision &gt; temp.plist</p></li><li><p>/usr/libexec/PlistBuddy -x -c’Print :Entitlements’ temp.plist &gt; entilements.plist</p></li></ul></li><li><p>查看可用的证书</p><ul><li>security find-identity -v -p codesigning</li></ul></li><li><p>对.app内的动态库、AppExtension等进行签名</p><ul><li>codesign -f -s 证书ID XXX.dylib</li></ul></li><li><p>对.app包进行签名</p><ul><li>codesign -f -s 证书id –entitlements entitlements.plist xxx.app</li></ul></li><li><p>重签名工具</p><ul><li><p>iOS App Signer</p><p>“&gt;<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="noopener">https://github.com/DanTheMan827/ios-app-signer</a></p><ul><li><p>对.app重签名，打包成ipa</p></li><li><p>需要再.app包中提供对应的embedded.mobileprovision文件</p></li></ul></li><li><p>iReSign</p><ul><li><p><a href="https://github.com/maciekish/iReSign" target="_blank" rel="noopener">https://github.com/maciekish/iReSign</a></p></li><li><p>可以对ipa进行重签名，打包成ipa</p></li><li><p>需要提供embedded.mobileprovision、entitlements.plist文件的路径</p></li></ul></li></ul></li></ul><h4 id="十二、其他笔记："><a href="#十二、其他笔记：" class="headerlink" title="十二、其他笔记："></a>十二、其他笔记：</h4><p>Tweak 技巧</p><p>1，加载 图片资源 创建 layout 文件夹 相当于Device/Library</p><p>图片会放在 在Device/Library/PreferenceLoader/Preference</p><p>2，自己做的插件在 Device/Library/MobileSubstrate/DynamicLibraries</p><p>3，#define YZFile(path) @”/Library/PreferenceLoader/Preferences/yzxmly/“ #path</p><p>4，多个文件，多个目录，引用头文件要使用路径比如 @import “abc/def/person.h”</p><p>5，路径 全路径，或者 <em>代替 比如：src/test.xm src/</em>.m （中间一个空格）</p><p>6，如果自己增加类，方法属性等，要声明的话</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface yzdefine</span><br><span class="line">​</span><br><span class="line">-(void)vipReOpenPlayer;</span><br><span class="line">​</span><br><span class="line">@end&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于 &lt;a href=&quot;https://ityongzhen.github.io/categories&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;iOS逆向&quot;&gt;&lt;a href=&quot;#iOS逆向&quot; class=&quot;headerlink&quot; title=&quot;iOS逆向&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="逆向" scheme="https://ityongzhen.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之(九)观察者模式</title>
    <link href="https://ityongzhen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%B9%9D)%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ityongzhen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E4%B9%9D)%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-04-16T00:32:24.000Z</published>
    <updated>2019-12-12T05:42:29.850Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/设计模式之(九)观察者模式.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h3><p><a href="https://baike.baidu.com/item/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/5881786?fr=aladdin" target="_blank" rel="noopener">观察者模式</a>  属于行为型模式。</p><blockquote><p>观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象主题（Subject）：<br>它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>具体主题（Concrete Subject）：<br>将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</li><li>抽象观察者（Observer）：<br>为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li><li>具体观察者（Concrete Observer）：<br>实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调</li></ul><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要被改变。</li><li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象是紧密耦合的</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>观察者模式的主要的作用就是对对象解耦，将观察者和被观察者完全隔离。</li></ul><h4 id="观察者模式的优点"><a href="#观察者模式的优点" class="headerlink" title="观察者模式的优点"></a>观察者模式的优点</h4><ul><li>观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。</li></ul><h4 id="观察者模式的缺点"><a href="#观察者模式的缺点" class="headerlink" title="观察者模式的缺点"></a>观察者模式的缺点</h4><ul><li>在应用观察者模式时需要考虑一下开发小路问题，程序中包括一个被观察者和多个被观察者，开发和调试比较复杂，而且Java中的消息的通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。</li></ul><h2 id="iOS中的观察者模式"><a href="#iOS中的观察者模式" class="headerlink" title="iOS中的观察者模式"></a>iOS中的观察者模式</h2><p>一般两种：KVO和通知。通知比较简单，这里只说一下KVO</p><ul><li>KVO全称KeyValueObserving，俗称<strong>键值监听</strong>，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于KVO的实现机制，所以对属性才会发生作用，一般继承自NSObject的对象都默认支持KVO。</li><li>KVC和KVO都属于键值编程而且底层实现机制都是<strong>isa-swizzing</strong>。</li><li>KVO和NSNotificationCenter都是iOS中<strong>观察者模式</strong>的一种实现。KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听。</li><li>KVO可以监听单个属性的变化，也可以监听集合对象的变化。通过KVC的mutableArrayValueForKey:等方法获得代理对象，当代理对象的内部对象发生改变时，会回调KVO监听的方法。集合对象包含NSArray和NSSet。</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul><li>KVO是通过isa-swizzling技术实现的(这句话是整个KVO实现的重点)。</li><li>在运行时根据原类创建一个中间类，这个中间类是原类的子类，并动态修改当前对象的isa指向中间类。当修改 instance 对象的属性时，会调用 Foundation框架的 _NSSetXXXValueAndNotify 函数 ,该函数里面会先调用 willChangeValueForKey: 然后调用父类原来的 setter 方法修改值，最后是 didChangeValueForKey:。didChangeValueForKey 内部会触发监听器（Oberser）的监听方法observeValueForKeyPath:ofObject:change:context:</li><li>并且将class方法重写，返回原类的Class。</li></ul><h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>通过addObserver:forKeyPath:options:context:方法注册观察者，观察者可以接收keyPath属性的变化事件。</li><li>在观察者中实现observeValueForKeyPath:ofObject:change:context:方法，当keyPath属性发生改变后，KVO会回调这个方法来通知观察者。</li><li>当观察者不需要监听时，可以调用removeObserver:forKeyPath:方法将KVO移除。需要注意的是，调用removeObserver需要在观察者消失之前，否则会导致Crash。</li></ol><p>例如，我们定义一个 YZPerson 类 继承自 NSObject ，里面有name 和 age 两个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface YZPerson : NSObject</span><br><span class="line">@property (nonatomic ,assign) int age;</span><br><span class="line">@property (nonatomic,strong) NSString  *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后在ViewController中，写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">   &#x2F;&#x2F;调用方法</span><br><span class="line">    [self setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setNameKVO&#123;</span><br><span class="line">    self.person &#x3D; [[YZPerson alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 注册观察者</span><br><span class="line">    NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    </span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:options context:@&quot;1111&quot;];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">  self.person.name &#x3D; @&quot;ccc&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 移除监听</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行之后结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KVOdemo[11482:141804] 监听到&lt;YZPerson: 0x6000004e8400&gt;的name属性值改变了 - &#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; ccc;</span><br><span class="line">    old &#x3D; &quot;&lt;null&gt;&quot;;</span><br><span class="line">&#125; - 1111- 1111</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>需要注意的是，上面代码中我们已经移除了监听，如果再次移除的话，就会crash</strong></p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">   &#x2F;&#x2F;调用方法</span><br><span class="line">    [self setNameKVO];</span><br><span class="line">&#125;</span><br><span class="line">-(void)setNameKVO&#123;</span><br><span class="line">   self.person &#x3D; [[YZPerson alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 注册观察者</span><br><span class="line">    NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    </span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:options context:@&quot;1111&quot;];</span><br><span class="line">       &#x2F;&#x2F; 移除监听</span><br><span class="line">    [person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">    &#x2F;&#x2F; 再次移除</span><br><span class="line">     [person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除多次会报错 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KVOdemo[9261:2171323] *** Terminating app due to uncaught exception &#39;NSRangeException&#39;, </span><br><span class="line">reason: &#39;Cannot remove an observer &lt;ViewController 0x139e07220&gt; for the key path &quot;name&quot; </span><br><span class="line">from &lt;YZPerson 0x281322f20&gt; because it is not registered as an observer.&#39;</span><br></pre></td></tr></table></figure><p><strong>如果忘记移除的话，有可能下次收到这个属性的变化的时候，会carsh</strong></p><p>所以，我们要保证add和remove是成对出现的</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>更多关于KVO的内容，包括KVO的本质，KVO内部的流程，手动调用KVO等，可以参考之前的一篇文章<a href="https://ityongzhen.github.io/%E5%85%B3%E4%BA%8EKVO%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html">关于KVO看这篇就够了</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/设计模式之(九)观察者模式.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://ityongzhen.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之(八)访问者模式</title>
    <link href="https://ityongzhen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E5%85%AB)%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ityongzhen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B(%E5%85%AB)%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-03-30T00:32:24.000Z</published>
    <updated>2019-12-12T05:40:55.617Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ityongzhen.github.io/设计模式之(八)访问者模式.html">本文首发于个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本文代码为java代码</strong></p><h3 id="什么是访问者模式"><a href="#什么是访问者模式" class="headerlink" title="什么是访问者模式"></a>什么是访问者模式</h3><p><a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">访问者模式</a>  属于行为型模式，在<a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">菜鸟教程</a>中的定义如下</p><blockquote><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>意图：主要将数据结构与数据操作分离。</li></ul><h3 id="主要解决："><a href="#主要解决：" class="headerlink" title="主要解决："></a>主要解决：</h3><ul><li>稳定的数据结构和易变的操作耦合问题。</li></ul><h3 id="何时使用："><a href="#何时使用：" class="headerlink" title="何时使用："></a>何时使用：</h3><ul><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</li></ul><h3 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h3><ul><li>在被访问的类里面加一个对外提供接待访问者的接口。</li></ul><h3 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h3><ul><li>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</li></ul><h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><ul><li>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>符合单一职责原则。 </li><li>优秀的扩展性。 3、灵活性。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>具体元素对访问者公布细节，违反了迪米特原则。 </li><li>具体元素变更比较困难。 </li><li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li></ul><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 </li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>假设我们写了一个平衡二叉树，那么对应的肯定有对应的肯定有添加元素，删除元素，中序遍历，后序遍历…等等。我们就以中序遍历二叉树为例，先看不用访问者模式会有什么问题。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>创建<code>Node</code>节点类，有左子树，右子树，父节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class Node&lt;E&gt; &#123;</span><br><span class="line">Integer element;</span><br><span class="line">Node&lt;Integer&gt; left;</span><br><span class="line">Node&lt;Integer&gt; right;</span><br><span class="line">Node&lt;Integer&gt; parent;</span><br><span class="line">public Node(Integer element, Node&lt;Integer&gt; parent) &#123;</span><br><span class="line">this.element &#x3D; element;</span><br><span class="line">this.parent &#x3D; parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BinarySearchTree"><a href="#BinarySearchTree" class="headerlink" title="BinarySearchTree"></a>BinarySearchTree</h3><p>创建<code>BinarySearchTree</code>类，有size，根节点<code>root</code>, 添加，删除，遍历等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree&lt;Integer&gt; &#123;</span><br><span class="line">private int size;</span><br><span class="line">public Node&lt;Integer&gt; root;</span><br><span class="line"></span><br><span class="line">public void add(Integer element) &#123;</span><br><span class="line">&#x2F;&#x2F;添加的代码就不写了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove(Integer element) &#123;</span><br><span class="line">&#x2F;&#x2F;删除的代码就不写了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... 其他接口</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中序遍历</span><br><span class="line"></span><br><span class="line">private void inorder(Node&lt;Integer&gt; node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null ) return;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历左子树</span><br><span class="line">inorder(node.left);</span><br><span class="line">&#x2F;&#x2F; 打印</span><br><span class="line">System.out.println(node.element);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历右子树</span><br><span class="line">inorder(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p>上面的代码是否也是可以用的，调用<code>inorder</code>遍历之后，这个二叉树可以按照中序遍历的方式打印出来，似乎没什么问题。但是仔细想想，其实存在问题的。因为这个我们写死了是打印出元素，假设我们真正使用的时候，不是想直接打印呢？而是想每个元素的值加上2 然后再打印呢？又或者每个元素的值加上10，而且不想打印呢?</p><p>你可能会说，那简单啊，直接改啊，例如每个元素的值加上2 然后再打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree&lt;Integer&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;... 其他接口</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中序遍历</span><br><span class="line"></span><br><span class="line">private void inorder(Node&lt;Integer&gt; node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null ) return;</span><br><span class="line">&#x2F;&#x2F; 遍历左子树</span><br><span class="line">inorder(node.left);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印</span><br><span class="line">System.out.println(node.element + 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历右子树</span><br><span class="line">inorder(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来也没问题，既然是加上2再打印那就直接加上2再打印咯。但是有如下两个问题</p><ul><li>很麻烦，每次不同的场景都要修改遍历的实现</li><li>如果是我们提供给外界使用的话，尽量不要让使用者修改内部实现。</li></ul><p>也就是说，有没有一种不修改遍历的具体实现，就能满足不同场景下的遍历呢？答案是有的，就是访问者模式</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree&lt;Integer&gt; &#123;</span><br><span class="line">private int size;</span><br><span class="line">public Node&lt;Integer&gt; root;</span><br><span class="line"></span><br><span class="line">public void add(Integer element) &#123;</span><br><span class="line">&#x2F;&#x2F;添加的代码就不写了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove(Integer element) &#123;</span><br><span class="line">&#x2F;&#x2F;删除的代码就不写了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... 其他接口</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中序遍历</span><br><span class="line">public void inorder(Visitor&lt;Integer&gt; visitor) &#123;</span><br><span class="line">if (visitor &#x3D;&#x3D; null) return;</span><br><span class="line">inorder(root, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void inorder(Node&lt;Integer&gt; node, Visitor&lt;Integer&gt; visitor) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null ) return;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历左子树</span><br><span class="line">inorder(node.left, visitor);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 元素给visitor，具体的逻辑由外界的visitor处理</span><br><span class="line">visitor.visit(node.element);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历右子树</span><br><span class="line">inorder(node.right, visitor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用访问者模式的调用"><a href="#使用访问者模式的调用" class="headerlink" title="使用访问者模式的调用"></a>使用访问者模式的调用</h3><p>这样修改之后，使用的时候</p><p>每个节点的值加上2再打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchTree&lt;Integer&gt; bst &#x3D; new BinarySearchTree&lt;&gt;();</span><br><span class="line">bst.preorder(new Visitor&lt;Integer&gt;() &#123;</span><br><span class="line">public boolean visit(Integer element) &#123;</span><br><span class="line">System.out.print(element + 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>每个节点的值加上10再打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchTree&lt;Integer&gt; bst &#x3D; new BinarySearchTree&lt;&gt;();</span><br><span class="line">bst.preorder(new Visitor&lt;Integer&gt;() &#123;</span><br><span class="line">public boolean visit(Integer element) &#123;</span><br><span class="line">System.out.print(element + 10);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的话，无论使用者如何更改需求，不同的场景下，都不用修改二叉树内部的遍历代码，都可以满足。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ityongzhen.github.io/设计模式之(八)访问者模式.html&quot;&gt;本文首发于个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://ityongzhen.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
