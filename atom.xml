<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>殷永振</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ityongzhen.github.io/"/>
  <updated>2020-02-29T08:22:05.298Z</updated>
  <id>https://ityongzhen.github.io/</id>
  
  <author>
    <name>ityongzhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter学习之Dart语法(三)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%89).html/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%89).html/</id>
    <published>2020-02-16T00:32:24.000Z</published>
    <updated>2020-02-29T08:22:05.298Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(三).html/">个人博客</a></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote><p>Dart是一个面向对象的语言，面向对象中非常重要的概念就是类，类产生了对象。</p></blockquote><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>在Dart中，定义类用class关键字。<br>类通常有两部分组成：成员（member）和方法（method）。<br>定义类的伪代码如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">  类型 成员名;</span><br><span class="line">  返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个简单的Person类：</p><ul><li>这里有一个注意点: 我们在方法中使用属性(成员/实例变量)时，并没有加this；</li><li>Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略；</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在吃东西'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来使用这个类，创建对应的对象：</p><ul><li>注意：从Dart2开始，new关键字可以省略。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.创建类的对象</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">// 直接使用Person()也可以创建</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.给对象的属性赋值</span></span><br><span class="line">  p.name = <span class="string">'eagle'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.调用对象的方法</span></span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="普通构造方法"><a href="#普通构造方法" class="headerlink" title="普通构造方法"></a>普通构造方法</h3><p>我们知道, 当通过类创建一个对象时，会调用这个类的构造方法。</p><ul><li>当类中没有明确指定构造方法时，将默认拥有一个无参的构造方法。</li><li>前面的Person中我们就是在调用这个构造方法.</li></ul><p>我们也可以根据自己的需求，定义自己的构造方法:</p><p><strong>注意一：</strong>当有了自己的构造方法时，默认的构造方法将会失效，不能使用</p><ul><li>当然，你可能希望明确的写一个默认的构造方法，但是会和我们自定义的构造方法冲突；</li><li>这是因为Dart本身不支持函数的重载（名称相同, 参数不同的方式）。</li></ul><p><strong>注意二：</strong>这里我还实现了toString方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在实现构造方法时，通常做的事情就是通过<strong>参数给属性</strong>赋值<br>为了简化这一过程, Dart提供了一种更加简洁的语法糖形式.<br>上面的构造方法可以优化成下面的写法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Person(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span> &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="constructor">Person(<span class="params">this</span>.<span class="params">name</span>, <span class="params">this</span>.<span class="params">age</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="命名构造方法"><a href="#命名构造方法" class="headerlink" title="命名构造方法"></a>命名构造方法</h3><p>但是在开发中, 我们确实希望实现更多的构造方法，怎么办呢？</p><p>因为不支持方法（函数）的重载，所以我们没办法创建相同名称的构造方法。</p><p>我们需要使用命名构造方法:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person() &#123;</span><br><span class="line">    name = <span class="string">''</span>;</span><br><span class="line">    age = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 命名构造方法</span></span><br><span class="line">  Person.withArgments(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">print</span>(p1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.withArgments(<span class="string">'eagle'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">print</span>(p2);</span><br></pre></td></tr></table></figure><p>在之后的开发中, 我们也可以利用命名构造方法，提供更加便捷的创建对象方式:</p><p>比如开发中，我们需要经常将一个Map转成对象，可以提供如下的构造方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 新的构造方法</span></span><br><span class="line">Person.fromMap(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span>) &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="built_in">map</span>[<span class="string">'name'</span>];</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="built_in">map</span>[<span class="string">'age'</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上面的构造方法创建对象</span></span><br><span class="line"> var p3 = <span class="keyword">new</span> Person.fromMap(&#123;<span class="string">'name'</span>: <span class="string">'kobe'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;);</span><br><span class="line"> <span class="built_in">print</span>(p3);</span><br></pre></td></tr></table></figure><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>我们来重新定义一个类Point, 传入x/y，可以得到它们的距离distance:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误写法</span></span><br><span class="line">  <span class="comment">// Point(this.x, this.y) &#123;</span></span><br><span class="line">  <span class="comment">//   distance = sqrt(x * x + y * y);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的写法</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : distance = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种初始化变量的方法, 我们称之为初始化列表(Initializer list)</p><h3 id="重定向构造方法"><a href="#重定向构造方法" class="headerlink" title="重定向构造方法"></a>重定向构造方法</h3><p>在某些情况下, 我们希望在一个构造方法中去调用另外一个构造方法, 这个时候可以使用重定向构造方法：</p><p>在一个构造函数中，去调用另外一个构造函数（注意：是在冒号后面使用this调用）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="constructor">Person(<span class="params">this</span>.<span class="params">name</span>, <span class="params">this</span>.<span class="params">age</span>)</span>;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>from<span class="constructor">Name(String <span class="params">name</span>)</span> : this(name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量构造方法"><a href="#常量构造方法" class="headerlink" title="常量构造方法"></a>常量构造方法</h3><p>在某些情况下，传入相同值时，我们希望返回同一个对象，这个时候，可以使用常量构造方法.<br>默认情况下，创建对象时，即使传入相同的参数，创建出来的也不是同一个对象，看下面代码:</p><p>这里我们使用identical(对象1, 对象2)函数来判断两个对象是否是同一个对象:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 如果将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的</p><p>这样的构造方法就称之为常量构造方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">const</span> Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">const</span> Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造方法有一些注意点:</p><ul><li>注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的.</li><li>注意二: 为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字</li></ul><p>如果是将结果赋值给const修饰的标识符时，const可以省略.</p><h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><p>Dart提供了factory关键字, 用于通过工厂去获取对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Person&gt; _cache = &lt;<span class="built_in">String</span>, Person&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Person(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> p = Person._internal(name);</span><br><span class="line">      _cache[name] = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person._internal(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h2><p>默认情况下，Dart中类定义的属性是可以直接被外界访问的。<br>但是某些情况下，我们希望监控这个类的属性被访问的过程，这个时候就可以使用setter和getter了</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> d = Dog(<span class="string">"黄色"</span>);</span><br><span class="line">  d.setColor = <span class="string">"黑色"</span>;</span><br><span class="line">  <span class="built_in">print</span>(d.getColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog &#123;</span><br><span class="line">  <span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">String</span> <span class="built_in">get</span> getColor &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span> setColor(<span class="keyword">String</span> <span class="built_in">color</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">color</span> = <span class="built_in">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Dog(<span class="keyword">this</span>.<span class="built_in">color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。<br>Dart中的继承使用extends关键字，子类中使用super来访问父类。<br>父类中的所有成员变量和方法都会被继承,，但是构造方法除外。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">List</span>&lt;<span class="type">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="type">Person</span>();</span><br><span class="line">  p.age = <span class="number">18</span>;</span><br><span class="line">  p.run();</span><br><span class="line">  print(p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print('在奔跑ing');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以拥有自己的成员变量, 并且可以对父类的方法进行重写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    print('$name在奔跑ing');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类中可以调用父类的构造方法，对某些属性进行初始化：</p><p>子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。<br>如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Animal(<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'在奔跑ing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) : name=name, <span class="keyword">super</span>(age);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在奔跑ing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span>, age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们知道，继承是多态使用的前提。<br>所以在定义很多通用的<strong>调用接口</strong>时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。<br>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。<br>什么是 抽象方法? 在Dart中没有具体实现的方法(没有方法体)，就是抽象方法。</p><p>抽象方法，必须存在于抽象类中。<br>抽象类是使用abstract声明的类。</p><p>下面的代码中, Shape类就是一个抽象类, 其中包含一个抽象方法.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  getArea();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  double r;</span><br><span class="line"></span><br><span class="line">  <span class="type">Circle</span>(<span class="keyword">this</span>.r);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> r * r * <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  double w;</span><br><span class="line">  double h;</span><br><span class="line"></span><br><span class="line">  <span class="type">Reactangle</span>(<span class="keyword">this</span>.w, <span class="keyword">this</span>.h);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项:</p><p><strong>注意一：</strong>抽象类不能实例化.<br><strong>注意二：</strong>抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写.</p><h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p>Dart中的接口比较特殊, 没有一个专门的关键字来声明接口.<br>默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现(因为Dart不支持多继承)<br>在开发中，我们通常将用于给别人实现的类声明为抽象类:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Runner</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'超人在奔跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'超人在飞'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h2><p>在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。<br>但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢?</p><p>使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。</p><p>Dart提供了另外一种方案: Mixin混入的方式</p><p>除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。<br>只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  var superMan = SuperMain();</span><br><span class="line">  superMan.run();</span><br><span class="line">  superMan.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Runner &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(<span class="string">'在奔跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Flyer &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    print(<span class="string">'在飞翔'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implements的方式要求必须对其中的方法进行重新实现</span></span><br><span class="line"><span class="comment">// class SuperMan implements Runner, Flyer &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">SuperMain</span> <span class="symbol">with</span> <span class="symbol">Runner, <span class="symbol">Flyer</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员和方法"><a href="#类成员和方法" class="headerlink" title="类成员和方法"></a>类成员和方法</h2><p>前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法<br>在Dart中我们使用static关键字来定义:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> stu = Student();</span><br><span class="line">  stu.name = <span class="string">'eagle'</span>;</span><br><span class="line">  stu.sno = <span class="number">110</span>;</span><br><span class="line">  stu.study();</span><br><span class="line"></span><br><span class="line">  Student.time = <span class="string">'早上8点'</span>;</span><br><span class="line">  <span class="comment">// stu.time = '早上9点'; 错误做法, 实例对象不能访问类成员</span></span><br><span class="line">  Student.attendClass();</span><br><span class="line">  <span class="comment">// stu.attendClass(); 错误做法, 实现对象补鞥呢访问类方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> sno;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> time;</span><br><span class="line"></span><br><span class="line">  study() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在学习'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> attendClass() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'去上课'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举在开发中也非常常见, 枚举也是一种特殊的类, 通常用于表示固定数量的常量值。</p><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举使用enum关键字来进行定义:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(Colors.red);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colors</span> &#123;</span></span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的属性"><a href="#枚举的属性" class="headerlink" title="枚举的属性"></a>枚举的属性</h3><p>枚举类型中有两个比较常见的属性:</p><p>index: 用于表示每个枚举常量的索引, 从0开始.<br>values: 包含每个枚举值的List.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">red</span>.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">green</span>.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">blue</span>.index);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(Colors.values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  <span class="built_in">red</span>,</span><br><span class="line">  <span class="built_in">green</span>,</span><br><span class="line">  <span class="built_in">blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型的注意事项:</p><ul><li>注意一: 您不能子类化、混合或实现枚举。</li><li>注意二: 不能显式实例化一个枚举</li></ul><p>参考 <a href="https://juejin.im/post/5d76340c6fb9a06adb800961" target="_blank" rel="noopener">https://juejin.im/post/5d76340c6fb9a06adb800961</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(三).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习之Dart语法(二)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%BA%8C).html/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%BA%8C).html/</id>
    <published>2020-02-13T00:32:24.000Z</published>
    <updated>2020-02-29T07:29:38.418Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(二).html/">个人博客</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基本定义"><a href="#函数的基本定义" class="headerlink" title="函数的基本定义"></a>函数的基本定义</h3><ul><li>Dart是一种真正的面向对象语言，所以即使函数也是对象，所有也有类型, 类型就是Function。</li><li>这也就意味着函数可以作为变量定义或者作为其他函数的参数或者返回值.</li></ul><p>函数的定义方式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值 函数的名称(参数列表) &#123;</span><br><span class="line">  函数体</span><br><span class="line">  <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的定义方式, 我们定义一个完整的函数:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum(<span class="built_in">num</span> num1, <span class="built_in">num</span> num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Effective Dart建议对公共的API, 使用类型注解, 但是如果我们省略掉了类型, 依然是可以正常工作的</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sum</span>(num1, num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外, 如果函数中只有一个表达式, 那么可以使用箭头语法(arrow syntax)</p><ul><li>注意, 这里面只能是一个表达式, 不能是一个语句</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum<span class="comment">(num1, num2)</span> =&gt; <span class="symbol">num1</span> + <span class="symbol">num2</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的参数问题"><a href="#函数的参数问题" class="headerlink" title="函数的参数问题"></a>函数的参数问题</h3><blockquote><p>函数的参数可以分成两类: 必须参数和可选参数<br>前面使用的参数都是必须参数.</p></blockquote><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>可选参数可以分为 命名可选参数 和 位置可选参数<br>定义方式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命名可选参数: &#123;para<span class="name">m1</span>, para<span class="name">m2</span>, ...&#125;</span><br><span class="line">位置可选参数: [para<span class="name">m1</span>, para<span class="name">m2</span>, ...]</span><br></pre></td></tr></table></figure><p>命名可选参数的演示:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数</span></span><br><span class="line">print<span class="constructor">Info1(String <span class="params">name</span>, &#123;<span class="params">int</span> <span class="params">age</span>, <span class="params">double</span> <span class="params">height</span>&#125;)</span> &#123;</span><br><span class="line">  print('name=$name age=$age height=$height');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printInfo1函数</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>')</span>; <span class="comment">// name=eagle age=null height=null</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">age</span>: 18)</span>; <span class="comment">// name=eagle age=18 height=null</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">age</span>: 18, <span class="params">height</span>: 1.88)</span>; <span class="comment">// name=eagle age=18 height=1.88</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">height</span>: 1.88)</span>; <span class="comment">// name=eagle age=null height=1.88</span></span><br></pre></td></tr></table></figure><p>位置可选参数的演示:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义位置可选参数</span></span><br><span class="line">print<span class="constructor">Info2(String <span class="params">name</span>, [<span class="params">int</span> <span class="params">age</span>, <span class="params">double</span> <span class="params">height</span>])</span> &#123;</span><br><span class="line">  print('name=$name age=$age height=$height');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printInfo2函数</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>')</span>; <span class="comment">// name=eagle age=null height=null</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>', 18)</span>; <span class="comment">// name=eagle age=18 height=null</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>', 18, 1.88)</span>; <span class="comment">// name=eagle age=18 height=1.88</span></span><br></pre></td></tr></table></figure><p>命名可选参数, 可以指定某个参数是必传的(使用@required, 有问题)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数的必须</span></span><br><span class="line">printInfo3(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age, <span class="built_in">double</span> height, <span class="meta">@required</span> <span class="built_in">String</span> address&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span> address=<span class="subst">$address</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>参数可以有默认值, 在不传入的情况下, 使用默认值</p><p>注意, 只有可选参数才可以有默认值, 必须参数不能有默认值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数的默认值</span></span><br><span class="line">printInfo4(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age = <span class="number">18</span>, <span class="built_in">double</span> height=<span class="number">1.88</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart中的main函数就是一个接受可选的列表参数作为参数的, 所以在使用main函数时, 我们可以传入参数, 也可以不传入</p><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>在很多语言中, 函数并不能作为一等公民来使用, 比如Java/OC. 这种限制让编程不够灵活, 所以现代的编程语言基本都支持函数作为一等公民来使用, Dart也支持.<br>这就意味着你可以将函数赋值给一个变量, 也可以将函数作为另外一个函数的参数或者返回值来使用.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.将函数赋值给一个变量</span></span><br><span class="line">  <span class="keyword">var</span> bar = foo;</span><br><span class="line">  <span class="built_in">print</span>(bar);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.将函数作为另一个函数的参数</span></span><br><span class="line">  test(foo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">  <span class="keyword">var</span> func =getFunc();</span><br><span class="line">  func(<span class="string">'kobe'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个函数</span></span><br><span class="line">foo(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'传入的name:<span class="subst">$name</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将函数作为另外一个函数的参数</span></span><br><span class="line">test(<span class="built_in">Function</span> func) &#123;</span><br><span class="line">  func(<span class="string">'eagle'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">getFunc() &#123;</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数的使用"><a href="#匿名函数的使用" class="headerlink" title="匿名函数的使用"></a>匿名函数的使用</h3><p>大部分我们定义的函数都会有自己的名字， 比如前面定义的foo、test函数等等。<br>但是某些情况下，给函数命名太麻烦了，我们可以使用没有名字的函数，这种函数可以被称之为匿名函数( anonymous function)，也可以叫lambda或者closure。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">List</span>&lt;String&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.定义数组</span></span><br><span class="line">  <span class="keyword">var</span> movies = [<span class="string">'盗梦空间'</span>, <span class="string">'星际穿越'</span>, <span class="string">'少年派'</span>, <span class="string">'大话西游'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.使用forEach遍历: 有名字的函数</span></span><br><span class="line">  printElement(item) &#123;</span><br><span class="line">    <span class="keyword">print</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  movies.<span class="keyword">forEach</span>(printElement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.使用forEach遍历: 匿名函数</span></span><br><span class="line">  movies.<span class="keyword">forEach</span>((item) &#123;</span><br><span class="line">    <span class="keyword">print</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  movies.<span class="keyword">forEach</span>((item) =&gt; <span class="keyword">print</span>(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>dart中的词法有自己明确的作用域范围，它是根据代码的结构({})来决定作用域范围的<br>优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// var name = 'main';</span></span><br><span class="line">  <span class="keyword">void</span> foo() &#123;</span><br><span class="line">    <span class="comment">// var name = 'foo';</span></span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h3><p>闭包可以访问其词法范围内的变量，即使函数在其他地方被使用，也可以正常的访问。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">num</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i + addBy;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adder2 = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">10</span>)); <span class="comment">// 12</span></span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">6</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adder5 = makeAdder(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder5(<span class="number">10</span>)); <span class="comment">// 15</span></span><br><span class="line">  <span class="built_in">print</span>(adder5(<span class="number">6</span>)); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值问题"><a href="#返回值问题" class="headerlink" title="返回值问题"></a>返回值问题</h3><p>所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo()); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'foo function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="除法、整除、取模运算"><a href="#除法、整除、取模运算" class="headerlink" title="除法、整除、取模运算"></a>除法、整除、取模运算</h3><p>我们来看一下除法、整除、取模运算</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> / <span class="number">3</span>); <span class="comment">// 除法操作, 结果2.3333..</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> ~/ <span class="number">3</span>); <span class="comment">// 整除操作, 结果2;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> % <span class="number">3</span>); <span class="comment">// 取模操作, 结果1;</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="??=赋值操作"></a>??=赋值操作</h3><p>dart有一个很多语言都不具备的赋值运算符：</p><ul><li>当变量为null时，使用后面的内容进行赋值。</li><li>当变量有值时，使用自己原来的值。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> name1 = <span class="string">'eagle'</span>;</span><br><span class="line">  <span class="built_in">print</span>(name1);</span><br><span class="line">  <span class="comment">// var name2 = 'kobe';</span></span><br><span class="line">  <span class="keyword">var</span> name2 = <span class="keyword">null</span>;</span><br><span class="line">  name2 ??= <span class="string">'james'</span>; </span><br><span class="line">  <span class="built_in">print</span>(name2); <span class="comment">// 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件运算符："><a href="#条件运算符：" class="headerlink" title="条件运算符："></a>条件运算符：</h3><p>Dart中包含一直比较特殊的条件运算符：expr1 ?? expr2</p><ul><li>如果expr1是null，则返回expr2的结果;</li><li>如果expr1不是null，直接使用expr1的结果。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">temp</span> = <span class="string">'eagle'</span>;</span><br><span class="line">var <span class="keyword">temp</span> = <span class="keyword">null</span>;</span><br><span class="line">var <span class="type">name</span> = <span class="keyword">temp</span> ?? <span class="string">'kobe'</span>;</span><br><span class="line">print(<span class="type">name</span>);</span><br></pre></td></tr></table></figure><h3 id="级联语法："><a href="#级联语法：" class="headerlink" title="级联语法：.."></a>级联语法：..</h3><ul><li>某些时候，我们希望对一个对象进行连续的操作，这个时候可以使用级联语法</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  void <span class="builtin-name">run</span>() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is running"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void eat() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is eating"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swim() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is swimming"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p1 = Person();</span><br><span class="line">  p1.name = <span class="string">'eagle'</span>;</span><br><span class="line">  p1.<span class="builtin-name">run</span>();</span><br><span class="line">  p1.eat();</span><br><span class="line">  p1.swim();</span><br><span class="line"></span><br><span class="line">  final p2 = Person()</span><br><span class="line">              <span class="built_in">..</span>name = <span class="string">"eagle"</span></span><br><span class="line">              <span class="built_in">..</span><span class="builtin-name">run</span>()</span><br><span class="line">              <span class="built_in">..</span>eat()</span><br><span class="line">              <span class="built_in">..</span>swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>和大部分语言的特性比较相似，这里就不再详细赘述，看一下即可。</p><h3 id="if和else"><a href="#if和else" class="headerlink" title="if和else"></a>if和else</h3><p>和其他语言用法一样<br>这里有一个注意点：不支持非空即真或者非0即真，必须有明确的bool类型</p><ul><li>我们来看下面name为null的判断</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var age = <span class="built_in">null</span>;</span><br><span class="line"><span class="keyword">if</span>(age)&#123; <span class="comment">//错误的用法</span></span><br><span class="line">   <span class="keyword">print</span>(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h3><p>基本的for循环</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  print(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for in遍历List和Set类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'eagle'</span>, <span class="string">'kobe'</span>, <span class="string">'curry'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names) &#123;</span><br><span class="line">  <span class="built_in">print</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while和do-while和其他语言一致<br>break和continue用法也是一致</p><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>普通的switch使用</p><p>注意：每一个case语句，默认情况下必须以一个break结尾</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> direction = <span class="string">'east'</span>;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'east'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'东面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'south'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'南面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'west'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'西面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'north'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'北面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'其他方向'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://juejin.im/post/5d76340c6fb9a06adb800961" target="_blank" rel="noopener">Flutter(三)之搞定Dart（一）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(二).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习之Dart语法(一)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80).html/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80).html/</id>
    <published>2020-02-10T00:32:24.000Z</published>
    <updated>2020-02-29T06:18:32.280Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(一).html/">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准 。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</li><li>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system</li></ul><p><strong>Google为Flutter选择了Dart作为开发语言</strong></p><p>关于Dart的环境安装和配置这里就不赘述了。</p><h2 id="新建程序"><a href="#新建程序" class="headerlink" title="新建程序"></a>新建程序</h2><p>用VSCode新建一个Dart文件，默认是如下代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这也和Java,C等等其他语言一样，main函数作为入口。</p><ul><li>Dart语言的入口也是main函数，并且必须显示的进行定义；</li><li>Dart的入口函数main是没有返回值的；</li><li>传递给main的命令行参数，是通过List<String>完成的。<ul><li>从字面值就可以理解List是Dart中的集合类型。</li><li>其中的每一个String都表示传递给main的一个参数；</li></ul></li><li>定义字符串的时候，可以使用单引号或双引号；</li><li>每行语句必须使用分号结尾，很多语言并不需要分号，比如Swift、JavaScript；</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="明确声明-Explicit"><a href="#明确声明-Explicit" class="headerlink" title="明确声明(Explicit)"></a>明确声明(Explicit)</h3><p>明确声明变量的方式, 格式如下:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量类型 变量名称 = 赋值<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>示例代码:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>注意: 定义的变量可以修改值, 但是不能赋值其他类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="attribute">content</span> = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="attribute">content</span> = <span class="string">'Hello China'</span>; <span class="comment">// 正确的</span></span><br><span class="line"><span class="attribute">content</span> = <span class="number">111</span>; <span class="comment">// 错误的, 将一个int值赋值给一个String变量</span></span><br></pre></td></tr></table></figure><h3 id="类型推导-Type-Inference"><a href="#类型推导-Type-Inference" class="headerlink" title="类型推导(Type Inference)"></a>类型推导(Type Inference)</h3><p>和swift等语言类似，Dart也是支持类型推导的，类型推导声明变量的方式, 格式如下:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="keyword">dynamic</span>/<span class="keyword">const</span>/<span class="keyword">final</span> 变量名称 = 赋值;</span><br></pre></td></tr></table></figure><h4 id="var的使用"><a href="#var的使用" class="headerlink" title="var的使用"></a>var的使用</h4><p>var的使用示例:</p><ul><li>runtimeType用于获取变量当前的类型</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">name</span> = <span class="string">'ITYongzhen'</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// String</span></span><br></pre></td></tr></table></figure><p>var的错误用法:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="string">'eagle'</span>; <span class="comment">// 不可以将String赋值给一个int类型</span></span><br></pre></td></tr></table></figure><h4 id="dynamic的使用"><a href="#dynamic的使用" class="headerlink" title="dynamic的使用"></a>dynamic的使用</h4><p>如果确实希望这样做,可以使用dynamic来声明变量:</p><ul><li>但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">name</span> = <span class="number">18</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// int</span></span><br></pre></td></tr></table></figure><h4 id="final-amp-const的使用"><a href="#final-amp-const的使用" class="headerlink" title="final&amp;const的使用"></a>final&amp;const的使用</h4><p>final和const都是用于定义常量的, 也就是定义之后值都不可以修改</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">name</span> = <span class="string">'ITyongzhen'</span>; <span class="comment">// 错误做法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="number">20</span>; <span class="comment">// 错误做法</span></span><br></pre></td></tr></table></figure><h4 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h4><p>const在赋值时, 赋值的内容必须是在编译期间就确定下来的<br>final在赋值时, 可以动态获取, 比如赋值一个函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> getName() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'eagle'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = getName(); <span class="comment">// 错误的做法, 因为要执行函数才能获取到值</span></span><br><span class="line">  <span class="keyword">final</span> name = getName(); <span class="comment">// 正确的做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final和const小案例:</p><ul><li>首先, const是不可以赋值为DateTime.now()</li><li>其次, final一旦被赋值后就有确定的结果, 不会再次赋值</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const time = DateTime.now(); // 错误的赋值方式</span></span><br><span class="line">final time = DateTime.now();</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">time</span>); <span class="comment">// 2020-02-05 12:04:50.052626</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">time</span>); <span class="comment">// 2020-02-05 12:04:50.052626</span></span><br></pre></td></tr></table></figure><p>const放在赋值语句的右边，可以共享对象，提高性能:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">Person</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> a = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="keyword">final</span> b = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(a, b)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> m = Person();</span><br><span class="line">  <span class="keyword">final</span> n = Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(m, n)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><h4 id="int和double"><a href="#int和double" class="headerlink" title="int和double"></a><code>int</code>和<code>double</code></h4><p>对于数值来说，我们也不用关心它是否有符号，以及数据的宽度和精度等问题。只要记着整数用<code>int</code>，浮点数用<code>double</code>就行了。<br>不过，要注意的是<code>Dart</code>中的<code>int</code>和<code>double</code>可表示的范围并不是固定的，它取决于运行Dart的平台。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.整数类型int</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> hexAge = <span class="number">0x12</span>;</span><br><span class="line"><span class="built_in">print</span>(age);</span><br><span class="line"><span class="built_in">print</span>(hexAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.浮点类型double</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">height</span> = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">height</span>);</span><br></pre></td></tr></table></figure><h4 id="字符串和数字之间的转化"><a href="#字符串和数字之间的转化" class="headerlink" title="字符串和数字之间的转化"></a>字符串和数字之间的转化</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串和数字转化</span></span><br><span class="line"><span class="comment">// 1.字符串转数字</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">'111'</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="built_in">double</span>.parse(<span class="string">'12.22'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;one&#125;</span> <span class="subst">$&#123;one.runtimeType&#125;</span>'</span>); <span class="comment">// 111 int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;two&#125;</span> <span class="subst">$&#123;two.runtimeType&#125;</span>'</span>); <span class="comment">// 12.22 double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.数字转字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123.456</span>;</span><br><span class="line"><span class="keyword">var</span> num1Str = num1.toString();</span><br><span class="line"><span class="keyword">var</span> num2Str = num2.toString();</span><br><span class="line"><span class="keyword">var</span> num2StrD = num2.toStringAsFixed(<span class="number">2</span>); <span class="comment">// 保留两位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num1Str&#125;</span> <span class="subst">$&#123;num1Str.runtimeType&#125;</span>'</span>); <span class="comment">// 123 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num2Str&#125;</span> <span class="subst">$&#123;num2Str.runtimeType&#125;</span>'</span>); <span class="comment">// 123.456 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num2StrD&#125;</span> <span class="subst">$&#123;num2StrD.runtimeType&#125;</span>'</span>); <span class="comment">// 123.46 String</span></span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型中,Dart提供了一个bool的类型, 取值为true和false</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="keyword">var</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$isFlag</span> <span class="subst">$&#123;isFlag.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p><strong>注意: Dart中不能判断非0即真, 或者非空即真</strong></p><p>Dart的类型安全性意味着您不能使用if(非booleanvalue)或assert(非booleanvalue)之类的代码。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">message</span> = <span class="string">'Hello Dart'</span>;</span><br><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">message</span>) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  print(message)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>Dart字符串是UTF-16编码单元的序列。您可以使用单引号或双引号创建一个字符串:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义字符串的方式</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="symbol">'Hello</span> <span class="type">World</span>';</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"Hello Dart"</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="symbol">'Hello</span>\<span class="symbol">'Fullte</span>r';</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">"Hello'Fullter"</span>;</span><br></pre></td></tr></table></figure><p>可以使用三个单引号或者双引号表示多行字符串:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="number">2</span>.表示多行字符串的方式</span><br><span class="line">var message1 = <span class="string">'''</span></span><br><span class="line"><span class="string">哈哈哈</span></span><br><span class="line"><span class="string">呵呵呵</span></span><br><span class="line"><span class="string">嘿嘿嘿'''</span>;</span><br></pre></td></tr></table></figure><p>字符串和其他变量或表达式拼接: 使用<code>${expression}</code>, 如果表达式是一个标识符, 那么<code>{}</code>可以省略</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.拼接其他变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$age</span>, height is <span class="subst">$height</span>'</span>);</span><br></pre></td></tr></table></figure><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><ul><li>集合类型的定义</li></ul><p>对于集合类型，Dart则内置了最常用的三种：<code>List / Set / Map</code>。<br>其中，<code>List</code>可以这样来定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$letters</span> <span class="subst">$&#123;letters.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$&#123;numbers.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>其中，<code>set</code>可以这样来定义：</p><p>其实，也就是把[]换成{}就好了。<br>Set和List最大的两个不同就是：Set是无序的，并且元素是不重复的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set的定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> lettersSet = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$lettersSet</span> <span class="subst">$&#123;lettersSet.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">int</span>&gt; numbersSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbersSet</span> <span class="subst">$&#123;numbersSet.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>最后，Map是我们常说的字典类型，它的定义是这样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map的定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> infoMap1 = &#123;<span class="string">'name'</span>: <span class="string">'eagle'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$infoMap1</span> <span class="subst">$&#123;infoMap1.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; infoMap2 = &#123;<span class="string">'height'</span>: <span class="number">1.88</span>, <span class="string">'address'</span>: <span class="string">'北京市'</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$infoMap2</span> <span class="subst">$&#123;infoMap2.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><h4 id="集合的常见操作"><a href="#集合的常见操作" class="headerlink" title="集合的常见操作"></a>集合的常见操作</h4><p>了解了这三个集合的定义方式之后，我们来看一些最基础的公共操作</p><p>第一类，是所有集合都支持的获取长度的属性length：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取集合的长度</span></span><br><span class="line"><span class="keyword">print</span>(letters.length);</span><br><span class="line"><span class="keyword">print</span>(lettersSet.length);</span><br><span class="line"><span class="keyword">print</span>(infoMap1.length);</span><br></pre></td></tr></table></figure><p>第二类, 是添加/删除/包含操作</p><p>并且，对List来说，由于元素是有序的，它还提供了一个删除指定索引位置上元素的方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加/删除/包含元素</span></span><br><span class="line">numbers.add(<span class="number">5</span>);</span><br><span class="line">numbersSet.add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$numbersSet</span>'</span>);</span><br><span class="line"></span><br><span class="line">numbers.remove(<span class="number">1</span>);</span><br><span class="line">numbersSet.remove(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$numbersSet</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers.contains(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">print</span>(numbersSet.contains(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// List根据index删除元素</span></span><br><span class="line">numbers.removeAt(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span>'</span>);</span><br></pre></td></tr></table></figure><p>第三类，是Map的操作</p><p>由于它有key和value，因此无论是读取值，还是操作，都要明确是基于key的，还是基于value的，或者是基于key/value对的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map的操作</span></span><br><span class="line"><span class="comment">// 1.根据key获取value</span></span><br><span class="line"><span class="built_in">print</span>(infoMap1[<span class="string">'name'</span>]); <span class="comment">// eagle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取所有的entries</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.entries&#125;</span> <span class="subst">$&#123;infoMap1.entries.runtimeType&#125;</span>'</span>); <span class="comment">// (MapEntry(name: eagle), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取所有的keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.keys&#125;</span> <span class="subst">$&#123;infoMap1.keys.runtimeType&#125;</span>'</span>); <span class="comment">// (name, age) _CompactIterable&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取所有的values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.values&#125;</span> <span class="subst">$&#123;infoMap1.values.runtimeType&#125;</span>'</span>); <span class="comment">// (eagle, 18) _CompactIterable&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.判断是否包含某个key或者value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.containsKey(<span class="string">'age'</span>)&#125;</span> <span class="subst">$&#123;infoMap1.containsValue(<span class="number">18</span>)&#125;</span>'</span>); <span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.根据key删除元素</span></span><br><span class="line">infoMap1.remove(<span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1&#125;</span>'</span>); <span class="comment">// &#123;name: eagle&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(一).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之类型转换</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html/</id>
    <published>2020-01-09T21:32:24.000Z</published>
    <updated>2020-03-10T02:55:45.736Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之类型转换.html/">个人博客</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>C语言风格的类型转换符<ul><li><code>(type)expression</code></li><li><code>type(expression)</code></li></ul></li><li>C++中有4个类型转换符<ul><li><code>static_cast</code></li><li><code>dynamic_cast</code></li><li><code>reinterpret_cast</code></li><li><code>const_cast</code></li><li>使用格式：<code>xx_cast&lt;type&gt;(expression)</code></li></ul></li></ul><p>我们有如下Person类和Student类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">     <span class="built_in">void</span> run() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span> : <span class="symbol">public</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接用子类指针指向父类对象，编译报错</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *p = <span class="keyword">new</span> <span class="type">Person</span>(); <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><p>C语言的做法一般是</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *p = (Student *)<span class="keyword">new</span> <span class="type">Person</span>(); <span class="comment">//编译正常</span></span><br></pre></td></tr></table></figure><p>强制转换只是欺骗编译器，有时候编译正常，执行会报错。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h2><ul><li>一般用于去除<code>const</code>属性，将<code>const</code>转换成非<code>const</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1-&gt;age = <span class="number">10</span>; <span class="comment">//编译报错</span></span><br><span class="line">    </span><br><span class="line">Person *p2 = <span class="keyword">const_cast</span>&lt;Person *&gt;(p1);</span><br><span class="line">p2-&gt;age = <span class="number">10</span>; <span class="comment">//编译正常</span></span><br></pre></td></tr></table></figure><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h2><ul><li>◼ 一般用于多态类型的转换，有运行时安全检测</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student *stu1 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(P1); <span class="comment">//null</span></span><br><span class="line">    Student *stu2 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line">    Car *car = <span class="keyword">dynamic_cast</span>&lt;Car *&gt;(P1); <span class="comment">//null</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; car&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x100660110</span></span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>上面的代码中，随便编译都是正常的。但是运行的事，检测到P1不是Student类型，也不是Car类型，所以转换之后的stu1和car都是Null.</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h2><p>对比dynamic_cast，缺乏运行时安全检测</p><ul><li>不能交叉转换（不是同一继承体系的，无法转换）</li><li>常用于基本数据类型的转换、非const转成const</li></ul><p>上面的代码中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student *stu1 = <span class="keyword">static_cast</span>&lt;Student *&gt;(P1);</span><br><span class="line">    Student *stu2 = <span class="keyword">static_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line"><span class="comment">//    Car *car = static_cast&lt;Car *&gt;(P1); //编译报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100555390</span></span><br><span class="line"><span class="number">0x10063e9b0</span></span><br></pre></td></tr></table></figure><p>可知<code>Person</code>类型的P1可以转换为 Person <code>类型或者</code>Student `类型</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h2><ul><li>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝</li><li>可以交叉转换</li><li>可以将指针和整数互相转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line"> Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line"> Student *stu1 = <span class="keyword">reinterpret_cast</span>&lt;Student *&gt;(P1); <span class="comment">//null</span></span><br><span class="line"> Student *stu2 = <span class="keyword">reinterpret_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line"> Car *car = <span class="keyword">reinterpret_cast</span>&lt;Car *&gt;(P1);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; car&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出如下，可知都可以转换成功，因为只是拷贝二进制</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10062e6e0</span></span><br><span class="line"><span class="number">0x10062b940</span></span><br><span class="line"><span class="number">0x10062e6e0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之类型转换.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类型转换&quot;&gt;&lt;a href=&quot;#类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型转换&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之模板</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/</id>
    <published>2019-12-27T21:32:24.000Z</published>
    <updated>2020-03-09T02:41:02.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之模板.html/">个人博客</a></p><h2 id="模板（template）"><a href="#模板（template）" class="headerlink" title="模板（template）"></a>模板（template）</h2><ul><li><p>泛型，是一种将类型参数化以达到代码复用的技术，很多语言中都有，例如Java,Swift等，C++中使用模板来实现泛型</p></li><li><p>模板的使用格式如下</p><ul><li><code>template &lt;typename\class T&gt;</code></li><li><code>typename和class是等价的</code></li></ul></li><li><p>模板没有被使用时，是不会被实例化出来的</p></li><li><p>模板的声明和实现如果分离到.h和.cpp中，会导致链接错误</p></li><li><p>一般将模板的声明和实现统一放到一个.hpp文件中</p></li></ul><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>格式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者和下面是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 形参名，<span class="keyword">typename</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们有2个函数，分别计算int 类型和 double类型的加法运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的每个函数只能实现一种数据类型的运算，所以我们用模板就可以用一个函数来表示</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="literal">T</span>&gt;</span><br><span class="line"><span class="literal">T</span> add(<span class="literal">T</span> a, <span class="literal">T</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">int</span> c = add&lt;<span class="built_in">int</span>&gt;(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以把类型去掉，这样调用函数的时候，会隐式转换</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">int</span> c = add(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多参数模板"><a href="#多参数模板" class="headerlink" title="多参数模板"></a>多参数模板</h2><ul><li>有时候我们的可以多参数，并且是不同类型的</li></ul><p>例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>,typename <span class="built_in">T2</span>&gt;</span><br><span class="line"><span class="built_in">T2</span> <span class="keyword">add(T1 </span>a, <span class="built_in">T2</span> <span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>但是一般来说，为了避免生成不必要的中间变量，以及为了代码安全性，上面代码可以改成如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>,typename <span class="built_in">T2</span>&gt;</span><br><span class="line"><span class="built_in">T2</span> <span class="keyword">add(const </span><span class="built_in">T1</span> &amp;a,const <span class="built_in">T2</span> &amp;<span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>不仅仅有函数模板，而且还有类模板<br>例如，我们自定义一个数组类，可以接收各种类型的数据</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;, <span class="keyword">const</span> Array&lt;Item&gt; &amp;);</span><br><span class="line"><span class="comment">// 用于指向首元素</span></span><br><span class="line">Item *m_data;</span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">int</span> m_size;</span><br><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">int</span> m_capacity;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Array(<span class="keyword">int</span> capacity = <span class="number">0</span>);</span><br><span class="line">~Array();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Item value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Item value)</span></span>;</span><br><span class="line"><span class="function">Item <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">Item <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Array&lt;Item&gt;::Array(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">m_capacity = (capacity &gt; <span class="number">0</span>) ? capacity : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请堆空间</span></span><br><span class="line">m_data = <span class="keyword">new</span> Item[m_capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Array&lt;Item&gt;::~Array() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_data == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::checkIndex(<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= m_size) &#123;</span><br><span class="line"><span class="comment">// 报错：抛异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"数组下标越界"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::add(Item value) &#123;</span><br><span class="line"><span class="keyword">if</span> (m_size == m_capacity) &#123;</span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.申请一块更大的新空间</span></span><br><span class="line"><span class="comment">2.将旧空间的数据拷贝到新空间</span></span><br><span class="line"><span class="comment">3.释放旧空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只做简单的打印</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"空间不够"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_data[m_size++] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::<span class="built_in">remove</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::insert(<span class="keyword">int</span> index, Item value) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Item Array&lt;Item&gt;::<span class="built_in">get</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">int</span> Array&lt;Item&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Item Array&lt;Item&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;<span class="built_in">cout</span>, <span class="keyword">const</span> Array&lt;Item&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.m_size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.m_data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候</p><p>定义坐标类Point</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">friend ostream &amp;operator&lt;&lt;(ostream &amp;, const Point &amp;);</span><br><span class="line"><span class="built_in">int</span> m_x;</span><br><span class="line"><span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line"><span class="constructor">Point(<span class="params">int</span> <span class="params">x</span> = 0, <span class="params">int</span> <span class="params">y</span> = 0)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个数组里面可以存放Point类型的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">Point</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">get</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>也可以存放int类型数据</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">int</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h2 id="类模板中的友元函数"><a href="#类模板中的友元函数" class="headerlink" title="类模板中的友元函数"></a>类模板中的友元函数</h2><p>上的代码中已经包含了友元函数，是运算符号<code>&lt;&gt;</code>重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;, <span class="keyword">const</span> Array&lt;Item&gt; &amp;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;<span class="built_in">cout</span>, <span class="keyword">const</span> Array&lt;Item&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.m_size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.m_data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下使用，就可以按照我们重载的方式来打印array的数值了。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line"><span class="keyword">Array</span>&lt;<span class="type">Point</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="keyword">array</span>.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="keyword">array</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之模板.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;模板（template）&quot;&gt;&lt;a href=&quot;#模板（template）&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之内部类和局部类</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB.html/</id>
    <published>2019-12-19T21:32:24.000Z</published>
    <updated>2020-03-07T12:40:04.387Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之内部类和局部类.html/">个人博客</a></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>如果将类A定义在类C的内部，那么类A就是一个内部类（嵌套类）</li><li>内部类的特点<ul><li>支持public、protected、private权限</li><li>成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</li><li>成员函数可以直接不带类名、对象名访问其外部类的static成员</li><li>不会影响外部类的内存布局</li><li>可以在外部类内部声明，在外部类外面进行定义</li></ul></li></ul><p>如下的<code>Car</code>类就是<code>Person</code>类的内部类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">int</span> m_price;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><ul><li>在一个函数内部定义的类，称为局部类</li><li>局部类的特点<ul><li>作用域仅限于所在的函数内部</li><li>其所有的成员必须定义在类内部，不允许定义static成员变量</li><li>成员函数不能直接访问函数的局部变量（static变量除外）</li></ul></li></ul><p>如下<code>Car</code>类就属于局部类</p><pre><code>void test() {    static int age = 10;    // 局部类    class Car {    public:        void run() {            age = 20;        }    };    Car car;    car.run();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之内部类和局部类.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之友元函数、友元类</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB.html/</id>
    <published>2019-12-12T21:32:24.000Z</published>
    <updated>2020-03-07T12:14:33.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之友元函数、友元类.html/">个人博客</a></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>友元包括友元函数和友元类</li><li>如果将函数A（非成员函数）声明为类C的友元函数，那么函数A就能直接访问类C对象的所有成员</li><li>如果将类A声明为类C的友元类，那么类A的所有成员函数都能直接访问类C对象的所有成员</li><li>友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能</li></ul><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>如下代码：类Point。x和y坐标，成员变量是私有的，获取值通过get函数获取</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_x;</span><br><span class="line">    <span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">X()</span> &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Y()</span> &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="constructor">Point(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">    void display<span class="literal">()</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point add(Point p1, Point p2) &#123;</span><br><span class="line">    return <span class="constructor">Point(<span class="params">p1</span>.<span class="params">getX</span>()</span> + p2.get<span class="constructor">X()</span>, p1.get<span class="constructor">Y()</span> + p2.get<span class="constructor">Y()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义2个point，然后我们想把这两个point相加。就如下所示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    Point p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    Point p2(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    Point p3 = add(p1, p2);</span><br><span class="line">    p3.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能达到要求，但是问题是，调用add函数时候，每次获取x和y的值，都要通过<code>getX()</code>或者<code>getY()</code>来取值。因为<code>m_x</code>是私有成员，使用<code>p1. m_x</code>是会报错的。</li><li>有什么办法能直接<code>p1. m_x</code>就可以访问么。同时<code>m_x</code>依然是私有成员</li></ul><h3 id="那就通过友元函数来实现"><a href="#那就通过友元函数来实现" class="headerlink" title="那就通过友元函数来实现"></a>那就通过友元函数来实现</h3><p>上的代码改成</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">     friend Point add(Point, Point);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_x;</span><br><span class="line">    <span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">X()</span> &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Y()</span> &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="constructor">Point(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">    void display<span class="literal">()</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point add(Point p1, Point p2) &#123;</span><br><span class="line">    return <span class="constructor">Point(<span class="params">p1</span>.<span class="params">m_x</span> + <span class="params">p2</span>.<span class="params">m_x</span>, <span class="params">p1</span>.<span class="params">m_y</span> + <span class="params">p2</span>.<span class="params">m_y</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说把<code>friend Point add(Point, Point)</code>放在<code>class Point</code>中,这样说明这个函数是朋友了嘛，既然是朋友了，那可以直接访问私有成员变量。当然了其他函数想直接访问私有成员变量依然是不可以的。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>既然和函数可以做朋友，那和类呢？答案是可以的。如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point <span class="title">add</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">        p1.m_x = <span class="number">10</span>;</span><br><span class="line">        p1.m_x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>class Point</code> 中声明了友元类<code>friend class Math;</code>那么在类<code>Math</code>中也是可以直接访问类<code>Point</code>中的私有成员变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之友元函数、友元类.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;友元&quot;&gt;&lt;a href=&quot;#友元&quot; class=&quot;headerlink&quot; title=&quot;友元&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之static、const</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8Bstatic%E3%80%81const.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8Bstatic%E3%80%81const.html/</id>
    <published>2019-12-09T21:32:24.000Z</published>
    <updated>2020-03-07T11:52:40.488Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之static、const.html/">个人博客</a></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li><p>静态成员的提出是为了解决数据共享的问题。实现共享有许多方法，如：设置全局性的变量或对象是一种方法。但是，全局变量或对象是有局限性的。</p></li><li><p>静态成员：被static修饰的成员变量\函数</p><ul><li>可以通过对象（对象.静态成员）、对象指针（对象指针-&gt;静态成员）、类访问（类名::静态成员）</li></ul></li><li><p>静态成员变量</p><ul><li>存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存</li><li>对比全局变量，它可以设定访问权限（public、protected、private），达到局部共享的目的</li><li>必须初始化，必须在类外面初始化，初始化时不能带static，如果类的声明和实现分离（在实现.cpp中初始化）</li></ul></li><li><p>静态成员函数</p><ul><li>内部不能使用this指针（this指针只能用在非静态成员函数内部）</li><li>不能是虚函数（虚函数只能是非静态成员函数）</li><li>内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数</li><li>非静态成员函数内部可以访问静态成员变量\函数</li><li>构造函数、析构函数不能是静态</li><li>当声明和实现分离时，实现部分不能带static</li></ul></li></ul><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>在C++中，可以利用static关键字在全局只有一份的特性，来写代理</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rocket</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Rocket *ms_rocket;</span><br><span class="line">    Rocket() &#123;&#125;</span><br><span class="line">    Rocket(<span class="keyword">const</span> Rocket &amp;rocket) &#123;&#125;</span><br><span class="line">    ~Rocket() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Rocket &amp;rocket) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Rocket *sharedRocket() &#123;</span><br><span class="line">        <span class="comment">// 这里要考虑多线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (ms_rocket == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ms_rocket = <span class="keyword">new</span> Rocket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ms_rocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里要考虑多线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (ms_rocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ms_rocket;</span><br><span class="line">            ms_rocket = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><ul><li>const成员：被const修饰的成员变量、非静态成员函数</li><li>const成员变量<ul><li>必须初始化（类内部初始化），可以在声明的时候直接初始化赋值</li><li>非static的const成员变量还可以在初始化列表中初始化</li></ul></li><li>const成员函数（非静态）<ul><li>const关键字写在参数列表后面，函数的声明和实现都必须带const</li><li>内部不能修改非static成员变量</li><li>内部只能调用const成员函数、static成员函数</li><li>非const成员函数可以调用const成员函数</li><li>const成员函数和非const成员函数构成重载</li><li>非const对象（指针）优先调用非const成员函数</li><li>const对象（指针）只能调用const成员函数、static成员函数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之static、const.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之虚函数、虚表</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E8%A1%A8.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E8%A1%A8.html/</id>
    <published>2019-12-07T21:32:24.000Z</published>
    <updated>2020-03-07T11:26:22.901Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之虚函数、虚表.html/">个人博客</a></p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul><li>C++中的多态通过虚函数（virtual function）来实现<ul><li>虚函数：被virtual修饰的成员函数</li><li>只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（也就是说子类中可以省略virtual关键字）</li></ul></li></ul><h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt; <span class="string">"Student::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们用<code>Person</code>指针指向<code>Student</code>对象，然后真正输出的是<code>Person::run()</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person *stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu-&gt;<span class="built_in">run</span>(); <span class="comment">//输出 Person::run()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 </p><blockquote><p>Person::run()</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>那是因为对于编译器来说，编译代码的时候，发现<code>stu</code>指针是Person类型，那么调用的时候，直接调用了<code>Person::run()</code>。有没有办法调用<code>Student::run()</code>呢？答案是有的，就是用<code>virtual</code>修饰</li><li>用<code>virtual</code>修饰的函数，是虚函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改成如上代码之后，输出结果为</p><blockquote><p>Student::run()</p></blockquote><h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2><ul><li>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表</li></ul><p>对于上面的例子中，<code>Student</code>对象的前4个字节存放的是指向虚表的地址<br>当我们调用的时候，</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *stu = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">stu-&gt;<span class="keyword">run</span>();</span><br></pre></td></tr></table></figure><p>会首先把虚表地址取出来，然后去虚表中调用<code>Student::run()</code></p><p><strong>所有的Student对象（不管在全局区、栈、堆）共用同一份虚表</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1000010e5</span> &lt;+<span class="number">53</span>&gt;: movq   <span class="number">-0x18</span>(%rbp), %rax</span><br><span class="line"><span class="number">0x1000010e9</span> &lt;+<span class="number">57</span>&gt;: movq   %rax, <span class="number">-0x10</span>(%rbp)</span><br><span class="line"><span class="number">0x1000010ed</span> &lt;+<span class="number">61</span>&gt;: movq   <span class="number">-0x10</span>(%rbp), %rax</span><br><span class="line"><span class="number">0x1000010f1</span> &lt;+<span class="number">65</span>&gt;: movq   (%rax), %rdx</span><br><span class="line"><span class="number">0x1000010f4</span> &lt;+<span class="number">68</span>&gt;: movq   %rax, %rdi</span><br><span class="line"><span class="number">0x1000010f7</span> &lt;+<span class="number">71</span>&gt;: callq  *(%rdx) <span class="comment">//rdx里面存放虚表地址</span></span><br></pre></td></tr></table></figure><p> 跟踪汇编代码调用如下的<code>Student::run:</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> C++test01`Student::<span class="built_in">run</span>:</span><br><span class="line">-&gt;  <span class="number">0x100001190</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001191</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001194</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001198</span> &lt;+<span class="number">8</span>&gt;:  movq   <span class="number">0xe61</span>(%rip), %rax         ; (<span class="keyword">void</span> *)<span class="number">0x00007fff97678760</span>: <span class="built_in">std</span>::__1::<span class="built_in">cout</span></span><br><span class="line">    <span class="number">0x10000119f</span> &lt;+<span class="number">15</span>&gt;: movq   %rdi, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x1000011a3</span> &lt;+<span class="number">19</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x1000011a6</span> &lt;+<span class="number">22</span>&gt;: leaq   <span class="number">0xda6</span>(%rip), %rsi         ; <span class="string">"Student::run()"</span></span><br><span class="line">    <span class="number">0x1000011ad</span> &lt;+<span class="number">29</span>&gt;: callq  <span class="number">0x100001de2</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;&amp; <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;(<span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*)</span><br></pre></td></tr></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul><li>纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范</li><li>抽象类（Abstract Class） <ul><li>含有纯虚函数的类，不可以实例化（不可以创建对象）</li><li>抽象类也可以包含非纯虚函数、成员变量</li><li>如果父类是抽象类，子类没有完全重写纯虚函数，那么这个子类依然是抽象类</li></ul></li></ul><p>例如下面的<code>Person</code>类就是一个含有纯虚函数的类，可以用来定义接口规范</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line">    virtual <span class="built_in">void</span> run()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</li><li>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。</li><li>所以类纯虚函数的声明就是在告诉子类的设计者，”你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之虚函数、虚表.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之继承</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%BB%A7%E6%89%BF.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%BB%A7%E6%89%BF.html/</id>
    <published>2019-12-06T21:32:24.000Z</published>
    <updated>2020-03-07T12:17:27.124Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之继承.html/">个人博客</a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>继承，可以让子类拥有父类的所有成员（变量\函数）</li></ul><h3 id="默认私有继承"><a href="#默认私有继承" class="headerlink" title="默认私有继承"></a>默认私有继承</h3><p>例如下面的代码中，类Cat继承类Animal</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Animal::eat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">"Cat::run()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下调用的时候，发现设置父类的成员变量，访问父类的函数，会报错。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">Cat</span> <span class="keyword">cat</span>;</span><br><span class="line">    <span class="keyword">cat</span>.age =3; <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">cat</span>.height = 4;</span><br><span class="line">    <span class="keyword">cat</span>.<span class="keyword">run</span>();</span><br><span class="line">    <span class="keyword">cat</span>.eat(); <span class="comment">//编译报错</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改为public继承"><a href="#修改为public继承" class="headerlink" title="修改为public继承"></a>修改为<code>public</code>继承</h3><p>那是因为C++中默认是私有继承。如果子类想访问父类的函数等，需要public继承，改成如下就可以了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">"Cat::run()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>c++中没有类似Java中的java.lang.Object 或者ObjectC中的NSObject的基类</strong></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul><li>父类的成员变量在前，子类的成员变量在后</li></ul><p>上面的代码反汇编</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x100001160</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001161</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001164</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001168</span> &lt;+<span class="number">8</span>&gt;:  movl   $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000116f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x3</span>, <span class="number">-0x10</span>(%rbp) <span class="comment">//cat.age =3</span></span><br><span class="line">    <span class="number">0x100001176</span> &lt;+<span class="number">22</span>&gt;: movl   $<span class="number">0x4</span>, <span class="number">-0xc</span>(%rbp)<span class="comment">//cat.height =4</span></span><br><span class="line">-&gt;  <span class="number">0x10000117d</span> &lt;+<span class="number">29</span>&gt;: leaq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x100001181</span> &lt;+<span class="number">33</span>&gt;: callq  <span class="number">0x1000011a0</span>               ; Cat::run at Main.cpp:<span class="number">42</span></span><br><span class="line">    <span class="number">0x100001186</span> &lt;+<span class="number">38</span>&gt;: leaq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x10000118a</span> &lt;+<span class="number">42</span>&gt;: callq  <span class="number">0x1000011e0</span>               ; Animal::eat at Main.cpp:<span class="number">33</span></span><br><span class="line">    <span class="number">0x10000118f</span> &lt;+<span class="number">47</span>&gt;: xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100001191</span> &lt;+<span class="number">49</span>&gt;: addq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001195</span> &lt;+<span class="number">53</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001196</span> &lt;+<span class="number">54</span>&gt;: retq</span><br></pre></td></tr></table></figure><p>从上面的汇编可以看到<code>age</code>在<code>height</code>的地址前面，而且是连续的内存。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ul><li>C++允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）</li></ul><p>如下所示：<code>GoodStudent</code>同时继承<code>Person</code>和<code>Student</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::play()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodStudent</span>:</span><span class="keyword">public</span> Person,<span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"GoodStudent::study()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GoodStudent stu;</span><br><span class="line">    stu.age = <span class="number">1</span>;</span><br><span class="line">    stu.<span class="built_in">height</span> = <span class="number">2</span>;</span><br><span class="line">    stu.score = <span class="number">3</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应汇编如下，可知是把父类的成员变量放在了子类中，并且内存是连续的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100000f90</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f91</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f94</span> &lt;+<span class="number">4</span>&gt;:  xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100000f96</span> &lt;+<span class="number">6</span>&gt;:  movl   $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f9d</span> &lt;+<span class="number">13</span>&gt;: movl   $<span class="number">0x1</span>, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000fa4</span> &lt;+<span class="number">20</span>&gt;: movl   $<span class="number">0x2</span>, <span class="number">-0xc</span>(%rbp)</span><br><span class="line">-&gt;  <span class="number">0x100000fab</span> &lt;+<span class="number">27</span>&gt;: movl   $<span class="number">0x3</span>, <span class="number">-0x8</span>(%rbp)</span><br></pre></td></tr></table></figure><h2 id="多个父类同样的函数"><a href="#多个父类同样的函数" class="headerlink" title="多个父类同样的函数"></a>多个父类同样的函数</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::play()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类调用的时候需要区分命名空间</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu.Person::<span class="built_in">run</span>(); <span class="comment">//调用Person的run()</span></span><br><span class="line">stu.Student::<span class="built_in">run</span>();<span class="comment">//调用Student的run()</span></span><br></pre></td></tr></table></figure><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><ul><li><p>如果存在类A，同时类B和类C都继承A，有类D继承B和C。则称为菱形继承</p></li><li><p>一般在开发中，不会使用菱形继承。</p><ul><li>最底下子类从基类继承的成员变量冗余、重复</li><li>最底下子类无法访问基类的成员，有二义性</li></ul></li></ul><p>例如如下的代码中，就是菱形继承的例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student:<span class="symbol">public</span></span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Work:<span class="symbol">public</span></span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">GoodStudent:<span class="symbol">public</span></span> <span class="symbol">Student,<span class="symbol">public</span></span> <span class="symbol">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在X86架构下，一个GoodStudent对象占用内存20字节，是因为，Student和Work都从Person继承了age，那么GoodStudent中就有2个age了。同时加上score,height, salary就是5个成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GoodStudent stu;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(stu) &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出20</span></span><br></pre></td></tr></table></figure><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>为了解决菱形继承的问题，我们可以使用虚继承。</p><p>如下代码 Person类被称为虚基类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student:<span class="symbol">virtual</span></span> <span class="symbol">public</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Work:<span class="symbol">virtual</span></span> <span class="symbol">public</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">GoodStudent:<span class="symbol">public</span></span> <span class="symbol">Student,<span class="symbol">public</span></span> <span class="symbol">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个GoodStudent对象里面只有一个age成员变量。当然这样做增加了虚函数表。这里不做展开。</p><h2 id="成员访问权限"><a href="#成员访问权限" class="headerlink" title="成员访问权限"></a>成员访问权限</h2><ul><li>成员访问权限、继承方式有3种 <ul><li>public：公共的，任何地方都可以访问（struct默认）</li><li>protected：子类内部、当前类内部可以访问</li><li>private：私有的，只有当前类内部可以访问（class默认）<ul><li>子类内部访问父类成员的权限，是以下2项中权限最小的那个</li></ul></li><li>成员本身的访问权限</li><li>上一级父类的继承方式<ul><li>开发中用的最多的继承方式是public，这样能保留父类原来的成员访问权限</li><li>访问权限不影响对象的内存布局</li></ul></li></ul></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><ul><li>一种便捷的初始化成员变量的方式</li><li>只能用在构造函数中</li><li>初始化顺序只跟成员变量的声明顺序有关</li></ul><p>下面两种写法是等价的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">        this-&gt;m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>)</span>: m<span class="constructor">_age(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化列表与默认参数配合使用"><a href="#初始化列表与默认参数配合使用" class="headerlink" title="初始化列表与默认参数配合使用"></a>初始化列表与默认参数配合使用</h2><p>例如下面的代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="built_in">int</span> m_height;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span> = 0, <span class="params">int</span> <span class="params">height</span> =0)</span>:m<span class="constructor">_age(<span class="params">age</span>)</span>,m<span class="constructor">_height(<span class="params">height</span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用的时候如下三种都可以</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">Person person2(<span class="number">18</span>);</span><br><span class="line">Person person3(<span class="number">18</span>,<span class="number">188</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之继承.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之封装、构造函数、析构函数</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.html/</id>
    <published>2019-12-05T21:32:24.000Z</published>
    <updated>2020-03-07T08:13:41.263Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之封装、构造函数、析构函数.html/">个人博客</a></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>成员变量私有化，提供公共的getter和setter给外界去访问成员变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.setAge(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><ul><li><p>在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存</p></li><li><p>堆空间的申请\释放</p><ul><li><code>malloc</code> \ <code>free</code></li><li><code>new</code> \ <code>delete</code></li><li><code>new</code> [] \ <code>delete []</code></li></ul></li><li><p>注意</p><ul><li>申请堆空间成功后，会返回那一段内存空间的地址</li><li>申请和释放必须是1对1的关系，不然可能会存在内存泄露</li></ul></li><li><p>现在的很多高级编程语言不需要开发人员去管理内存（比如Java），屏蔽了很多内存细节，利弊同时存在</p><ul><li>利：提高开发效率，避免内存使用不当或泄露</li><li>弊：不利于开发人员了解本质，永远停留在API调用和表层语法糖，对性能优化无从下手</li></ul></li></ul><p>例如开盘int类型的空间，使用完之后销毁</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *p = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>));</span><br><span class="line">   *p = <span class="number">10</span>;</span><br><span class="line">   free(p);</span><br><span class="line">  </span><br><span class="line">   <span class="built_in">int</span> *p2 = new <span class="built_in">int</span>;</span><br><span class="line">   *p2 = <span class="number">20</span>;</span><br><span class="line">   delete p2;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> *p3 = new <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">   *p = <span class="number">10</span>;</span><br><span class="line">   *(p+<span class="number">1</span>) = <span class="number">20</span>;</span><br><span class="line">   *(p+<span class="number">2</span>) = <span class="number">30</span>;</span><br><span class="line">   delete [] (p3);</span><br></pre></td></tr></table></figure><h2 id="堆空间的初始化"><a href="#堆空间的初始化" class="headerlink" title="堆空间的初始化"></a>堆空间的初始化</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a><code>memset</code></h3><p><code>memset</code>函数是将较大的数据结构（比如对象、数组等）内存清零的比较快的方法</p><p>如下所示</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">Person</span> <span class="keyword">person</span>;</span><br><span class="line"> <span class="keyword">person</span>.age = 10;</span><br><span class="line"> <span class="keyword">person</span>.height = 199;</span><br><span class="line"> //从<span class="keyword">person</span>的地址开始,每个字节都赋值为0</span><br><span class="line">memset(&amp;<span class="keyword">person</span>, 0, sizeof(<span class="keyword">person</span>));</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//*p1 未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//将 *p2 的每一个字节都初始化为0</span></span><br></pre></td></tr></table></figure><p>如下几种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;           <span class="comment">//未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();         <span class="comment">//被初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);        <span class="comment">//被初始化为5</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];        <span class="comment">//数组元素未被初始化</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]();      <span class="comment">//3个数组元素都被初始化0</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;&#125;;      <span class="comment">//3个数组元素都被初始化0</span></span><br><span class="line"><span class="keyword">int</span> *p7 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">5</span>&#125;;     <span class="comment">//数组首元素被初始化为5,其他元素被初始化为0</span></span><br></pre></td></tr></table></figure><h2 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h2><ul><li>构造函数（也叫构造器），在对象创建的时候自动调用，一般用于完成对象的初始化工作</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>函数名与类同名，无返回值（void都不能写），可以有参数，可以重载，可以有多个构造函数</li><li>一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>通过malloc分配的对象不会调用构造函数</li><li>一个广为流传的、很多教程\书籍都推崇的错误结论： <ul><li>默认情况下，编译器会为每一个类生成空的无参的构造函数</li><li>正确理解：在某些特定的情况下，编译器才会为类生成空的无参的构造函数</li></ul></li></ul><p>比如我们自己写2个构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person(int age))"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在不同的空间调用的时候，如下区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局区</span></span><br><span class="line">Person p1;      <span class="comment">//调用Person()</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">()</span></span>;    <span class="comment">//这是一个函数，函数名是p2,返回值类型是Person，无参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">18</span>)</span></span>;  <span class="comment">//调用 Person(int)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//栈空间</span></span><br><span class="line">    Person p4;      <span class="comment">//调用Person()</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">()</span></span>;    <span class="comment">//这是一个函数，函数名是p5,返回值类型是Person，无参</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(<span class="number">18</span>)</span></span>;  <span class="comment">//调用 Person(int)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//堆空间</span></span><br><span class="line">    Person *p7  = <span class="keyword">new</span> Person;      <span class="comment">//调用Person()</span></span><br><span class="line">    Person *p8  = <span class="keyword">new</span> Person();    <span class="comment">//调用Person()</span></span><br><span class="line">    Person *p9  = <span class="keyword">new</span> Person(<span class="number">20</span>);  <span class="comment">//调用 Person(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数的互相调用"><a href="#构造函数的互相调用" class="headerlink" title="构造函数的互相调用"></a>构造函数的互相调用</h2><p>下面代码中有2个构造函数，<code>Person()</code>是可以调用<code>Person(int age, int height):m_age(age),m_height(height)</code>的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="built_in">int</span> m_height;</span><br><span class="line">    <span class="constructor">Person()</span>:<span class="constructor">Person(10,20)</span>&#123;&#125;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>, <span class="params">int</span> <span class="params">height</span>)</span>:m<span class="constructor">_age(<span class="params">age</span>)</span>,m<span class="constructor">_height(<span class="params">height</span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h2><ul><li>子类的构造函数默认会调用父类的无参构造函数</li><li>如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</li><li>如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>析构函数（也叫析构器），在对象销毁的时候自动调用，一般用于完成对象的清理工作</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>函数名以~开头，与类同名，无返回值（void都不能写），无参，不可以重载，有且只有一个析构函数</li></ul><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>通过malloc分配的对象free的时候不会调用析构函数</li><li>构造函数、析构函数要声明为public，才能被外界正常使用</li></ul><h3 id="例如下面的代码"><a href="#例如下面的代码" class="headerlink" title="例如下面的代码"></a>例如下面的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Cat()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Cat()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Cat()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Cat *cat;</span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Person person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">()</span></span></span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure><p>当person销毁的时候，其持有的cat并没有销毁。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>当person销毁的时候，其指向cat对象的指针销毁了，但是堆空间的cat对象依然存在，就会有内存泄露。所以需要在析构函数里面来释放掉。类似的析构函数在许多其他语言底层也是应用广泛，例如Objective-C的源码中，大量使用析构函数。</li></ul><p>代码改成如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Person()&#123;</span><br><span class="line">       <span class="keyword">delete</span> cat;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">()</span></span></span><br><span class="line">~Cat()</span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure><p>可知，cat对象才真正销毁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之封装、构造函数、析构函数.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之类(class,struct)</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB(class,struct).html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB(class,struct).html/</id>
    <published>2019-11-29T21:32:24.000Z</published>
    <updated>2020-03-06T05:06:33.691Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之类(class,struct).html/">个人博客</a></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p> C++中可以使用struct、class来定义一个类</p><h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><ul><li>struct的默认成员权限是public</li><li>class的默认成员权限是private</li><li>实际开发中，用class表示类比较多</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="操作类"><a href="#操作类" class="headerlink" title="操作类"></a>操作类</h3><ul><li>对类进行操作。我们有两种方式</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> <span class="keyword">person</span>;</span><br><span class="line">//使用对象的点语法</span><br><span class="line"><span class="keyword">person</span>.age = 10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *p = &amp;<span class="keyword">person</span>;</span><br><span class="line">//操作指针访问</span><br><span class="line">p-&gt;age = 20;</span><br></pre></td></tr></table></figure><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.age = <span class="number">10</span>; <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> pushq  <span class="symbol">%rbp</span></span><br><span class="line"> movq   <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line"> xorl   <span class="symbol">%eax</span>, <span class="symbol">%eax</span></span><br><span class="line">-&gt;   movl   $<span class="number">0xa</span>, <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>) <span class="comment">; person.age = 10</span></span><br><span class="line"><span class="comment"> popq   %rbp</span></span><br><span class="line"><span class="comment"> retq</span></span><br></pre></td></tr></table></figure><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.age = <span class="number">10</span>; <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> pushq  <span class="symbol">%rbp</span></span><br><span class="line"> movq   <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line"> xorl   <span class="symbol">%eax</span>, <span class="symbol">%eax</span></span><br><span class="line">-&gt;   movl   $<span class="number">0xa</span>, <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>) <span class="comment">; person.age = 10</span></span><br><span class="line"><span class="comment"> popq   %rbp</span></span><br><span class="line"><span class="comment"> retq</span></span><br></pre></td></tr></table></figure><p>可以看到无论是<code>struct</code>还是<code>class</code>。汇编代码完全一样</p><ul><li>实际开发中，用class表示类比较多</li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this是指向当前对象的指针"><a href="#this是指向当前对象的指针" class="headerlink" title="this是指向当前对象的指针"></a>this是指向当前对象的指针</h3><ul><li>对象在调用成员函数的时候，会自动传入当前对象的内存地址</li></ul><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age is "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：不能用this.age来访问成员变量。因为this是指针。</strong></p><h3 id="指针访问对象成员的本质"><a href="#指针访问对象成员的本质" class="headerlink" title="指针访问对象成员的本质"></a>指针访问对象成员的本质</h3><p>下面代码最后打印出来的每个成员变量值是多少？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" id = "</span> &lt;&lt; id &lt;&lt; <span class="string">" age = "</span> &lt;&lt; age &lt;&lt; <span class="string">" height = "</span> &lt;&lt; <span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person person;</span><br><span class="line">    person.id = <span class="number">10</span>;</span><br><span class="line">    person.age = <span class="number">20</span>;</span><br><span class="line">    person.<span class="built_in">height</span> = <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Person *p = (Person *)&amp;person.age;</span><br><span class="line">    <span class="comment">//操作指针访问</span></span><br><span class="line">    p-&gt;id = <span class="number">40</span>;</span><br><span class="line">    p-&gt;age= <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    person.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一感觉是</p><blockquote><p>id = 40 age = 50 height = 30</p></blockquote><p>然后用编译器运行起来的结果是</p><blockquote><p>id = 10 age = 40 height = 50</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>因为指针<code>p</code>实际指向的是<code>person.age</code>的地址，但是<code>(Person *)&amp;person.age;</code> 欺骗编译器是指向person。</li><li>64位下<code>person</code>中每个成员变量都是Int类型，占用4个字节。</li><li>当我们修改<code>p-&gt;id = 40;</code>的时候，实际上修改的是<code>age</code>指向的内存空间。</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>打印的时候不用点语法，使用指针呢？如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>display();</span><br></pre></td></tr></table></figure><p>其结果为：其中height 的值是不确定的</p><blockquote><p>id = 40 age = 50 height = 1 </p></blockquote><ul><li>是因为，使用指针访问的时候，传入的this就是偏移了4个字节的内存空间，打印的id实际上是age,打印的age实际上是height,打印的height实际上是其他空间的数据。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之类(class,struct).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之引用</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%BC%95%E7%94%A8.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%BC%95%E7%94%A8.html/</id>
    <published>2019-11-27T21:32:24.000Z</published>
    <updated>2020-03-07T06:12:40.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之引用.html/">个人博客</a></p><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><ul><li>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>引用相当于是变量的别名（基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用）</li><li>对引用做计算，就是对引用所指向的变量做计算</li><li>在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”</li><li>可以利用引用初始化另一个引用，相当于某个变量的多个别名</li><li>不存在【引用的引用、指向引用的指针、引用数组】</li></ul><p>例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line"> <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = age;</span><br><span class="line"> <span class="built_in">ref</span> = <span class="number">20</span>;</span><br><span class="line"> cout &lt;&lt; age &lt;&lt; endl; <span class="comment">//打印结果为 20</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中修改ref也就相当于修改了age。</p><h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><ul><li>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针<ul><li>一个引用占用一个指针的大小</li></ul></li></ul><h3 id="间接证明"><a href="#间接证明" class="headerlink" title="间接证明"></a>间接证明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person size is "</span> &lt;&lt; <span class="keyword">sizeof</span>(person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在X86位架构下，上面的代码输入为 <code>person size is 4</code><br>如果代码改成如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> &amp;ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person size is "</span> &lt;&lt; <span class="keyword">sizeof</span>(person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在X86架构下，上面的代码输入为 <code>person size is 8</code><br>而我们知道在X86架构下，指针类型占用字节为8。int 类型为占用4个字节。所以引用和指针占用字节数一样。</p><h3 id="汇编证明"><a href="#汇编证明" class="headerlink" title="汇编证明"></a>汇编证明</h3><ul><li>如下使用指针的代码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">   <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">int</span> *p = &amp;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">_main:</span></span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0x3</span></span><br><span class="line"><span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"><span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><ul><li>把指针改成引用的代码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">   <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol"> _main:</span></span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0x3</span></span><br><span class="line"><span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"><span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可发现，引用和指针的汇编代码完全一致。就说明最终转成机器码也是一样的。所以引用的本质就是指针。</p><h2 id="常引用（Const-Reference）"><a href="#常引用（Const-Reference）" class="headerlink" title="常引用（Const Reference）"></a>常引用（Const Reference）</h2><ul><li>引用可以被const修饰，这样就无法通过引用修改数据了，可以称为常引用</li><li>const必须写在&amp;符号的左边，才能算是常引用</li></ul><h3 id="const引用的特点"><a href="#const引用的特点" class="headerlink" title="const引用的特点"></a>const引用的特点</h3><ul><li>可以指向临时数据（常量、表达式、函数返回值等）</li><li>可以指向不同类型的数据</li><li>作为函数参数时（此规则也适用于const指针） <ul><li>可以接受const和非const实参（非const引用，只能接受非const实参）</li><li>可以跟非const引用构成重载</li></ul></li></ul><p><strong>当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量</strong></p><h3 id="常引用指向相同类型的数据"><a href="#常引用指向相同类型的数据" class="headerlink" title="常引用指向相同类型的数据"></a>常引用指向相同类型的数据</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ref is "</span> &lt;&lt; <span class="built_in">ref</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面代码输出为12。其对应的汇编如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"> <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"> //<span class="number">10</span>赋值给[<span class="built_in">rbp</span>+var_8] 这个内存空间 也就是 变量a的地址</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">// a的地址赋值给引用ref</span><br><span class="line"> <span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span>//</span><br><span class="line"></span><br><span class="line">//把a的值改为<span class="number">12</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xc</span></span><br><span class="line"> <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h3 id="常引用指向不同类型的数据"><a href="#常引用指向不同类型的数据" class="headerlink" title="常引用指向不同类型的数据"></a>常引用指向不同类型的数据</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> long &amp;<span class="built_in">ref</span> = a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ref is "</span> &lt;&lt; <span class="built_in">ref</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面代码输出为10。其对应的汇编如下，改变了a的值，并不能改变ref的值</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">             _main:</span></span><br><span class="line"> <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"> <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">//<span class="number">10</span>赋值给[<span class="built_in">rbp</span>+var_8] 这个内存空间 也就是 变量a的地址</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">//增加一个中间变量地址为[<span class="built_in">rbp</span>+var_18] 作为引用ref的地址</span><br><span class="line"> <span class="keyword">movsxd</span>     <span class="built_in">rcx</span>, <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_18], <span class="built_in">rcx</span></span><br><span class="line"> <span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_18]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"></span><br><span class="line">//把a的值改为<span class="number">12</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xc</span></span><br><span class="line"> <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之引用.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;C-引用&quot;&gt;&lt;a href=&quot;#C-引用&quot; class=&quot;headerlink&quot; title=&quot;C++ 引用&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之内联函数</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0.html/</id>
    <published>2019-11-25T21:32:24.000Z</published>
    <updated>2020-03-04T02:29:00.221Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之内联函数.html/">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p></blockquote><blockquote><p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>使用inline修饰函数的声明或者实现，可以使其变成内联函数</li><li>建议声明和实现都增加inline修饰</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过内敛之后就相当于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>编译器会将函数调用直接展开为函数体代码</li><li>可以减少函数调用的开销</li><li>会增大代码体积</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>尽量不要内联超过10行代码的函数</li><li>有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数</li></ul><p>例如下面的代码就算加了inline 也不会被编译器内敛的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    test3(a--);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test3(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inline只是建议"><a href="#inline只是建议" class="headerlink" title="inline只是建议"></a><code>inline</code>只是建议</h2><p>inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p><h2 id="慎用-inline"><a href="#慎用-inline" class="headerlink" title="慎用 inline"></a>慎用 inline</h2><ul><li>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？ </li><li>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 </li><li>如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li></ul><p>以下情况不宜使用内联： </p><ul><li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 </li><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如”偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</li></ul><h2 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h2><ul><li>内联函数和宏，都可以减少函数调用的开销</li><li>对比宏，内联函数多了语法检测和函数特性</li><li>宏使用不当，会导致和我们想法不一致的情况</li></ul><p>例如下面的代码,如果是宏定义，就相当于b = (a++ + a++);结果和预期不符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) (x + x)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> b = sum(a++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。 </li><li>最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强性能，就避免使用它！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之内联函数.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之C和C++混编</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8BC%E5%92%8CC++%E6%B7%B7%E7%BC%96.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8BC%E5%92%8CC++%E6%B7%B7%E7%BC%96.html/</id>
    <published>2019-11-23T21:32:24.000Z</published>
    <updated>2020-03-03T07:46:39.782Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之C和C++混编.html/">个人博客</a></p><h2 id="extern-quot-C-quot"><a href="#extern-quot-C-quot" class="headerlink" title="extern &quot;C&quot;"></a><code>extern &quot;C&quot;</code></h2><blockquote><p><code>extern &quot;C&quot;</code>的主要作用就是为了能够正确实现<code>C++</code>代码调用其他C语言代码。加上<code>extern &quot;C&quot;</code>后，会指示编译器这部分代码按<code>C</code>语言（而不是<code>C++</code>）的方式进行编译。由于<code>C++</code>支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p></blockquote><blockquote><p>这个功能十分有用处，因为在<code>C++</code>出现以前，很多代码都是<code>C</code>语言写的，而且很底层的库也是<code>C</code>语言写的，为了更好的支持原来的<code>C</code>代码和已经写好的<code>C</code>语言库，需要在<code>C++</code>中尽可能的支持<code>C</code>，而<code>extern &quot;C&quot;</code>就是其中的一个策略。</p></blockquote><h3 id="extern-quot-C-quot-可以修饰单个函数，也可以修饰多个函数。"><a href="#extern-quot-C-quot-可以修饰单个函数，也可以修饰多个函数。" class="headerlink" title="extern &quot;C&quot; 可以修饰单个函数，也可以修饰多个函数。"></a><code>extern &quot;C&quot;</code> 可以修饰单个函数，也可以修饰多个函数。</h3><p>例如下面的三个函数都会用 C语音的方式编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明必须修饰，实现可修饰可不修饰"><a href="#声明必须修饰，实现可修饰可不修饰" class="headerlink" title="声明必须修饰，实现可修饰可不修饰"></a>声明必须修饰，实现可修饰可不修饰</h3><ul><li><p>如果函数同时有声明和实现，要让函数声明被extern “C”修饰，函数实现可以不修饰</p></li><li><p>函数的声明都被extern “C”修饰是可以编译通过的</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以编译通过</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明被extern “C”修饰，实现没有被extern “C”修饰，是可以编译通过的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以编译通过</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明没有被extern “C”修饰，实现被extern “C”修饰，不能编译通过</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能编译通过</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cplusplus"><a href="#cplusplus" class="headerlink" title="__cplusplus"></a><code>__cplusplus</code></h2><p>有时候我们的函数，不仅要在C语言中调用，还要再C++中调用。怎么做呢？</p><p>如果我们加了<code>extern &quot;C&quot;</code> 那么只能是C语言的环境编译，C++环境编译就会有问题了。</p><p>如果我们不加<code>extern &quot;C&quot;</code> 那么只能是C++语言的环境编译，C环境编译就会有问题了。</p><p>如果能够判断是C语言环境还是C++环境，这样在C++语言的环境下按照C++编译方式，在C语言的环境下按照C编译方式，岂不是都可以了。</p><p> <code>__cplusplus</code>就可以达成这样的效果。</p><p> 例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就能做到C++语言的环境下按照C++编译方式，在C语言的环境下按照C编译方式。</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a><code>ifndef</code></h2><p>我们知道，当引用其他文件的时候，我们要用到 <code>#include</code> 例如</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br></pre></td></tr></table></figure><p>如果我们不小心写了很多次</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br></pre></td></tr></table></figure><p>那就相当于把引用的文件的内容拷贝过来很多次，编译器编译的时候，要执行多次，浪费性能。这时候我们只需要在被引用文件里面加上如下代码即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_IOSTREAM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIBCPP_IOSTREAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。很多代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就算引用多次，也没关系。因为第二次引用的时候，判断引用过了，直接跳过。其中<code>_LIBCPP_IOSTREAM</code>这个为了避免重复，一般采用和文件同名的大写字母来命名。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><ul><li>我们经常使用#ifndef、#define、#endif来防止头文件的内容被重复包含</li><li>#pragma once可以防止整个文件的内容被重复包含</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>受<code>C\C++</code>标准的支持，不受编译器的任何限制</li><li>有些编译器不支持<code>#pragma once</code>（较老编译器不支持，如<code>GCC 3.4</code>版本之前），兼容性不够好</li><li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>可以针对一个文件中的部分代码，而<code>#pragma once</code>只能针对整个文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之C和C++混编.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;extern-quot-C-quot&quot;&gt;&lt;a href=&quot;#extern-quot-C-quot&quot; cl
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之函数重载和默认参数</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html/</id>
    <published>2019-11-20T21:32:24.000Z</published>
    <updated>2020-03-02T11:52:09.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之函数重载.html/">个人博客</a></p><h2 id="函数重载（Overload）"><a href="#函数重载（Overload）" class="headerlink" title="函数重载（Overload）"></a>函数重载（Overload）</h2><p><strong>C语言中没有函数重载</strong></p><p><strong>C++语言中有函数重载</strong></p><h3 id="函数名相同，参数个数不同、参数类型不同、参数顺序不同"><a href="#函数名相同，参数个数不同、参数类型不同、参数顺序不同" class="headerlink" title="函数名相同，参数个数不同、参数类型不同、参数顺序不同"></a>函数名相同，参数个数不同、参数类型不同、参数顺序不同</h3><p>例如下面就是函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值类型与函数重载无关"><a href="#返回值类型与函数重载无关" class="headerlink" title="返回值类型与函数重载无关"></a>返回值类型与函数重载无关</h3><p>返回值类型与函数重载无关，下面代码不构成重载，编译会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值类型与函数重载无关</span></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实参的隐式类型转换可能会产生二义性"><a href="#实参的隐式类型转换可能会产生二义性" class="headerlink" title="实参的隐式类型转换可能会产生二义性"></a>实参的隐式类型转换可能会产生二义性</h3><p><strong>不同编译器有不同处理</strong></p><p>下面代码在vs上编译不过，但是在Xcode中可以编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载的本质"><a href="#函数重载的本质" class="headerlink" title="函数重载的本质"></a>函数重载的本质</h2><ul><li>采用了name mangling或者叫name decoration技术<ul><li>C++编译器默认会对符号名（比如函数名）进行改编、修饰，有些地方翻译为“命名倾轧”</li><li>重载时会生成多个不同的函数名，不同编译器（MSVC、g++）有不同的生成规则</li><li>通过IDA打开【VS_Release_禁止优化】可以看到 或者通过hopper查看</li></ul></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，<code>void sum(double a){}</code> 和 <code>void sum(int a){}</code> 是如何重载，调用函数的时候是如何能正确找到对应的函数呢？</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>我是用xcode的编译出可执行文件，放在hopper中查看</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">   __Z3sumd:</span>        // sum(double)</span><br><span class="line">0000000100000ce0         <span class="keyword">push</span>       <span class="built_in">rbp</span>         <span class="comment">; CODE XREF=_main+23</span></span><br><span class="line">0000000100000ce1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000ce4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000ce8         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">qword</span> [__ZNSt3__14coutE_100001000]</span><br><span class="line">0000000100000cef         <span class="keyword">movsd</span>      <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8], <span class="built_in">xmm0</span></span><br><span class="line">0000000100000cf4         <span class="keyword">movsd</span>      <span class="built_in">xmm0</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line">0000000100000cf9         <span class="keyword">call</span>       imp___stubs___ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEd <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(double)</span></span><br><span class="line">0000000100000cfe         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span></span><br><span class="line">0000000100000d01         <span class="keyword">lea</span>        <span class="built_in">rsi</span>, <span class="built_in">qword</span> [__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_]</span><br><span class="line">0000000100000d08         <span class="keyword">call</span>       __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; (*)(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;))</span></span><br><span class="line">0000000100000d0d         <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rax</span></span><br><span class="line">0000000100000d11         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000d15         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000d16         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000d17         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br></pre></td></tr></table></figure><p>可知 <code>void sum(double a){}</code> 被编译器修改为函数<code>__Z3sumd</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">                     __Z3sumi:</span>        // sum(<span class="keyword">int</span>)</span><br><span class="line">0000000100000da0         <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line">0000000100000da1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000da4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000da8         <span class="keyword">mov</span>        <span class="built_in">rax</span>, <span class="built_in">qword</span> [__ZNSt3__14coutE_100001000]</span><br><span class="line">0000000100000daf         <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="built_in">edi</span></span><br><span class="line">0000000100000db2         <span class="keyword">mov</span>        <span class="built_in">esi</span>, <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4]</span><br><span class="line">0000000100000db5         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span></span><br><span class="line">0000000100000db8         <span class="keyword">call</span>       imp___stubs___ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)</span></span><br><span class="line">0000000100000dbd         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span>                                    <span class="comment">; argument #1 for method __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E</span></span><br><span class="line">0000000100000dc0         <span class="keyword">lea</span>        <span class="built_in">rsi</span>, <span class="built_in">qword</span> [__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_]</span><br><span class="line">0000000100000dc7         <span class="keyword">call</span>       __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; (*)(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;))</span></span><br><span class="line">0000000100000dcc         <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rax</span></span><br><span class="line">0000000100000dd0         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000dd4         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000dd5         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000dd6         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">cs</span>:<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br></pre></td></tr></table></figure><p>可知 <code>void sum(int a){}</code> 被编译器修改为函数<code>__Z3sumi</code></p><p>这样当我们调用的时候</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    sum(<span class="number">10.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编如下，可知：因为 10.5是double类型，调用函数的时候是调用 <code>__Z3sumd</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000100000de0         <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line">0000000100000de1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000de4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000de8         <span class="keyword">movsd</span>      <span class="built_in">xmm0</span>, <span class="built_in">qword</span> [<span class="number">0x100000f80</span>]</span><br><span class="line">0000000100000df0         <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line">0000000100000df7         <span class="keyword">call</span>       __Z3sumd        <span class="comment">; sum(double)</span></span><br><span class="line">0000000100000dfc         <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">0000000100000dfe         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000e02         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000e03         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000e04         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">cs</span>:<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br><span class="line">0000000100000e0e         <span class="keyword">nop</span></span><br></pre></td></tr></table></figure><h3 id="函数重载结论"><a href="#函数重载结论" class="headerlink" title="函数重载结论"></a>函数重载结论</h3><p>由上面的汇编代码可知，当参数类型不同的时候，编译器会生成不同的函数名作为区别，这样就能实现函数重载。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>C++允许函数设置默认参数，在调用时可以根据情况省略实参。规则如下：</p><ul><li>默认参数只能按照右到左的顺序</li><li>如果函数同时有声明、实现，默认参数只能放在函数声明中</li><li>默认参数的值可以是常量、全局符号（全局变量、函数名）</li></ul><p>用法：如果函数的实参经常是同一个值，可以考虑使用默认参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2函数</span></span><br><span class="line"><span class="comment">// a没有默认值</span></span><br><span class="line"><span class="comment">// b 默认值是 10</span></span><br><span class="line"><span class="comment">// 最后一个参数默认值是个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">void</span> (*func)() = test)</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"a is "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test2(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可能有冲突，二义性"><a href="#可能有冲突，二义性" class="headerlink" title="可能有冲突，二义性"></a>可能有冲突，二义性</h3><ul><li>函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）</li></ul><p>例如下面的代码中， 调用<code>test(3);</code> 会报错，因为不知道要执行哪个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test(<span class="number">3</span>); <span class="comment">// 这里报错，因为不知道要执行哪个函数</span></span><br><span class="line">    test(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//这一句可以正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果函数的实参经常是同一个值，可以考虑使用默认参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之函数重载.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数重载（Overload）&quot;&gt;&lt;a href=&quot;#函数重载（Overload）&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之输入输出</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html/</id>
    <published>2019-11-16T00:32:24.000Z</published>
    <updated>2020-03-02T06:24:39.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>C++ 标准库提供了一组丰富的输入/输出功能，本文讨论 C++ 编程中最基本和最常见的 I/O 操作。</p></blockquote><blockquote><p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</p></blockquote><h2 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I/O 库头文件"></a>I/O 库头文件</h2><table><thead><tr><th align="center">头文件</th><th align="center">函数和描述</th></tr></thead><tbody><tr><td align="center"><code>&lt;iostream&gt;</code></td><td align="center">该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td align="center"><code>&lt;iomanip&gt;</code></td><td align="center">该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td align="center"><code>&lt;fstream&gt;</code></td><td align="center">该文件为用户控制的文件处理声明服务。</td></tr></tbody></table><h2 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h2><p>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello eagle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>hello eagle</p></blockquote><p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello eagle "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h2><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"age is "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输入18<br>然后打印</p><blockquote><p>age is 18</p></blockquote><p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p><blockquote><p>cin &gt;&gt; name &gt;&gt; age;</p></blockquote><p>等价</p><blockquote><p>cin &gt;&gt; name;</p><p>cin &gt;&gt; age;</p></blockquote><h2 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h2><p>预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是<strong>缓冲</strong>的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p><p>clog 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] = <span class="string">"Unable to read...."</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">clog</span> &lt;&lt; <span class="string">"Error message : "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><blockquote><p>Error message : Unable to read….</p></blockquote><h2 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h2><p>预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是<strong>非缓冲</strong>的，且每个流插入到 cerr 都会立即输出。</p><p>cerr 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] = <span class="string">"Unable to read...."</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error message : "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><blockquote><p>Error message : Unable to read….</p></blockquote><p>在编写和执行程序时，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;C++ 标准库提供了一组丰富的输入/输出功能，本文讨论 C++ 编程中最基本和最常见的 I/O 操作。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之下标</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html/</id>
    <published>2019-10-30T00:32:24.000Z</published>
    <updated>2019-12-12T06:40:29.375Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift中对枚举、结构体、类使用下标(subscript），就可以像使用数组一样来使用了</p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ul><li>使用subscript可以给任意类型（枚举、结构体、类）增加下标功能，有些地方也翻译为：下标脚本</li><li>subscript的语法类似于实例方法、计算属性，本质就是方法（函数）</li></ul><p>例如下面的代码中，类<code>Point</code>中，的属性 x 和 y,可以用下标访问</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="type">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(<span class="keyword">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">                x = newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">1</span> &#123;</span><br><span class="line">                y = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">index</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问的时候</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = Point()</span><br><span class="line"><span class="selector-tag">p</span>[<span class="number">0</span>] = <span class="number">11.1</span></span><br><span class="line"><span class="selector-tag">p</span>[<span class="number">1</span>] = <span class="number">22.2</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p.x)</span></span> <span class="comment">// 11.1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p.y)</span></span> <span class="comment">// 22.2</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p[<span class="number">0</span>])</span></span> <span class="comment">// 11.1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p[<span class="number">1</span>])</span></span> <span class="comment">// 22.2</span></span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>subscript中定义的返回值类型决定了<ul><li>get方法的返回值类型</li><li>set方法中newValue的类型</li></ul></li><li>subscript可以接受多个参数，并且类型任意</li></ul><h3 id="subscript可以没有set方法"><a href="#subscript可以没有set方法" class="headerlink" title="subscript可以没有set方法"></a>subscript可以没有set方法</h3><p>例如下面的代码中，只提供了get，没有set</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(index: <span class="built_in">Int</span>) -&gt; <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有get方法，可以省略get</li></ul><p>上面的代码可以写成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可以设置参数标签"><a href="#可以设置参数标签" class="headerlink" title="可以设置参数标签"></a>可以设置参数标签</h3><p>例如下面的代码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    subscript(index i: Int) -&gt; Double &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = Point()</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.y</span> = <span class="number">22.2</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p[index: <span class="number">1</span>])</span></span> <span class="comment">// 22.2</span></span><br></pre></td></tr></table></figure><h3 id="下标可以是类型方法"><a href="#下标可以是类型方法" class="headerlink" title="下标可以是类型方法"></a>下标可以是类型方法</h3><p>如下</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> subscript(v1: <span class="keyword">Int</span>, v2: <span class="keyword">Int</span>) -&gt; <span class="keyword">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(Sum[<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h2 id="结构体、类作为返回值对比"><a href="#结构体、类作为返回值对比" class="headerlink" title="结构体、类作为返回值对比"></a>结构体、类作为返回值对比</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>eg,如下代码,结构体Point，用了下标<code>subscript</code>只有get方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="type">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PointManager &#123;</span><br><span class="line">    var <span class="type">point</span> = <span class="type">Point</span>()</span><br><span class="line">    subscript(<span class="keyword">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">point</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候报错</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var </span><span class="string">pm </span>= <span class="string">PointManager(</span>)</span><br><span class="line"><span class="string">pm[</span>0].x = <span class="string">11 </span>//<span class="string">Cannot </span><span class="string">assign </span><span class="string">to </span><span class="string">property:</span> <span class="string">subscript </span><span class="string">is </span><span class="built_in">get-only</span></span><br><span class="line"><span class="built_in">//</span> 等价于 <span class="string">pm[</span>0] = <span class="string">Point(</span>x: <span class="string">11,</span> y: <span class="string">pm[</span>0].y)</span><br><span class="line"><span class="string">pm[</span>0].y = <span class="string">22/</span>/<span class="string">Cannot </span><span class="string">assign </span><span class="string">to </span><span class="string">property:</span> <span class="string">subscript </span><span class="string">is </span><span class="built_in">get-only</span></span><br></pre></td></tr></table></figure><h3 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h3><ul><li>加上set方法</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="type">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PointManager &#123;</span><br><span class="line">    var <span class="type">point</span> = <span class="type">Point</span>()</span><br><span class="line">    subscript(<span class="keyword">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">       <span class="keyword">set</span> &#123; <span class="type">point</span> = newValue &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">point</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面使用正常</span><br><span class="line">var pm = PointManager()</span><br><span class="line">pm[<span class="number">0</span>].x = <span class="number">11</span></span><br><span class="line">// 等价于 pm[<span class="number">0</span>] = <span class="type">Point</span>(x: <span class="number">11</span>, y: pm[<span class="number">0</span>].y)</span><br><span class="line">pm[<span class="number">0</span>].y = <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h3><p>结构体改成类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span> &#123;</span><br><span class="line">    var x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">PointManager</span> &#123;</span><br><span class="line">    var point = Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; point &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面使用正常</span></span><br><span class="line">var pm = PointManager()</span><br><span class="line">pm[<span class="number">0</span>].x = <span class="number">11</span></span><br><span class="line"><span class="comment">// 等价于 pm[0] = Point(x: 11, y: pm[0].y)</span></span><br><span class="line">pm[<span class="number">0</span>].y = <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>类是引用类型的，传递的是地址<br>结构体是值类型，传递的是具体的值</p><h2 id="接受多个参数的下标"><a href="#接受多个参数的下标" class="headerlink" title="接受多个参数的下标"></a>接受多个参数的下标</h2><p>eg,如下代码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Grid</span> &#123;</span><br><span class="line">    var data = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    ]</span><br><span class="line">    subscript(row: Int, column: Int) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            guard row &gt;= <span class="number">0</span> &amp;&amp; row &lt; <span class="number">3</span> &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; <span class="number">3</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            data[row][column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            guard row &gt;= <span class="number">0</span> &amp;&amp; row &lt; <span class="number">3</span> &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; <span class="number">3</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data[row][column]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下使用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var grid = Grid()</span><br><span class="line">grid[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">77</span></span><br><span class="line">grid[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">88</span></span><br><span class="line">grid[<span class="number">2</span>, <span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">print(grid.data)</span><br></pre></td></tr></table></figure><p>输出为</p><blockquote><p>[[0, 77, 2], [3, 4, 88], [99, 7, 8]]</p></blockquote><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E4%B8%8B%E6%A0%87.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift之协议</title>
    <link href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html/"/>
    <id>https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html/</id>
    <published>2019-10-16T00:32:24.000Z</published>
    <updated>2019-12-12T06:37:26.102Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>协议，有关开发经验的应该都不陌生，很多语言中都有协议，但是相对来说，Swift中的协议更加强大，灵活。</p><ul><li>Swift中协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开）</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">//可读可写属性</span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//只读属性</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 下标</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类<code>TestClass</code>准守多个协议</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol Test1 &#123; &#125;</span><br><span class="line">protocol Test2 &#123; &#125;</span><br><span class="line">protocol Test3 &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">TestClass</span> : <span class="symbol">Test1, <span class="symbol">Test2</span>, <span class="symbol">Test3</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h3><ul><li>协议中定义方法时不能有默认参数值</li><li>默认情况下，协议中定义的内容必须全部都实现</li><li>也有办法办到只实现部分内容，后面会说</li></ul><h2 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h2><ul><li>协议中定义属性时必须用var关键字</li><li>实现协议时的属性权限要不小于协议中定义的属性权限</li><li>协议定义get、set，用var存储属性或get、set计算属性去实现</li><li>协议定义get，用任何属性都可以实现</li></ul><p>eg：有协议<code>Drawable</code>,里面有方法<code>draw</code>，以及可读可写属性<code>x</code>，只读属性<code>y</code>，下标。其中属性必须用<code>var</code>关键字</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">//可读可写 属性用var</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">//只读  属性用var</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">//下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现的时候，有如下的方式，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span> <span class="comment">//用var的存储属性</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">0</span> <span class="comment">//let实现只读属性</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person draw"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了。也可以写成如下这种</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="type">Drawable &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Int</span> &#123; <span class="comment">//用计算属性</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> &#123; <span class="number">0</span> &#125; <span class="comment">//var实现只读属性</span></span><br><span class="line">    func draw() &#123; print(<span class="string">"Person draw"</span>) &#125;</span><br><span class="line">    subscript(index: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static、class"><a href="#static、class" class="headerlink" title="static、class"></a>static、class</h2><ul><li>为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标<ul><li>因为class只能用在类中，不能用于结构体等。所以为了通用，用static</li><li>但是实现的时候，可以用class，也可以用static，具体看自己的情况<br>eg:</li></ul></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里必须用static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里可以用class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">draw</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person1 draw"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里也可以用static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person2 draw"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h2><p>关于<code>mutating</code>可以参考<a href="https://juejin.im/post/5d2ba7265188252d1d5f9218" target="_blank" rel="noopener">Swift之方法</a></p><ul><li>只有将协议中的实例方法标记为mutating<ul><li>才允许结构体、枚举的具体实现修改自身内存</li><li>类在实现方法时不用加mutating，枚举、结构体才需要加mutating</li></ul></li></ul><p>eg:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        width = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> : <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><ul><li>协议中还可以定义初始化器init<ul><li>非final类实现时必须加上required</li></ul></li></ul><p>可以这么理解，如果定义的类，有子类，那么子类必须准守初始化器init，所以加上关键字<code>required</code>,但是，如果一个被<code>final</code>修饰的类。就不用加上<code>required</code>.因为被<code>final</code>修饰的类不能被其他类继承。</p><p>关于<code>final</code>可参考<a href="https://juejin.im/post/5d2d9ebbe51d4510634318bf" target="_blank" rel="noopener">Swift之继承</a></p><p>eg: 有协议<code>Drawable</code>,里面定义了初始化器<code>init</code>，类Point遵守这个协议，所以在init 前面加了关键字 <code>required</code>,这样，继承类Point的子类都要实现这个方法，但是类Size没子类。因为加了关键字<code>final</code>，这个类不能被继承。所以<code>init</code>前面不用加<code>required</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    <span class="keyword">init</span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> : <span class="type">Drawable &#123;</span></span></span><br><span class="line">    required <span class="keyword">init</span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Size</span> : <span class="type">Drawable &#123;</span></span></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果从协议实现的初始化器，刚好是重写了父类的指定初始化器<ul><li>那么这个初始化必须同时加required、override</li></ul></li></ul><p>eg:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable &#123;</span><br><span class="line">    <span class="keyword">init</span>(age: <span class="built_in">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(age: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span>, <span class="type">Livable &#123;</span></span></span><br><span class="line">    required <span class="keyword">override</span> <span class="keyword">init</span>(age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init、init-、init"><a href="#init、init-、init" class="headerlink" title="init、init?、init!"></a>init、init?、init!</h2><ul><li>协议中定义的init?、init!，可以用init、init?、init!去实现</li><li>协议中定义的init，可以用init、init!去实现</li></ul><p>eg:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line">protocol Livable &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">init</span>?(age: <span class="built_in">Int</span>)</span><br><span class="line">    <span class="keyword">init</span>!(no: <span class="built_in">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="type">Livable &#123;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两种都可以实现init()</span></span><br><span class="line">    required <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    <span class="comment">// required init!() &#123; &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面3种都可以实现init?(age: Int)</span></span><br><span class="line">    required <span class="keyword">init</span>?(age: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// required init!(age: Int) &#123; &#125;</span></span><br><span class="line">    <span class="comment">// required init(age: Int) &#123; &#125;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//下面3种都可以实现 init!(no: Int)</span></span><br><span class="line">    required <span class="keyword">init</span>!(no: <span class="built_in">Int</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// required init?(no: Int) &#123; &#125;</span></span><br><span class="line">    <span class="comment">// required init(no: Int) &#123; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h2><ul><li>一个协议可以继承其他协议</li></ul><p>eg</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议Livable 继承协议 Runnable</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Livable</span> : <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">breath</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Livable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">breath</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h2><ul><li>协议组合，多个协议组合在一起，而且可以包含1个类类型（最多1个）</li></ul><p>eg: 两个协议<code>Livable</code>和<code>Runnable</code>,类<code>Person</code></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol <span class="keyword">Livable</span> &#123; &#125; <span class="keyword">n</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="keyword">Runnable</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Person</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>下面定义了fn0,接收参数必须是Person或者其子类的实例。fn1接收参数必须遵守Livable协议的实例，其他的可以自行看代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收Person或者其子类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn0</span><span class="params">(obj: Person)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收遵守Livable协议的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(obj: Livable)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收同时遵守Livable、Runnable协议的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">(obj: Livable &amp; Runnable)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn3</span><span class="params">(obj: Person &amp; Livable &amp; Runnable)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RealPerson</span> = <span class="type">Person</span> &amp; <span class="type">Livable</span> &amp; <span class="type">Runnable</span></span><br><span class="line"><span class="comment">// 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn4</span><span class="params">(obj: RealPerson)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="CaseIterable"><a href="#CaseIterable" class="headerlink" title="CaseIterable"></a>CaseIterable</h2><ul><li>让枚举遵守CaseIterable协议，可以实现遍历枚举值</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举Season遵守协议CaseIterable</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> : <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出所有的case</span></span><br><span class="line"><span class="keyword">let</span> seasons = <span class="type">Season</span>.allCases</span><br><span class="line"><span class="built_in">print</span>(seasons.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以遍历</span></span><br><span class="line"><span class="keyword">for</span> season <span class="keyword">in</span> seasons &#123;</span><br><span class="line">    <span class="built_in">print</span>(season)</span><br><span class="line">&#125; <span class="comment">// spring summer autumn winter</span></span><br></pre></td></tr></table></figure><h2 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h2><ul><li>遵守CustomStringConvertible协议，可以自定义实例的打印字符串</li></ul><p>eg: <code>Person</code>类遵守了<code>CustomStringConvertible</code>协议,可以再内部自定义打印<code>description</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: Int</span><br><span class="line">    <span class="keyword">var</span> name: <span class="built_in">String</span></span><br><span class="line">    init(age: Int, name: <span class="built_in">String</span>) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="string">"age=\(age), name=\(name)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person(age: <span class="number">10</span>, name: <span class="string">"Jack"</span>)</span><br><span class="line"><span class="built_in">print</span>(p) <span class="comment">// age=10, name=Jack</span></span><br></pre></td></tr></table></figure><h2 id="Any、AnyObject"><a href="#Any、AnyObject" class="headerlink" title="Any、AnyObject"></a>Any、AnyObject</h2><ul><li>Swift提供了2种特殊的类型：Any、AnyObject<ul><li>Any：可以代表任意类型（枚举、结构体、类，也包括函数类型）</li><li>AnyObject：可以代表任意类类型（在协议后面写上: AnyObject代表只有类能遵守这个协议）</li></ul></li></ul><p>eg: stu属于Any类型,可以赋值为字符串或者对象等</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stu: <span class="attr">Any</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">stu</span> = <span class="string">"Jack"</span></span><br><span class="line"><span class="attr">stu</span> = Student()</span><br></pre></td></tr></table></figure><p>eg: 创建1个能存放任意类型的数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建1个能存放任意类型的数组</span></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="comment">// var data = Array&lt;Any&gt;()</span></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = [Any]()</span><br><span class="line"><span class="keyword">data</span>.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">data</span>.append(<span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">data</span>.append(Student())</span><br><span class="line"><span class="keyword">data</span>.append(<span class="string">"Jack"</span>)</span><br><span class="line"><span class="keyword">data</span>.append(&#123; <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="is、as-、as-、as"><a href="#is、as-、as-、as" class="headerlink" title="is、as?、as!、as"></a>is、as?、as!、as</h2><ul><li>is用来判断是否为某种类型，as用来做强制类型转换</li></ul><p>eg: 定义协议<code>Runnable</code>,类<code>Person</code>和类<code>Student</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Student run"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Student study"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用is 的时候</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> stu: Any = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Int)</span></span> <span class="comment">// true</span></span><br><span class="line">stu = <span class="string">"Jack"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is String)</span></span> <span class="comment">// true</span></span><br><span class="line">stu = Student()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Person)</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Student)</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu is Runnable)</span></span> <span class="comment">// t</span></span><br></pre></td></tr></table></figure><p>使用as 的时候,如果转换失败，后面都不执行。转换成功，后面才继续执行</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu: Any = 10</span><br><span class="line">(stu <span class="keyword">as</span>? Student)?.study() <span class="comment">// 没有调用study</span></span><br><span class="line">stu = Student()</span><br><span class="line">(stu <span class="keyword">as</span>? Student)?.study() <span class="comment">// Student study</span></span><br><span class="line">(stu <span class="keyword">as</span>! Student).study() <span class="comment">// Student study</span></span><br><span class="line">(stu <span class="keyword">as</span>? Runnable)?.<span class="keyword">run</span>() <span class="comment">// Student run</span></span><br></pre></td></tr></table></figure><h2 id="X-self、X-Type、AnyClass"><a href="#X-self、X-Type、AnyClass" class="headerlink" title="X.self、X.Type、AnyClass"></a>X.self、X.Type、AnyClass</h2><ul><li>X.self是一个元类型（metadata）的指针，metadata存放着类型相关信息</li><li>X.self属于X.Type类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">// 定义类Student 继承 Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//perType类型是 Person.Type</span></span><br><span class="line"><span class="keyword">var</span> perType: <span class="type">Person</span>.<span class="type">Type</span> = <span class="type">Person</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">//stuType类型是 Student.Type</span></span><br><span class="line"><span class="keyword">var</span> stuType: <span class="type">Student</span>.<span class="type">Type</span> = <span class="type">Student</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// Student.self可以赋值给perType</span></span><br><span class="line">perType = <span class="type">Student</span>.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// anyType可以是任何类型</span></span><br><span class="line"><span class="keyword">var</span> anyType: <span class="type">AnyObject</span>.<span class="type">Type</span> = <span class="type">Person</span>.<span class="keyword">self</span></span><br><span class="line">anyType = <span class="type">Student</span>.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnyClass</span> = <span class="type">AnyObject</span>.<span class="type">Type</span></span><br><span class="line"><span class="comment">//anyType2可以是任何类型</span></span><br><span class="line"><span class="keyword">var</span> anyType2: <span class="type">AnyClass</span> = <span class="type">Person</span>.<span class="keyword">self</span></span><br><span class="line">anyType2 = <span class="type">Student</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><h2 id="元类型的应用"><a href="#元类型的应用" class="headerlink" title="元类型的应用"></a>元类型的应用</h2><p>eg:<code>Cat</code>类，<code>Dog</code>类，<code>Pig</code>类，都继承自<code>Animal</code>类，我们想同时去初始化，可使用下面的代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; <span class="keyword">required</span> <span class="keyword">init</span>() &#123; &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> : <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> clses: [Animal.<span class="keyword">Type</span>])</span></span> -&gt; [<span class="type">Animal</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="type">Animal</span>]()</span><br><span class="line">    <span class="keyword">for</span> cls <span class="keyword">in</span> clses &#123;</span><br><span class="line">        <span class="comment">// 根据元类型初始化</span></span><br><span class="line">        arr.append(cls.<span class="keyword">init</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里传入Cat,Dog,Pig进行初始化</span></span><br><span class="line"><span class="built_in">print</span>(create([<span class="type">Cat</span>.<span class="keyword">self</span>, <span class="type">Dog</span>.<span class="keyword">self</span>, <span class="type">Pig</span>.<span class="keyword">self</span>]))</span><br></pre></td></tr></table></figure><p><strong>注意上面的required不能省略</strong></p><ul><li>在OC、Java等语言中，任何一个类最终都要继承自某个基类，</li><li>在Swift中没有这个规定，如果一个类不继承任何一个类，那这个类就是基类</li></ul><p>实际上，真的如此么，真的不继承任何类么？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> no: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(class_getInstanceSize(<span class="type">Student</span>.<span class="keyword">self</span>)) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">print</span>(class_getSuperclass(<span class="type">Student</span>.<span class="keyword">self</span>)!) <span class="comment">// Person</span></span><br><span class="line"><span class="built_in">print</span>(class_getSuperclass(<span class="type">Person</span>.<span class="keyword">self</span>)!) <span class="comment">// Swift._SwiftObject</span></span><br></pre></td></tr></table></figure><ul><li>从结果可以看得出来，Swift还有个隐藏的基类：Swift._SwiftObject</li><li>可以参考<a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObjec.h" target="_blank" rel="noopener">Swift源码</a></li></ul><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><ul><li>Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型（也可以作为参数类型）</li></ul><p>有点类似OC中的instanType的感觉。eg:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123; type(of: <span class="keyword">self</span>).<span class="keyword">init</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>调用时候</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = Person()</span><br><span class="line"><span class="comment">// 输出Person</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p.test()</span></span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> stu = Student()</span><br><span class="line"><span class="comment">// 输出Student</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(stu.test()</span></span>)</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Swift%E4%B9%8B%E5%8D%8F%E8%AE%AE.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编深入分析inout本质</title>
    <link href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html/"/>
    <id>https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html/</id>
    <published>2019-09-28T00:32:24.000Z</published>
    <updated>2019-12-12T06:32:35.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于<code>输入输出参数inout</code> 在<a href="https://juejin.im/post/5d1eec54f265da1bb27750ba" target="_blank" rel="noopener">Swift之函数</a>一文中，我们已经有了初步的认识。现在我们再继续深入了解一下</p><h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><ul><li>说了形参只能是let，但是如果我们想再内部修改外部实参的值，可以用 inout 定义输入输出参数</li></ul><p>例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func swapValues(_ v1: <span class="keyword">inout</span> Int, _ v2: <span class="keyword">inout</span> Int) &#123;</span><br><span class="line">     let tmp = v1</span><br><span class="line">     v1 = v2</span><br><span class="line">     v2 = tmp</span><br><span class="line">     <span class="comment">//前面三行也可以换成  (v1, v2) = (v2, v1) 效果一样</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  var num1 = <span class="number">10</span></span><br><span class="line">  var num2 = <span class="number">20</span></span><br><span class="line">  swapValues(&amp;num1, &amp;num2)</span><br><span class="line"> print(<span class="string">"num1 = \(num1), num2 = \(num2)"</span>)</span><br><span class="line">    </span><br><span class="line">  输出： num1 = <span class="number">20</span>, num2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>注意点:</p><ul><li>可变参数不能标记为inout</li><li>inout参数不能有默认值</li><li>inout参数的本质是地址传递(引用传递)</li><li>inout参数只能传入可以被多次赋值的</li></ul><h2 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h2><p><code>inout</code> 是地址传递，对于不同的情况具体怎么传递呢？汇编拨开云雾</p><p>如下代码，表示等边的多边形，其中<code>width</code>表示边长，<code>side</code>表示多边形边长数量 <code>girth</code>表示周长，我们知道 <code>周长 = 边长 * 边数</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inout-修改存储属性"><a href="#inout-修改存储属性" class="headerlink" title="inout 修改存储属性"></a>inout 修改存储属性</h2><h3 id="先看打印结果"><a href="#先看打印结果" class="headerlink" title="先看打印结果"></a>先看打印结果</h3><p> 如下代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(&amp;s.width) <span class="comment">//这里打断点</span></span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">getGirth</span><br><span class="line">width=8, side=4, girth=32</span><br></pre></td></tr></table></figure><p>其中<code>getGirth</code>这句打印是因为后面的<code>show</code>方法需要获取<code>girth</code>的值，如果我们去掉最后一句,只有如下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s = Shape(<span class="attribute">width</span>: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(&amp;s.width)</span></span></span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>在上面代码中的 <code>test(&amp;s.width)</code>这一句打断点</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef672deebf0?w=1172&h=650&f=png&s=295179" alt=""></p><p>关键代码为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量0x44be(%rip)的地址给寄存器rdi，rdi是全局变量s的地址</span></span><br><span class="line"> <span class="number">0x100000fbb</span> &lt;+<span class="number">107</span>&gt;: leaq   <span class="number">0x44be</span>(%rip), %rdi        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用test函数，其中rdi作为参数传入</span></span><br><span class="line"><span class="number">0x100000fc2</span> &lt;+<span class="number">114</span>&gt;: callq  <span class="number">0x100001930</span>               ; testSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">44</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> <strong>把属性<code>s.width</code>的地址值传递过去，进行修改</strong></p><ul><li>全局变量0x44be(%rip)的地址给寄存器rdi，rdi是全局变量s的地址</li><li>调用test函数，其中rdi作为参数传入</li></ul><ul><li><p>为什么我们代码中写的是 s.width ，但汇编传入的是s的地址呢？</p><ul><li>因为，width作为结构体的第一个属性变量，它的地址就是结构体s的地址</li></ul></li><li><p>为什么rdi是作为参数呢？</p><ul><li><a href="https://juejin.im/post/5d19f9816fb9a07f0a2df848" target="_blank" rel="noopener">汇编总结</a>中我们知道 rdi、rsi、rdx、rcx、r8、r9等寄存器常用于存放函数参数。</li></ul></li></ul><h2 id="inout-修改带有属性观察器的存储属性"><a href="#inout-修改带有属性观察器的存储属性" class="headerlink" title="inout 修改带有属性观察器的存储属性"></a>inout 修改带有属性观察器的存储属性</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先分析一下，应该和前面存储属性不一样的，因为如果直接修改存储属性<code>side</code>的值，那怎么调动属性观察器的方法<code>willSet</code>和<code>didSet</code>呢？，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">test(&amp;s.side) <span class="comment">//这里打断点</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">willSetSide 8</span><br><span class="line">didSetSide 4 8</span><br></pre></td></tr></table></figure><h3 id="查看汇编"><a href="#查看汇编" class="headerlink" title="查看汇编"></a>查看汇编</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef673dc1585?w=2092&h=1244&f=png&s=814277" alt=""></p><p>关键汇编代码分析</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量0x44e4(%rip)的地址给寄存器rdi，地址是testSwift.Shape + 8也就是size的地址</span></span><br><span class="line"><span class="number">0x100000f9d</span> &lt;+<span class="number">109</span>&gt;: movq   <span class="number">0x44e4</span>(%rip), %rax        ; testSwift.s : testSwift.Shape + <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//size的地址给局部变量-0x28(%rbp)</span></span><br><span class="line"><span class="number">0x100000fa4</span> &lt;+<span class="number">116</span>&gt;: movq   %rax, <span class="number">-0x28</span>(%rbp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量-0x28(%rbp)的值给寄存器 %rdi</span></span><br><span class="line"><span class="number">0x100000fa8</span> &lt;+<span class="number">120</span>&gt;: leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test函数，寄存器 %rdi作为参数传入</span></span><br><span class="line"><span class="number">0x100000fac</span> &lt;+<span class="number">124</span>&gt;: callq  <span class="number">0x100001930</span>               ; testSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时已经修改完了局部变量 -0x28(%rbp)对应的值 并把局部变量 -0x28(%rbp)的值传给rdi,</span></span><br><span class="line"><span class="number">0x100000fb1</span> &lt;+<span class="number">129</span>&gt;: movq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"><span class="number">0x100000fb5</span> &lt;+<span class="number">133</span>&gt;: leaq   <span class="number">0x44c4</span>(%rip), %r13        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从截图中也可以看到此时%rdi里面是8，也就是 test函数中的  num = 8</span></span><br><span class="line"><span class="number">0x100000fbc</span> &lt;+<span class="number">140</span>&gt;: callq  <span class="number">0x100001240</span>               ; testSwift.Shape.side.setter : Swift.Int at &lt;compiler-generated&gt;</span><br></pre></td></tr></table></figure><h3 id="testSwift-Shape-side-setter函数中，调用side-willset-和-side-didset"><a href="#testSwift-Shape-side-setter函数中，调用side-willset-和-side-didset" class="headerlink" title="testSwift.Shape.side.setter函数中，调用side.willset 和 side.didset"></a><code>testSwift.Shape.side.setter</code>函数中，调用<code>side.willset</code> 和 <code>side.didset</code></h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef675ec0101?w=1988&h=1154&f=png&s=538327" alt=""></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>对于带有属性观察器的存储属性<code>size</code></p><ul><li>首先把<code>size</code>的地址放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>size</code></li></ul><h2 id="inout-修改计算属性girth"><a href="#inout-修改计算属性girth" class="headerlink" title="inout 修改计算属性girth"></a>inout 修改计算属性<code>girth</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先分析一下，应该和前面存储属性不一样的，因为计算属性<code>girth</code>没有自己的内存地址，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽、边长</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSetSide"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSetSide"</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 周长</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 边长 = 周长 / 边数</span></span><br><span class="line">            width = newValue / side</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"setGirth"</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"getGirth"</span>)</span><br><span class="line">            <span class="comment">// 周长 = 边长 * 边数</span></span><br><span class="line">            <span class="keyword">return</span> width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"width=\(width), side=\(side), girth=\(girth)"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"test"</span>);</span><br><span class="line">    num = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">test(&amp;s.girth) <span class="comment">//这里打断点</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getGirth</span><br><span class="line">test</span><br><span class="line">setGirth 8</span><br></pre></td></tr></table></figure><h3 id="查看汇编-1"><a href="#查看汇编-1" class="headerlink" title="查看汇编"></a>查看汇编</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/17/16bfcef676ac3806?w=2008&h=1198&f=png&s=568740" alt=""></p><h3 id="汇编分析-1"><a href="#汇编分析-1" class="headerlink" title="汇编分析"></a>汇编分析</h3><p>关键汇编代码分析</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用testSwift.Shape.girth.getter 方法，返回值放在rax中</span></span><br><span class="line"><span class="number">0x100000fab</span> &lt;+<span class="number">123</span>&gt;: callq  <span class="number">0x100001580</span>               ; testSwift.Shape.girth.getter : Swift.Int at main.swift:<span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把getter的返回值放在 局部变量-0x28(%rbp)中</span></span><br><span class="line"><span class="number">0x100000fb0</span> &lt;+<span class="number">128</span>&gt;: movq   %rax, <span class="number">-0x28</span>(%rbp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量-0x28(%rbp)的地址值 放在寄存器rdi</span></span><br><span class="line"><span class="number">0x100000fb4</span> &lt;+<span class="number">132</span>&gt;: leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"><span class="comment">//寄存器rdi的地址值传到testSwift.test函数中，进行修改</span></span><br><span class="line"><span class="number">0x100000fb8</span> &lt;+<span class="number">136</span>&gt;: callq  <span class="number">0x100001930</span>               ; testSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量-0x28(%rbp)的值，传到寄存器rdi中</span></span><br><span class="line"><span class="number">0x100000fbd</span> &lt;+<span class="number">141</span>&gt;: movq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0x100000fc1</span> &lt;+<span class="number">145</span>&gt;: leaq   <span class="number">0x44b8</span>(%rip), %r13        ; testSwift.s : testSwift.Shape</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器rdi里面放的是局部变量-0x28(%rbp)的值 传入到Shape.girth.setter中</span></span><br><span class="line"><span class="number">0x100000fc8</span> &lt;+<span class="number">152</span>&gt;: callq  <span class="number">0x1000012f0</span>               ;  testSwift.Shape.girth.setter : Swift.Int at main.swift:<span class="number">28</span></span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>因为计算属性本身没有地址值，所以过程略显复杂</p><p>对于<code>inout</code>修改计算属性<code>girth</code></p><ul><li>首先调用<code>getter</code>方法，把返回值放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>girth</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="针对本文代码的总结"><a href="#针对本文代码的总结" class="headerlink" title="针对本文代码的总结"></a>针对本文代码的总结</h3><p>输入输出参数inout 本质就是引用传递，也就是地址传递，根据传过来的地址，修改对应的值。针对不同的情况，其他处理不同，</p><ul><li>普通存储属性，直接把地址值传过来修改就可以了。</li><li>对于<code>inout</code>带有属性观察器的存储属性<code>size</code><ul><li>首先把<code>size</code>的地址放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>size</code></li></ul></li><li>对于<code>inout</code>修改计算属性<code>girth</code><ul><li>首先调用<code>getter</code>方法，把返回值放在一个局部变量中</li><li>然后调用<code>test</code>方法，把局部变量的值修改</li><li>再把局部变量传入到<code>setter</code>方法中，真正的修改计算属性<code>girth</code></li></ul></li></ul><h3 id="针对inout的总结"><a href="#针对inout的总结" class="headerlink" title="针对inout的总结"></a>针对inout的总结</h3><ul><li>如果实参有物理内存地址，且没有设置属性观察器    <ul><li>直接将实参的内存地址传入函数（实参进行引用传递）</li><li>如果实参是计算属性 或者 设置了属性观察器</li></ul></li><li>采取了Copy In Copy Out的做法<ul><li>调用该函数时，先复制实参的值，产生副本【get】</li><li>将副本的内存地址传入函数（副本进行引用传递），在函数内部可以修改副本的值</li><li>函数返回后，再将副本的值覆盖实参的值【set】</li></ul></li><li>总结：inout的本质就是引用传递（地址传递）</li></ul><p>参考资料:</p><p><a href="https://github.com/apple/Swift" target="_blank" rel="noopener">Swift官方源码</a></p><p><a href="https://ke.qq.com/course/392094" target="_blank" rel="noopener">从入门到精通Swift编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90inout%E6%9C%AC%E8%B4%A8.html&quot;&gt;个人博客&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://ityongzhen.github.io/categories/Swift/"/>
    
    
  </entry>
  
</feed>
