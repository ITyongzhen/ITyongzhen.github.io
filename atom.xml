<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>殷永振</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ityongzhen.github.io/"/>
  <updated>2020-05-05T08:46:00.079Z</updated>
  <id>https://ityongzhen.github.io/</id>
  
  <author>
    <name>ityongzhen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序初步了解</title>
    <link href="https://ityongzhen.github.io/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3.html/"/>
    <id>https://ityongzhen.github.io/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3.html/</id>
    <published>2020-04-21T00:32:24.000Z</published>
    <updated>2020-05-05T08:46:00.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io">个人博客</a> : <a href="https://ityongzhen.github.io">https://ityongzhen.github.io</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小程序开发与网页开发有很大的相似性</p><ul><li>在小程序开发中<ul><li>编写样式时建议多使用 flex 布局</li><li>支持 TypeScript</li><li>也可以自行搭建less、sass开发环境</li></ul></li></ul><h2 id="小程序开发-vs-网页开发"><a href="#小程序开发-vs-网页开发" class="headerlink" title="小程序开发 vs 网页开发"></a>小程序开发 vs 网页开发</h2><ul><li><p>网页开发中的渲染线程和脚本线程是互斥的，长时间的脚本运行可能会导致页面失去响应</p></li><li><p>网页开发者可以使用到各种浏览器暴露出来的DOMAPI，进行DOM选中和操作</p></li><li><p>在小程序中，页面渲染和业务逻辑是分开的，分别运行在不同的线程中</p><ul><li>逻辑层运行在JSCore中，并没有一个完整浏览器对象，因而缺少相关的DOMAPI和BOMAPI </li><li>因此非常熟悉的一些库，例如jQuery、Zepto等，在小程序中是无法运行的</li><li>同时JSCore的环境同NodeJS环境也是不完全相同的，所以一些NPM的包在小程序中也是无法运行的</li></ul></li><li><p>小程序的性能介于纯网页开发与原生（native）开发之间</p></li></ul><h2 id="小程序的运行环境"><a href="#小程序的运行环境" class="headerlink" title="小程序的运行环境"></a>小程序的运行环境</h2><table><thead><tr><th align="center">运行环境</th><th align="center">逻辑层</th><th align="center">渲染层</th></tr></thead><tbody><tr><td align="center">iOS</td><td align="center">JavaScriptCore</td><td align="center">WKWebView</td></tr><tr><td align="center">Android</td><td align="center">V8</td><td align="center">chromium定制内核</td></tr><tr><td align="center">开发者工具</td><td align="center">NWJS</td><td align="center">ChromeWebView</td></tr></tbody></table><h2 id="小程序-vs-APP"><a href="#小程序-vs-APP" class="headerlink" title="小程序 vs APP"></a>小程序 vs APP</h2><ul><li><p>安装使用</p><ul><li>小程序：无需安装、无需卸载、简单易用、占用内存较小</li><li>APP：需要主动联网下载安装APP、不想用了需要主动卸载</li></ul></li><li><p>开发</p><ul><li>小程序：跨平台、开发门槛低、开发周期短、开发成本低（对初创企业来说，是个很好的选择）</li><li>APP：开发成本高、每一个平台都要维护一套代码（目前也有ReactiveNative、Flutter等跨平台方案）</li></ul></li><li><p>发布上线</p><ul><li>小程序：提交到微信公众平台审核</li><li>APP：提交到应用商店审核（Apple的AppStore常有审核不通过的情况，审核周期也较长</li></ul></li><li><p>其他</p><ul><li>小程序用户体验、功能丰富度、开放性不如APP</li></ul></li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">开发文档</a> : <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p></li><li><p>[开发指南] (<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener">https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a</a> ) :<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener">https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a</a> </p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">开发工具</a>: <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p></li></ul><p>(官方开发工具不太好用，可以选择VS Code等)</p><ul><li><a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener">官方Demo</a> : <a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener">https://github.com/wechat-miniprogram/miniprogram-demo</a></li></ul><h2 id="注册小程序"><a href="#注册小程序" class="headerlink" title="注册小程序"></a>注册小程序</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/introduction/" target="_blank" rel="noopener">注册指南</a>：<a href="https://developers.weixin.qq.com/miniprogram/introduction/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/introduction/</a></li><li><a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">利用邮箱注册小程序</a>：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a> </li><li>注册完毕后会有一个小程序的AppID（唯一标识）</li></ul><h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><ul><li><a href="https://github.com/opendigg/awesome-github-wechat-weapp" target="_blank" rel="noopener">微信小程序开源项目库汇总</a>: <a href="https://github.com/opendigg/awesome-github-wechat-weapp" target="_blank" rel="noopener">https://github.com/opendigg/awesome-github-wechat-weapp</a></li><li><a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">微信小程序开发资源汇总</a>:<a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">https://github.com/justjavac/awesome-wechat-weapp</a></li></ul><h2 id="UI组件库"><a href="#UI组件库" class="headerlink" title="UI组件库"></a>UI组件库</h2><ul><li><a href="https://github.com/TalkingData/iview-weapp" target="_blank" rel="noopener">https://github.com/TalkingData/iview-weapp</a> </li><li><a href="https://github.com/youzan/vant-weapp" target="_blank" rel="noopener">https://github.com/youzan/vant-weapp</a> </li><li><a href="https://github.com/meili/minui" target="_blank" rel="noopener">https://github.com/meili/minui</a> </li><li><a href="https://github.com/wux-weapp/wux-weapp" target="_blank" rel="noopener">https://github.com/wux-weapp/wux-weapp</a> </li><li><a href="https://github.com/weilanwl/ColorUI" target="_blank" rel="noopener">https://github.com/weilanwl/ColorUI</a> </li><li><a href="https://github.com/Tencent/weui-wxss" target="_blank" rel="noopener">微信官方</a>：<a href="https://github.com/Tencent/weui-wxss" target="_blank" rel="noopener">https://github.com/Tencent/weui-wxss</a> </li><li><a href="https://github.com/NervJS/taro-ui" target="_blank" rel="noopener">京东凹凸实验室</a>：<a href="https://github.com/NervJS/taro-ui" target="_blank" rel="noopener">https://github.com/NervJS/taro-ui</a></li></ul><p>QQ交流群：592831498</p><p>参考资料：<a href="https://ke.qq.com/course/435191" target="_blank" rel="noopener">https://ke.qq.com/course/435191</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io&quot;&gt;个人博客&lt;/a&gt; : &lt;a href=&quot;https://ityongzhen.github.io&quot;&gt;https://ityongzhen.github.io&lt;/a&gt;&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="小程序" scheme="https://ityongzhen.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>实现iOS中的多语言切换</title>
    <link href="https://ityongzhen.github.io/%E5%AE%9E%E7%8E%B0iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2.html/"/>
    <id>https://ityongzhen.github.io/%E5%AE%9E%E7%8E%B0iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2.html/</id>
    <published>2020-03-27T00:32:24.000Z</published>
    <updated>2020-03-31T08:15:22.724Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/实现iOS中的多语言切换.html">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>我们日常使用App中，只有中文就够了，然而如果我们的App是面向国际化的，那么多语言就必不可少。本文整理了在iOS中多语言的实现。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加支持的语言"><a href="#添加支持的语言" class="headerlink" title="添加支持的语言"></a>添加支持的语言</h3><ul><li>选择工程，在info下面的<code>Localizations</code>中，点击加号按钮，添加支持的语言</li></ul><h3 id="建立strings文件"><a href="#建立strings文件" class="headerlink" title="建立strings文件"></a>建立strings文件</h3><ul><li>方法1.选择一个<code>storyboard</code>,例如默认的<code>Main.storyboard,</code>在<code>Localization</code>栏中勾选支持的语言。系统就会生成对应的文件。</li><li>方法2.我们直接新建<code>strings</code>资源文件。在该文件的<code>File Inspecter</code>的<code>Localizatio</code>n栏中勾选支持的语言。</li></ul><h3 id="准备对应文案"><a href="#准备对应文案" class="headerlink" title="准备对应文案"></a>准备对应文案</h3><ul><li>例如在<code>Localizable.strings(English)</code>中，</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"消息"</span> = <span class="string">"Messages"</span><span class="comment">;</span></span><br><span class="line"><span class="string">"搜索"</span> = <span class="string">" Search"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>思路：<ul><li>偏好设置中存储我们设置的语言，默认是简体中文</li><li>当我们切换多语言的时候，更改偏好设置中存储的语言</li><li>显示的时候，传入key。</li><li>如果设置了其他语言，就根据对应的bundle中的key取出对应value来显示</li></ul></li></ul><h3 id="切换多语言的实现"><a href="#切换多语言的实现" class="headerlink" title="切换多语言的实现"></a>切换多语言的实现</h3><h4 id="定义宏"><a href="#定义宏" class="headerlink" title="定义宏"></a>定义宏</h4><ul><li>定义多语言的宏，如下，定义了三种宏，分别是简体中文，繁体中文，英文，韩文</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Chinese_Simple @<span class="meta-string">"zh-Hans"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Chinese_Traditional @<span class="meta-string">"zh-Hant"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> English_US @<span class="meta-string">"en"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Korean @<span class="meta-string">"ko"</span></span></span><br></pre></td></tr></table></figure><p>定义偏好设置的文件名称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Language_Key @<span class="meta-string">"eagle_languageKey"</span></span></span><br></pre></td></tr></table></figure><h4 id="设置多语言"><a href="#设置多语言" class="headerlink" title="设置多语言"></a>设置多语言</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 设置多语言</span></span><br><span class="line"><span class="comment">/// @param language 语言</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">setNewLanguage:</span>(NSString *)language</span><br><span class="line">&#123;</span><br><span class="line">    NSString * setLanguage = [[NSUserDefaults standardUserDefaults] <span class="string">objectForKey:</span>Language_Key];</span><br><span class="line">    <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>setLanguage]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简体中文</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>Chinese_Simple]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>Chinese_Simple <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 繁体中文</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>Chinese_Traditional]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>Chinese_Traditional <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 英文</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>English_US]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>English_US <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 韩语</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([language <span class="string">isEqualToString:</span>Korean]) &#123;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] <span class="string">setObject:</span>Korean <span class="string">forKey:</span>Language_Key];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> languageStringWithKey(key) [[LanguageTools sharedInstance] getStringForKey:key]</span></span><br><span class="line"></span><br><span class="line">NSString *<span class="keyword">title</span> = languageStringWithKey(@<span class="string">"确定"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>具体实现如下，先偏好设置存储的当前语言获取对应bundle，然后拿到这个bundle之后，根据key找到对应的值。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据语言名获取bundle</span></span><br><span class="line">- (<span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * setLanguage = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:Language_Key];</span><br><span class="line">    <span class="comment">//默认是简体中文</span></span><br><span class="line">    <span class="keyword">if</span> (setLanguage == <span class="literal">nil</span> || [setLanguage isEqualToString:<span class="string">@"zh-Hans-CN"</span>]) &#123;</span><br><span class="line">        setLanguage = Chinese_Simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> * bundlePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:setLanguage ofType:<span class="string">@"lproj"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key获取value</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)getStringForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSBundle</span> * bundle = [[LanguageTools sharedInstance] bundle];</span><br><span class="line">    <span class="keyword">if</span> (bundle) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> * valueString = <span class="built_in">NSLocalizedStringFromTableInBundle</span>(key, <span class="string">@"Localizable"</span>, bundle, <span class="string">@"HelloWord"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!KCNSSTRING_ISEMPTY(valueString)) &#123;</span><br><span class="line">            <span class="keyword">return</span> valueString;</span><br><span class="line">        &#125;</span><br><span class="line">        DDLogInfo(<span class="string">@"\n********** have not add key **********\n \"%@\" = \"%@\" \n****************************"</span>,key,key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(key, <span class="string">@"HelloWord"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(key, <span class="string">@"HelloWord"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSLocalizedString"><a href="#NSLocalizedString" class="headerlink" title="NSLocalizedString"></a><code>NSLocalizedString</code></h2><ul><li><p><code>NSLocalizedString</code>是一个定义在<code>NSBundle.h</code>中的宏，用途是寻找当前系统语言对应的<code>Localizable.strings</code>文件中的某个<code>key</code>的值。</p></li><li><p>第一个参数是<code>key</code>的名字，第二个参数是对这个“键值对”的注释，在用<code>genstrings</code>工具生成<code>Loclizable.strings</code>文件时会自动加上去。例如上面代码中的<code>HelloWord</code>就是注释。</p></li></ul><ul><li><code>NSLocalizedString</code>系列的四个宏，其实最终都是调用了<code>[bundle localizedStringForKey:(key) value:(val) table:(tbl)]</code>。根据我们的自定义程度不同可以选择不同的宏。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">NSLocalizedString(<span class="params">key</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">    <span class="literal">[NSB<span class="identifier">undle</span>.<span class="identifier">mainBundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:@"" <span class="identifier">table</span>:<span class="identifier">nil</span>]</span></span><br><span class="line">#define <span class="constructor">NSLocalizedStringFromTable(<span class="params">key</span>, <span class="params">tbl</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">    <span class="literal">[NSB<span class="identifier">undle</span>.<span class="identifier">mainBundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:@"" <span class="identifier">table</span>:(<span class="identifier">tbl</span>)]</span></span><br><span class="line">#define <span class="constructor">NSLocalizedStringFromTableInBundle(<span class="params">key</span>, <span class="params">tbl</span>, <span class="params">bundle</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">    <span class="literal">[<span class="identifier">bundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:@"" <span class="identifier">table</span>:(<span class="identifier">tbl</span>)]</span></span><br><span class="line">#define <span class="constructor">NSLocalizedStringWithDefaultValue(<span class="params">key</span>, <span class="params">tbl</span>, <span class="params">bundle</span>, <span class="params">val</span>, <span class="params">comment</span>)</span> \</span><br><span class="line">    <span class="literal">[<span class="identifier">bundle</span> <span class="identifier">localizedStringForKey</span>:(<span class="identifier">key</span>) <span class="identifier">value</span>:(<span class="identifier">val</span>) <span class="identifier">table</span>:(<span class="identifier">tbl</span>)]</span></span><br></pre></td></tr></table></figure><p>上面基本就是实现一个可控的多语言版本的实现过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/实现iOS中的多语言切换.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://ityongzhen.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Dart中的Future使用</title>
    <link href="https://ityongzhen.github.io/Dart%E4%B8%AD%E7%9A%84Future%E4%BD%BF%E7%94%A8.html/"/>
    <id>https://ityongzhen.github.io/Dart%E4%B8%AD%E7%9A%84Future%E4%BD%BF%E7%94%A8.html/</id>
    <published>2020-03-20T00:32:24.000Z</published>
    <updated>2020-05-05T15:25:27.973Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Dart中的异步使用.html/">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于异步，相信很多开发者都是经常用到的。不过，不同的语言有不同的处理方式</p><h3 id="一般耗时操作的处理"><a href="#一般耗时操作的处理" class="headerlink" title="一般耗时操作的处理"></a>一般耗时操作的处理</h3><p>针对如何处理耗时的操作，不同的语言有不同的处理方式。</p><ul><li><p>处理方式一： 多线程，比如<code>Java</code>、<code>C++</code>，<code>Objective C</code>我们普遍的做法是开启一个新的线程（<code>Thread</code>），在新的线程中完成这些异步的操作，再通过线程间通信的方式，将拿到的数据传递给主线程。</p></li><li><p>处理方式二： 单线程+事件循环，比如<code>JavaScript</code>、<code>Dart</code>都是基于单线程加事件循环来完成耗时操作的处理。</p></li></ul><h3 id="阻塞式调用和非阻塞式调用"><a href="#阻塞式调用和非阻塞式调用" class="headerlink" title="阻塞式调用和非阻塞式调用"></a>阻塞式调用和非阻塞式调用</h3><ul><li><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p></li><li><p>阻塞式调用： 调用结果返回之前，当前线程会被挂起，调用线程只有在得到调用结果之后才会继续执行。</p></li><li><p>非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。</p></li></ul><p>例如你平时做饭的时候，把米放在电饭煲里面煮，这时候你可以在旁边坐着等着米饭做好，然后去做菜，这就是阻塞式调用。当然了。你也可以煮饭时候，准备菜，啤酒鸭，麻辣小龙虾。。这就是非阻塞式调用。</p><h2 id="Dart事件循环"><a href="#Dart事件循环" class="headerlink" title="Dart事件循环"></a>Dart事件循环</h2><h3 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h3><p>单线程模型中主要就是在维护着一个事件循环（Event Loop）。</p><p>事件循环是什么呢？</p><ul><li><p>事实上事件循环并不复杂，它就是将需要处理的一系列事件（包括点击事件、IO事件、网络事件）放在一个事件队列（Event Queue）中。</p></li><li><p>不断的从事件队列（Event Queue）中取出事件，并执行其对应需要执行的代码块，直到事件队列清空位置。</p></li><li><p>当我们有一些事件时，比如点击事件、IO事件、网络事件时，它们就会被加入到eventLoop中，当发现事件队列不为空时发现，就会取出事件，并且执行。</p></li></ul><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们先看一个例子：如下代码中，用sleep代替网络请求的耗时操作</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  <span class="built_in">String</span> res = getData();</span><br><span class="line">  <span class="built_in">print</span>(res);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> getData()&#123;</span><br><span class="line">  sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>start</p></blockquote><p>2秒钟之后输出</p><blockquote><p>hello world</p><p>end</p></blockquote><p>很显然阻塞了后面的代码执行</p><h2 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h2><p><code>Future</code> 表示一件“将来”会发生的事情，将来可以从Future中取到一个值。<br>有了Future之后，通过.then的回调去获取请求到的结果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">var</span> res = getData();</span><br><span class="line">  res.then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getData()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Future&lt;<span class="built_in">String</span>&gt;(() &#123;</span><br><span class="line">     sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a><code>catchError</code></h3><p>如果有异常的话，我们可以用catchError来捕获</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">var</span> res = getData();</span><br><span class="line">  res.then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value);</span><br><span class="line">  &#125;).catchError((error)&#123;<span class="comment">// 捕获出现异常时的情况</span></span><br><span class="line">    <span class="built_in">print</span>(error);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getData()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Future&lt;<span class="built_in">String</span>&gt;(() &#123;</span><br><span class="line">     sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//  return "hello world";</span></span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">"请求异常"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><blockquote><p>start</p></blockquote><blockquote><p>end</p></blockquote><blockquote><p>Exception: 请求异常</p></blockquote><h3 id="Future的链式调用"><a href="#Future的链式调用" class="headerlink" title="Future的链式调用"></a>Future的链式调用</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">ma<span class="meta">in(</span><span class="meta">List</span>&lt;String&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  p<span class="meta">rint(</span><span class="string">"start"</span>);</span><br><span class="line">  var res = getData();</span><br><span class="line">  res.th<span class="meta">en(</span>(value) &#123;</span><br><span class="line">    p<span class="meta">rint(</span>value);</span><br><span class="line">    <span class="meta">return</span> <span class="string">"第一次调用完成"</span>;</span><br><span class="line">  &#125;).th<span class="meta">en(</span>(value2)&#123;</span><br><span class="line"></span><br><span class="line">     p<span class="meta">rint(</span>value2);</span><br><span class="line">    <span class="meta">return</span> <span class="string">"第二次调用完成"</span>;</span><br><span class="line">  &#125;).th<span class="meta">en(</span>(value3)&#123;</span><br><span class="line"></span><br><span class="line">     p<span class="meta">rint(</span>value3);</span><br><span class="line">  &#125;).catchError((<span class="meta">error</span>)&#123;</span><br><span class="line">    p<span class="meta">rint(</span><span class="meta">error</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">  p<span class="meta">rint(</span><span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; getData()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">return</span> Future&lt;String&gt;(() &#123;</span><br><span class="line">     sleep(Durati<span class="meta">on(</span>seconds: 2));</span><br><span class="line">     <span class="meta">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    // throw Excepti<span class="meta">on(</span><span class="string">"请求异常"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>start</p><p>end</p><p>hello world</p><p>第一次调用完成</p><p>第二次调用完成</p></blockquote><h3 id="直接获取一个完成的Future，该Future会直接调用then的回调函数"><a href="#直接获取一个完成的Future，该Future会直接调用then的回调函数" class="headerlink" title="直接获取一个完成的Future，该Future会直接调用then的回调函数"></a>直接获取一个完成的Future，该Future会直接调用then的回调函数</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">  </span><br><span class="line">  Future.value(<span class="string">"测试"</span>).then((value)&#123;</span><br><span class="line">    <span class="built_in">print</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><blockquote><p>start</p><p>end</p><p>测试</p></blockquote><p>我们可以看到，<code>测试</code>是最后才打印，这是因为Future中的then会作为新的任务会加入到事件队列中（Event Queue），加入之后你需要排队执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>创建一个Future（可能是我们创建的，也可能是调用内部API或者第三方API获取到的一个Future，总之你需要获取到一个Future实例，Future通常会对一些异步的操作进行封装）；</li><li>通过.then(成功回调函数)的方式来监听Future内部执行完成时获取到的结果；</li><li>通过.catchError(失败或异常回调函数)的方式来监听Future内部执行失败或者出现异常时的错误信息；</li><li>可以链式调用</li><li>直接获取一个完成的Future，该Future会直接调用then的回调函数</li></ul><p>QQ交流群：592831498</p><p><a href="https://ityongzhen.github.io/Dart中的异步使用.html/">个人博客</a>：<a href="https://ityongzhen.github.io">https://ityongzhen.github.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Dart中的异步使用.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Dart语法之泛型</title>
    <link href="https://ityongzhen.github.io/Dart%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%B3%9B%E5%9E%8B.html/"/>
    <id>https://ityongzhen.github.io/Dart%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%B3%9B%E5%9E%8B.html/</id>
    <published>2020-03-10T00:32:24.000Z</published>
    <updated>2020-05-05T05:38:16.608Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Dart语法之泛型.html/">个人博客</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>泛型是很多语言都支持的一种语法。例如Swift,Java,C++等。之前的文章<a href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/">C++语法之模板</a> 详细介绍了C++中的泛型。</li></ul><h2 id="List泛型使用"><a href="#List泛型使用" class="headerlink" title="List泛型使用"></a>List泛型使用</h2><ul><li>List 的泛型使用</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建List的方式</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'eagle'</span>,<span class="string">'ityongzhen'</span>,<span class="string">"abc"</span>];</span><br><span class="line"><span class="built_in">print</span>(names); <span class="comment">//[eagle, ityongzhen, abc]</span></span><br><span class="line"><span class="built_in">print</span>(names.runtimeType); <span class="comment">//List&lt;String&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们没有指定具体类型，但是跟根据类型推断可知其类型为 <code>List&lt;String&gt;</code><br>除了类型的自动推断，还可以限制类型。如下</p><ul><li>限制类型</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制类型</span></span><br><span class="line"><span class="keyword">var</span> names2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">'eagle'</span>,<span class="string">'ityongzhen'</span>,<span class="string">"abc"</span>]; <span class="comment">//List&lt;String&gt;</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names3 = [<span class="string">'eagle'</span>,<span class="string">'ityongzhen'</span>,<span class="string">"abc"</span>]; <span class="comment">//List&lt;String&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Map泛型使用"><a href="#Map泛型使用" class="headerlink" title="Map泛型使用"></a>Map泛型使用</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Map的方式</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="string">'name'</span>:<span class="string">'eagle'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(person.runtimeType);<span class="comment">//_InternalLinkedHashMap&lt;String, Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//限制类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; person2 = &#123;<span class="string">'name'</span>:<span class="string">'eagle'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> person3 = &lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;&#123;<span class="string">'name'</span>:<span class="string">'eagle'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="类定义的泛型"><a href="#类定义的泛型" class="headerlink" title="类定义的泛型"></a>类定义的泛型</h2><ul><li><p>如果我们需要定义一个类, 用于存储位置信息Location, 但是并不确定使用者希望使用的是int类型,还是double类型,  甚至是一个字符串, 这个时候如何定义呢?</p></li><li><p>一种方案是使用Object类型, 但是在之后使用时, 非常不方便</p></li><li><p>另一种方案就是使用泛型.</p></li></ul><h3 id="Location类的定义-Object方式"><a href="#Location类的定义-Object方式" class="headerlink" title="Location类的定义: Object方式"></a>Location类的定义: Object方式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"></span><br><span class="line">Location loc1 = Location(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">Location loc2 = Location(<span class="number">10.6</span>, <span class="number">18.8</span>);</span><br><span class="line"><span class="built_in">print</span>(loc1.x.runtimeType); <span class="comment">//int</span></span><br><span class="line"><span class="built_in">print</span>(loc2.x.runtimeType); <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> x;</span><br><span class="line">  <span class="built_in">Object</span> y;</span><br><span class="line">  Location(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Location类的定义-泛型方式"><a href="#Location类的定义-泛型方式" class="headerlink" title="Location类的定义: 泛型方式"></a>Location类的定义: 泛型方式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断</span></span><br><span class="line">Location loc1 = Location(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">print</span>(loc1.x.runtimeType); <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型  double</span></span><br><span class="line">Location loc2 = Location&lt;<span class="built_in">double</span>&gt;(<span class="number">10.6</span>, <span class="number">18.8</span>);</span><br><span class="line"><span class="built_in">print</span>(loc2.x.runtimeType); <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型  String</span></span><br><span class="line">Location loc3 = Location&lt;<span class="built_in">String</span>&gt;(<span class="string">'abc'</span>, <span class="string">"ad"</span>);</span><br><span class="line"><span class="built_in">print</span>(loc3.x.runtimeType); <span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  T x;</span><br><span class="line">  T y;</span><br><span class="line">  Location(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果我们希望类型只能是num类型"><a href="#如果我们希望类型只能是num类型" class="headerlink" title="如果我们希望类型只能是num类型"></a>如果我们希望类型只能是num类型</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">List</span>&lt;<span class="type">String</span>&gt; args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断</span></span><br><span class="line"><span class="type">Location</span> loc1 = <span class="type">Location</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">print(loc1.x.runtimeType); <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型  double</span></span><br><span class="line"><span class="type">Location</span> loc2 = <span class="type">Location</span>&lt;double&gt;(<span class="number">10.6</span>, <span class="number">18.8</span>);</span><br><span class="line">print(loc2.x.runtimeType); <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错 因为类型必须继承自num</span></span><br><span class="line"><span class="type">Location</span> loc3 = <span class="type">Location</span>&lt;<span class="type">String</span>&gt;(<span class="symbol">'ab</span>c', <span class="string">"ad"</span>); <span class="comment">//报错</span></span><br><span class="line">print(loc3.x.runtimeType); <span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location&lt;T</span> <span class="keyword">extends</span> <span class="title">num&gt;</span></span>&#123;</span><br><span class="line">  <span class="type">T</span> x;</span><br><span class="line">  <span class="type">T</span> y;</span><br><span class="line">  <span class="type">Location</span>(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h2><ul><li>之前，Dart仅仅在类中支持泛型。后来在方法和函数中使用泛型的类型参数。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">'eagle'</span>, <span class="string">'ityongzhen'</span>];</span><br><span class="line">  <span class="keyword">var</span> first = getFirst(names);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$first</span> <span class="subst">$&#123;first.runtimeType&#125;</span>'</span>); <span class="comment">// eagle String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T getFirst&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="keyword">return</span> ts[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://ke.qq.com/course/469774" target="_blank" rel="noopener">https://ke.qq.com/course/469774</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Dart语法之泛型.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习之Dart语法(三)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%89).html/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%89).html/</id>
    <published>2020-02-16T00:32:24.000Z</published>
    <updated>2020-03-29T14:15:54.848Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(三).html/">个人博客</a></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote><p>Dart是一个面向对象的语言，面向对象中非常重要的概念就是类，类产生了对象。</p></blockquote><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>在Dart中，定义类用class关键字。<br>类通常有两部分组成：成员（member）和方法（method）。<br>定义类的伪代码如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">  类型 成员名;</span><br><span class="line">  返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个简单的Person类：</p><ul><li>这里有一个注意点: 我们在方法中使用属性(成员/实例变量)时，并没有加this；</li><li>Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略；</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在吃东西'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来使用这个类，创建对应的对象：</p><ul><li>注意：从Dart2开始，new关键字可以省略。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.创建类的对象</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">// 直接使用Person()也可以创建</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.给对象的属性赋值</span></span><br><span class="line">  p.name = <span class="string">'eagle'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.调用对象的方法</span></span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="普通构造方法"><a href="#普通构造方法" class="headerlink" title="普通构造方法"></a>普通构造方法</h3><p>我们知道, 当通过类创建一个对象时，会调用这个类的构造方法。</p><ul><li>当类中没有明确指定构造方法时，将默认拥有一个无参的构造方法。</li><li>前面的Person中我们就是在调用这个构造方法.</li></ul><p>我们也可以根据自己的需求，定义自己的构造方法:</p><p><strong>注意一：</strong>当有了自己的构造方法时，默认的构造方法将会失效，不能使用</p><ul><li>当然，你可能希望明确的写一个默认的构造方法，但是会和我们自定义的构造方法冲突；</li><li>这是因为Dart本身不支持函数的重载（名称相同, 参数不同的方式）。</li></ul><p><strong>注意二：</strong>这里我还实现了toString方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在实现构造方法时，通常做的事情就是通过<strong>参数给属性</strong>赋值<br>为了简化这一过程, Dart提供了一种更加简洁的语法糖形式.<br>上面的构造方法可以优化成下面的写法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Person(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span> &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="constructor">Person(<span class="params">this</span>.<span class="params">name</span>, <span class="params">this</span>.<span class="params">age</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="命名构造方法"><a href="#命名构造方法" class="headerlink" title="命名构造方法"></a>命名构造方法</h3><p>但是在开发中, 我们确实希望实现更多的构造方法，怎么办呢？</p><p>因为不支持方法（函数）的重载，所以我们没办法创建相同名称的构造方法。</p><p>我们需要使用命名构造方法:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person() &#123;</span><br><span class="line">    name = <span class="string">''</span>;</span><br><span class="line">    age = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 命名构造方法</span></span><br><span class="line">  Person.withArgments(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">print</span>(p1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.withArgments(<span class="string">'eagle'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">print</span>(p2);</span><br></pre></td></tr></table></figure><p>在之后的开发中, 我们也可以利用命名构造方法，提供更加便捷的创建对象方式:</p><p>比如开发中，我们需要经常将一个Map转成对象，可以提供如下的构造方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 新的构造方法</span></span><br><span class="line">Person.fromMap(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span>) &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="built_in">map</span>[<span class="string">'name'</span>];</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="built_in">map</span>[<span class="string">'age'</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上面的构造方法创建对象</span></span><br><span class="line"> var p3 = <span class="keyword">new</span> Person.fromMap(&#123;<span class="string">'name'</span>: <span class="string">'kobe'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;);</span><br><span class="line"> <span class="built_in">print</span>(p3);</span><br></pre></td></tr></table></figure><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>我们来重新定义一个类Point, 传入x/y，可以得到它们的距离distance:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误写法</span></span><br><span class="line">  <span class="comment">// Point(this.x, this.y) &#123;</span></span><br><span class="line">  <span class="comment">//   distance = sqrt(x * x + y * y);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的写法</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : distance = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种初始化变量的方法, 我们称之为初始化列表(Initializer list)</p><h3 id="重定向构造方法"><a href="#重定向构造方法" class="headerlink" title="重定向构造方法"></a>重定向构造方法</h3><p>在某些情况下, 我们希望在一个构造方法中去调用另外一个构造方法, 这个时候可以使用重定向构造方法：</p><p>在一个构造函数中，去调用另外一个构造函数（注意：是在冒号后面使用this调用）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="constructor">Person(<span class="params">this</span>.<span class="params">name</span>, <span class="params">this</span>.<span class="params">age</span>)</span>;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>from<span class="constructor">Name(String <span class="params">name</span>)</span> : this(name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量构造方法"><a href="#常量构造方法" class="headerlink" title="常量构造方法"></a>常量构造方法</h3><p>在某些情况下，传入相同值时，我们希望返回同一个对象，这个时候，可以使用常量构造方法.<br>默认情况下，创建对象时，即使传入相同的参数，创建出来的也不是同一个对象，看下面代码:</p><p>这里我们使用identical(对象1, 对象2)函数来判断两个对象是否是同一个对象:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 如果将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的</p><p>这样的构造方法就称之为常量构造方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">const</span> Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">const</span> Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造方法有一些注意点:</p><ul><li>注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的.</li><li>注意二: 为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字</li></ul><p>如果是将结果赋值给const修饰的标识符时，const可以省略.</p><h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><p>Dart提供了factory关键字, 用于通过工厂去获取对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">'eagle'</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Person&gt; _cache = &lt;<span class="built_in">String</span>, Person&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Person(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> p = Person._internal(name);</span><br><span class="line">      _cache[name] = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person._internal(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h2><p>默认情况下，Dart中类定义的属性是可以直接被外界访问的。<br>但是某些情况下，我们希望监控这个类的属性被访问的过程，这个时候就可以使用setter和getter了</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> d = Dog(<span class="string">"黄色"</span>);</span><br><span class="line">  d.setColor = <span class="string">"黑色"</span>;</span><br><span class="line">  <span class="built_in">print</span>(d.getColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog &#123;</span><br><span class="line">  <span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">String</span> <span class="built_in">get</span> getColor &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span> setColor(<span class="keyword">String</span> <span class="built_in">color</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">color</span> = <span class="built_in">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Dog(<span class="keyword">this</span>.<span class="built_in">color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。<br>Dart中的继承使用extends关键字，子类中使用super来访问父类。<br>父类中的所有成员变量和方法都会被继承,，但是构造方法除外。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">List</span>&lt;<span class="type">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="type">Person</span>();</span><br><span class="line">  p.age = <span class="number">18</span>;</span><br><span class="line">  p.run();</span><br><span class="line">  print(p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print('在奔跑ing');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以拥有自己的成员变量, 并且可以对父类的方法进行重写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    print('$name在奔跑ing');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类中可以调用父类的构造方法，对某些属性进行初始化：</p><p>子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。<br>如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Animal(<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'在奔跑ing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) : name=name, <span class="keyword">super</span>(age);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在奔跑ing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name=<span class="subst">$name</span>, age=<span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们知道，继承是多态使用的前提。<br>所以在定义很多通用的<strong>调用接口</strong>时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。<br>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。<br>什么是 抽象方法? 在Dart中没有具体实现的方法(没有方法体)，就是抽象方法。</p><p>抽象方法，必须存在于抽象类中。<br>抽象类是使用abstract声明的类。</p><p>下面的代码中, Shape类就是一个抽象类, 其中包含一个抽象方法.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  getArea();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  double r;</span><br><span class="line"></span><br><span class="line">  <span class="type">Circle</span>(<span class="keyword">this</span>.r);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> r * r * <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  double w;</span><br><span class="line">  double h;</span><br><span class="line"></span><br><span class="line">  <span class="type">Reactangle</span>(<span class="keyword">this</span>.w, <span class="keyword">this</span>.h);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项:</p><p><strong>注意一：</strong>抽象类不能实例化.<br><strong>注意二：</strong>抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写.</p><h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p>Dart中的接口比较特殊, 没有一个专门的关键字来声明接口.<br>默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现(因为Dart不支持多继承)<br>在开发中，我们通常将用于给别人实现的类声明为抽象类:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Runner</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'超人在奔跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'超人在飞'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h2><p>在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。<br>但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢?</p><p>使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。</p><p>Dart提供了另外一种方案: Mixin混入的方式</p><p>除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。<br>只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  var superMan = SuperMain();</span><br><span class="line">  superMan.run();</span><br><span class="line">  superMan.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Runner &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(<span class="string">'在奔跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Flyer &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    print(<span class="string">'在飞翔'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implements的方式要求必须对其中的方法进行重新实现</span></span><br><span class="line"><span class="comment">// class SuperMan implements Runner, Flyer &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">SuperMain</span> <span class="symbol">with</span> <span class="symbol">Runner, <span class="symbol">Flyer</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员和方法"><a href="#类成员和方法" class="headerlink" title="类成员和方法"></a>类成员和方法</h2><p>前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法<br>在Dart中我们使用static关键字来定义:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> stu = Student();</span><br><span class="line">  stu.name = <span class="string">'eagle'</span>;</span><br><span class="line">  stu.sno = <span class="number">110</span>;</span><br><span class="line">  stu.study();</span><br><span class="line"></span><br><span class="line">  Student.time = <span class="string">'早上8点'</span>;</span><br><span class="line">  <span class="comment">// stu.time = '早上9点'; 错误做法, 实例对象不能访问类成员</span></span><br><span class="line">  Student.attendClass();</span><br><span class="line">  <span class="comment">// stu.attendClass(); 错误做法, 实现对象补鞥呢访问类方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> sno;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> time;</span><br><span class="line"></span><br><span class="line">  study() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$name</span>在学习'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> attendClass() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'去上课'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举在开发中也非常常见, 枚举也是一种特殊的类, 通常用于表示固定数量的常量值。</p><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举使用enum关键字来进行定义:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(Colors.red);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colors</span> &#123;</span></span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的属性"><a href="#枚举的属性" class="headerlink" title="枚举的属性"></a>枚举的属性</h3><p>枚举类型中有两个比较常见的属性:</p><p>index: 用于表示每个枚举常量的索引, 从0开始.<br>values: 包含每个枚举值的List.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">red</span>.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">green</span>.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.<span class="built_in">blue</span>.index);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(Colors.values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  <span class="built_in">red</span>,</span><br><span class="line">  <span class="built_in">green</span>,</span><br><span class="line">  <span class="built_in">blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型的注意事项:</p><ul><li>注意一: 您不能子类化、混合或实现枚举。</li><li>注意二: 不能显式实例化一个枚举</li></ul><p>参考 <a href="https://ke.qq.com/course/469774" target="_blank" rel="noopener">https://ke.qq.com/course/469774</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(三).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习之Dart语法(二)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%BA%8C).html/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%BA%8C).html/</id>
    <published>2020-02-13T00:32:24.000Z</published>
    <updated>2020-03-11T07:30:06.127Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(二).html/">个人博客</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基本定义"><a href="#函数的基本定义" class="headerlink" title="函数的基本定义"></a>函数的基本定义</h3><ul><li>Dart是一种真正的面向对象语言，所以即使函数也是对象，所有也有类型, 类型就是Function。</li><li>这也就意味着函数可以作为变量定义或者作为其他函数的参数或者返回值.</li></ul><p>函数的定义方式:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值 函数的名称(参数列表) &#123;</span><br><span class="line">  函数体</span><br><span class="line">  <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的定义方式, 我们定义一个完整的函数:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum(<span class="built_in">num</span> num1, <span class="built_in">num</span> num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Effective Dart建议对公共的API, 使用类型注解, 但是如果我们省略掉了类型, 依然是可以正常工作的</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sum</span>(num1, num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外, 如果函数中只有一个表达式, 那么可以使用箭头语法(arrow syntax)</p><ul><li>注意, 这里面只能是一个表达式, 不能是一个语句</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum<span class="comment">(num1, num2)</span> =&gt; <span class="symbol">num1</span> + <span class="symbol">num2</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的参数问题"><a href="#函数的参数问题" class="headerlink" title="函数的参数问题"></a>函数的参数问题</h3><blockquote><p>函数的参数可以分成两类: 必须参数和可选参数<br>前面使用的参数都是必须参数.</p></blockquote><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>可选参数可以分为 命名可选参数 和 位置可选参数<br>定义方式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命名可选参数: &#123;para<span class="name">m1</span>, para<span class="name">m2</span>, ...&#125;</span><br><span class="line">位置可选参数: [para<span class="name">m1</span>, para<span class="name">m2</span>, ...]</span><br></pre></td></tr></table></figure><p>命名可选参数的演示:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数</span></span><br><span class="line">print<span class="constructor">Info1(String <span class="params">name</span>, &#123;<span class="params">int</span> <span class="params">age</span>, <span class="params">double</span> <span class="params">height</span>&#125;)</span> &#123;</span><br><span class="line">  print('name=$name age=$age height=$height');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printInfo1函数</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>')</span>; <span class="comment">// name=eagle age=null height=null</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">age</span>: 18)</span>; <span class="comment">// name=eagle age=18 height=null</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">age</span>: 18, <span class="params">height</span>: 1.88)</span>; <span class="comment">// name=eagle age=18 height=1.88</span></span><br><span class="line">print<span class="constructor">Info1('<span class="params">eagle</span>', <span class="params">height</span>: 1.88)</span>; <span class="comment">// name=eagle age=null height=1.88</span></span><br></pre></td></tr></table></figure><p>位置可选参数的演示:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义位置可选参数</span></span><br><span class="line">print<span class="constructor">Info2(String <span class="params">name</span>, [<span class="params">int</span> <span class="params">age</span>, <span class="params">double</span> <span class="params">height</span>])</span> &#123;</span><br><span class="line">  print('name=$name age=$age height=$height');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用printInfo2函数</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>')</span>; <span class="comment">// name=eagle age=null height=null</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>', 18)</span>; <span class="comment">// name=eagle age=18 height=null</span></span><br><span class="line">print<span class="constructor">Info2('<span class="params">eagle</span>', 18, 1.88)</span>; <span class="comment">// name=eagle age=18 height=1.88</span></span><br></pre></td></tr></table></figure><p>命名可选参数, 可以指定某个参数是必传的(使用@required, 有问题)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数的必须</span></span><br><span class="line">printInfo3(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age, <span class="built_in">double</span> height, <span class="meta">@required</span> <span class="built_in">String</span> address&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span> address=<span class="subst">$address</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>参数可以有默认值, 在不传入的情况下, 使用默认值</p><p>注意, 只有可选参数才可以有默认值, 必须参数不能有默认值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数的默认值</span></span><br><span class="line">printInfo4(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age = <span class="number">18</span>, <span class="built_in">double</span> height=<span class="number">1.88</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart中的main函数就是一个接受可选的列表参数作为参数的, 所以在使用main函数时, 我们可以传入参数, 也可以不传入</p><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>在很多语言中, 函数并不能作为一等公民来使用, 比如Java/OC. 这种限制让编程不够灵活, 所以现代的编程语言基本都支持函数作为一等公民来使用, Dart也支持.<br>这就意味着你可以将函数赋值给一个变量, 也可以将函数作为另外一个函数的参数或者返回值来使用.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.将函数赋值给一个变量</span></span><br><span class="line">  <span class="keyword">var</span> bar = foo;</span><br><span class="line">  <span class="built_in">print</span>(bar);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.将函数作为另一个函数的参数</span></span><br><span class="line">  test(foo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">  <span class="keyword">var</span> func =getFunc();</span><br><span class="line">  func(<span class="string">'kobe'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个函数</span></span><br><span class="line">foo(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'传入的name:<span class="subst">$name</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将函数作为另外一个函数的参数</span></span><br><span class="line">test(<span class="built_in">Function</span> func) &#123;</span><br><span class="line">  func(<span class="string">'eagle'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">getFunc() &#123;</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数的使用"><a href="#匿名函数的使用" class="headerlink" title="匿名函数的使用"></a>匿名函数的使用</h3><p>大部分我们定义的函数都会有自己的名字， 比如前面定义的foo、test函数等等。<br>但是某些情况下，给函数命名太麻烦了，我们可以使用没有名字的函数，这种函数可以被称之为匿名函数( anonymous function)，也可以叫lambda或者closure。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">List</span>&lt;String&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.定义数组</span></span><br><span class="line">  <span class="keyword">var</span> movies = [<span class="string">'盗梦空间'</span>, <span class="string">'星际穿越'</span>, <span class="string">'少年派'</span>, <span class="string">'大话西游'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.使用forEach遍历: 有名字的函数</span></span><br><span class="line">  printElement(item) &#123;</span><br><span class="line">    <span class="keyword">print</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  movies.<span class="keyword">forEach</span>(printElement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.使用forEach遍历: 匿名函数</span></span><br><span class="line">  movies.<span class="keyword">forEach</span>((item) &#123;</span><br><span class="line">    <span class="keyword">print</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  movies.<span class="keyword">forEach</span>((item) =&gt; <span class="keyword">print</span>(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>dart中的词法有自己明确的作用域范围，它是根据代码的结构({})来决定作用域范围的<br>优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// var name = 'main';</span></span><br><span class="line">  <span class="keyword">void</span> foo() &#123;</span><br><span class="line">    <span class="comment">// var name = 'foo';</span></span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h3><p>闭包可以访问其词法范围内的变量，即使函数在其他地方被使用，也可以正常的访问。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">num</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i + addBy;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adder2 = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">10</span>)); <span class="comment">// 12</span></span><br><span class="line">  <span class="built_in">print</span>(adder2(<span class="number">6</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> adder5 = makeAdder(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(adder5(<span class="number">10</span>)); <span class="comment">// 15</span></span><br><span class="line">  <span class="built_in">print</span>(adder5(<span class="number">6</span>)); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值问题"><a href="#返回值问题" class="headerlink" title="返回值问题"></a>返回值问题</h3><p>所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(foo()); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'foo function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="除法、整除、取模运算"><a href="#除法、整除、取模运算" class="headerlink" title="除法、整除、取模运算"></a>除法、整除、取模运算</h3><p>我们来看一下除法、整除、取模运算</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> / <span class="number">3</span>); <span class="comment">// 除法操作, 结果2.3333..</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> ~/ <span class="number">3</span>); <span class="comment">// 整除操作, 结果2;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> % <span class="number">3</span>); <span class="comment">// 取模操作, 结果1;</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="??=赋值操作"></a>??=赋值操作</h3><p>dart有一个很多语言都不具备的赋值运算符：</p><ul><li>当变量为null时，使用后面的内容进行赋值。</li><li>当变量有值时，使用自己原来的值。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> name1 = <span class="string">'eagle'</span>;</span><br><span class="line">  <span class="built_in">print</span>(name1);</span><br><span class="line">  <span class="comment">// var name2 = 'kobe';</span></span><br><span class="line">  <span class="keyword">var</span> name2 = <span class="keyword">null</span>;</span><br><span class="line">  name2 ??= <span class="string">'james'</span>; </span><br><span class="line">  <span class="built_in">print</span>(name2); <span class="comment">// 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件运算符："><a href="#条件运算符：" class="headerlink" title="条件运算符："></a>条件运算符：</h3><p>Dart中包含一直比较特殊的条件运算符：expr1 ?? expr2</p><ul><li>如果expr1是null，则返回expr2的结果;</li><li>如果expr1不是null，直接使用expr1的结果。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">temp</span> = <span class="string">'eagle'</span>;</span><br><span class="line">var <span class="keyword">temp</span> = <span class="keyword">null</span>;</span><br><span class="line">var <span class="type">name</span> = <span class="keyword">temp</span> ?? <span class="string">'kobe'</span>;</span><br><span class="line">print(<span class="type">name</span>);</span><br></pre></td></tr></table></figure><h3 id="级联语法："><a href="#级联语法：" class="headerlink" title="级联语法：.."></a>级联语法：..</h3><ul><li>某些时候，我们希望对一个对象进行连续的操作，这个时候可以使用级联语法</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  void <span class="builtin-name">run</span>() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is running"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void eat() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is eating"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swim() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"<span class="variable">$&#123;name&#125;</span> is swimming"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p1 = Person();</span><br><span class="line">  p1.name = <span class="string">'eagle'</span>;</span><br><span class="line">  p1.<span class="builtin-name">run</span>();</span><br><span class="line">  p1.eat();</span><br><span class="line">  p1.swim();</span><br><span class="line"></span><br><span class="line">  final p2 = Person()</span><br><span class="line">              <span class="built_in">..</span>name = <span class="string">"eagle"</span></span><br><span class="line">              <span class="built_in">..</span><span class="builtin-name">run</span>()</span><br><span class="line">              <span class="built_in">..</span>eat()</span><br><span class="line">              <span class="built_in">..</span>swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>和大部分语言的特性比较相似，这里就不再详细赘述，看一下即可。</p><h3 id="if和else"><a href="#if和else" class="headerlink" title="if和else"></a>if和else</h3><p>和其他语言用法一样<br>这里有一个注意点：不支持非空即真或者非0即真，必须有明确的bool类型</p><ul><li>我们来看下面name为null的判断</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var age = <span class="built_in">null</span>;</span><br><span class="line"><span class="keyword">if</span>(age)&#123; <span class="comment">//错误的用法</span></span><br><span class="line">   <span class="keyword">print</span>(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h3><p>基本的for循环</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  print(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for in遍历List和Set类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'eagle'</span>, <span class="string">'kobe'</span>, <span class="string">'curry'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names) &#123;</span><br><span class="line">  <span class="built_in">print</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while和do-while和其他语言一致<br>break和continue用法也是一致</p><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>普通的switch使用</p><p>注意：每一个case语句，默认情况下必须以一个break结尾</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> direction = <span class="string">'east'</span>;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'east'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'东面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'south'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'南面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'west'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'西面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'north'</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'北面'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'其他方向'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://juejin.im/post/5d76340c6fb9a06adb800961" target="_blank" rel="noopener">Flutter(三)之搞定Dart（一）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(二).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习之Dart语法(一)</title>
    <link href="https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80).html/"/>
    <id>https://ityongzhen.github.io/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8BDart%E8%AF%AD%E6%B3%95(%E4%B8%80).html/</id>
    <published>2020-02-10T00:32:24.000Z</published>
    <updated>2020-02-29T06:18:32.280Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/Flutter学习之Dart语法(一).html/">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准 。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</li><li>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system</li></ul><p><strong>Google为Flutter选择了Dart作为开发语言</strong></p><p>关于Dart的环境安装和配置这里就不赘述了。</p><h2 id="新建程序"><a href="#新建程序" class="headerlink" title="新建程序"></a>新建程序</h2><p>用VSCode新建一个Dart文件，默认是如下代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这也和Java,C等等其他语言一样，main函数作为入口。</p><ul><li>Dart语言的入口也是main函数，并且必须显示的进行定义；</li><li>Dart的入口函数main是没有返回值的；</li><li>传递给main的命令行参数，是通过List<String>完成的。<ul><li>从字面值就可以理解List是Dart中的集合类型。</li><li>其中的每一个String都表示传递给main的一个参数；</li></ul></li><li>定义字符串的时候，可以使用单引号或双引号；</li><li>每行语句必须使用分号结尾，很多语言并不需要分号，比如Swift、JavaScript；</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="明确声明-Explicit"><a href="#明确声明-Explicit" class="headerlink" title="明确声明(Explicit)"></a>明确声明(Explicit)</h3><p>明确声明变量的方式, 格式如下:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量类型 变量名称 = 赋值<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>示例代码:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>注意: 定义的变量可以修改值, 但是不能赋值其他类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="attribute">content</span> = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="attribute">content</span> = <span class="string">'Hello China'</span>; <span class="comment">// 正确的</span></span><br><span class="line"><span class="attribute">content</span> = <span class="number">111</span>; <span class="comment">// 错误的, 将一个int值赋值给一个String变量</span></span><br></pre></td></tr></table></figure><h3 id="类型推导-Type-Inference"><a href="#类型推导-Type-Inference" class="headerlink" title="类型推导(Type Inference)"></a>类型推导(Type Inference)</h3><p>和swift等语言类似，Dart也是支持类型推导的，类型推导声明变量的方式, 格式如下:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="keyword">dynamic</span>/<span class="keyword">const</span>/<span class="keyword">final</span> 变量名称 = 赋值;</span><br></pre></td></tr></table></figure><h4 id="var的使用"><a href="#var的使用" class="headerlink" title="var的使用"></a>var的使用</h4><p>var的使用示例:</p><ul><li>runtimeType用于获取变量当前的类型</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">name</span> = <span class="string">'ITYongzhen'</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// String</span></span><br></pre></td></tr></table></figure><p>var的错误用法:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="string">'eagle'</span>; <span class="comment">// 不可以将String赋值给一个int类型</span></span><br></pre></td></tr></table></figure><h4 id="dynamic的使用"><a href="#dynamic的使用" class="headerlink" title="dynamic的使用"></a>dynamic的使用</h4><p>如果确实希望这样做,可以使用dynamic来声明变量:</p><ul><li>但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">name</span> = <span class="number">18</span>;</span><br><span class="line">print(<span class="keyword">name</span>.runtimeType); <span class="comment">// int</span></span><br></pre></td></tr></table></figure><h4 id="final-amp-const的使用"><a href="#final-amp-const的使用" class="headerlink" title="final&amp;const的使用"></a>final&amp;const的使用</h4><p>final和const都是用于定义常量的, 也就是定义之后值都不可以修改</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">name</span> = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">name</span> = <span class="string">'ITyongzhen'</span>; <span class="comment">// 错误做法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="number">20</span>; <span class="comment">// 错误做法</span></span><br></pre></td></tr></table></figure><h4 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h4><p>const在赋值时, 赋值的内容必须是在编译期间就确定下来的<br>final在赋值时, 可以动态获取, 比如赋值一个函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> getName() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'eagle'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = getName(); <span class="comment">// 错误的做法, 因为要执行函数才能获取到值</span></span><br><span class="line">  <span class="keyword">final</span> name = getName(); <span class="comment">// 正确的做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final和const小案例:</p><ul><li>首先, const是不可以赋值为DateTime.now()</li><li>其次, final一旦被赋值后就有确定的结果, 不会再次赋值</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const time = DateTime.now(); // 错误的赋值方式</span></span><br><span class="line">final time = DateTime.now();</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">time</span>); <span class="comment">// 2020-02-05 12:04:50.052626</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">time</span>); <span class="comment">// 2020-02-05 12:04:50.052626</span></span><br></pre></td></tr></table></figure><p>const放在赋值语句的右边，可以共享对象，提高性能:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">Person</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;<span class="keyword">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> a = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="keyword">final</span> b = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(a, b)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> m = Person();</span><br><span class="line">  <span class="keyword">final</span> n = Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(m, n)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><h4 id="int和double"><a href="#int和double" class="headerlink" title="int和double"></a><code>int</code>和<code>double</code></h4><p>对于数值来说，我们也不用关心它是否有符号，以及数据的宽度和精度等问题。只要记着整数用<code>int</code>，浮点数用<code>double</code>就行了。<br>不过，要注意的是<code>Dart</code>中的<code>int</code>和<code>double</code>可表示的范围并不是固定的，它取决于运行Dart的平台。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.整数类型int</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> hexAge = <span class="number">0x12</span>;</span><br><span class="line"><span class="built_in">print</span>(age);</span><br><span class="line"><span class="built_in">print</span>(hexAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.浮点类型double</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">height</span> = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">height</span>);</span><br></pre></td></tr></table></figure><h4 id="字符串和数字之间的转化"><a href="#字符串和数字之间的转化" class="headerlink" title="字符串和数字之间的转化"></a>字符串和数字之间的转化</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串和数字转化</span></span><br><span class="line"><span class="comment">// 1.字符串转数字</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">'111'</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="built_in">double</span>.parse(<span class="string">'12.22'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;one&#125;</span> <span class="subst">$&#123;one.runtimeType&#125;</span>'</span>); <span class="comment">// 111 int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;two&#125;</span> <span class="subst">$&#123;two.runtimeType&#125;</span>'</span>); <span class="comment">// 12.22 double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.数字转字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123.456</span>;</span><br><span class="line"><span class="keyword">var</span> num1Str = num1.toString();</span><br><span class="line"><span class="keyword">var</span> num2Str = num2.toString();</span><br><span class="line"><span class="keyword">var</span> num2StrD = num2.toStringAsFixed(<span class="number">2</span>); <span class="comment">// 保留两位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num1Str&#125;</span> <span class="subst">$&#123;num1Str.runtimeType&#125;</span>'</span>); <span class="comment">// 123 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num2Str&#125;</span> <span class="subst">$&#123;num2Str.runtimeType&#125;</span>'</span>); <span class="comment">// 123.456 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;num2StrD&#125;</span> <span class="subst">$&#123;num2StrD.runtimeType&#125;</span>'</span>); <span class="comment">// 123.46 String</span></span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型中,Dart提供了一个bool的类型, 取值为true和false</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="keyword">var</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$isFlag</span> <span class="subst">$&#123;isFlag.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p><strong>注意: Dart中不能判断非0即真, 或者非空即真</strong></p><p>Dart的类型安全性意味着您不能使用if(非booleanvalue)或assert(非booleanvalue)之类的代码。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">message</span> = <span class="string">'Hello Dart'</span>;</span><br><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">message</span>) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  print(message)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>Dart字符串是UTF-16编码单元的序列。您可以使用单引号或双引号创建一个字符串:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义字符串的方式</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="symbol">'Hello</span> <span class="type">World</span>';</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"Hello Dart"</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="symbol">'Hello</span>\<span class="symbol">'Fullte</span>r';</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">"Hello'Fullter"</span>;</span><br></pre></td></tr></table></figure><p>可以使用三个单引号或者双引号表示多行字符串:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="number">2</span>.表示多行字符串的方式</span><br><span class="line">var message1 = <span class="string">'''</span></span><br><span class="line"><span class="string">哈哈哈</span></span><br><span class="line"><span class="string">呵呵呵</span></span><br><span class="line"><span class="string">嘿嘿嘿'''</span>;</span><br></pre></td></tr></table></figure><p>字符串和其他变量或表达式拼接: 使用<code>${expression}</code>, 如果表达式是一个标识符, 那么<code>{}</code>可以省略</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.拼接其他变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'eagle'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$age</span>, height is <span class="subst">$height</span>'</span>);</span><br></pre></td></tr></table></figure><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><ul><li>集合类型的定义</li></ul><p>对于集合类型，Dart则内置了最常用的三种：<code>List / Set / Map</code>。<br>其中，<code>List</code>可以这样来定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$letters</span> <span class="subst">$&#123;letters.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$&#123;numbers.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>其中，<code>set</code>可以这样来定义：</p><p>其实，也就是把[]换成{}就好了。<br>Set和List最大的两个不同就是：Set是无序的，并且元素是不重复的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set的定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> lettersSet = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$lettersSet</span> <span class="subst">$&#123;lettersSet.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">int</span>&gt; numbersSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbersSet</span> <span class="subst">$&#123;numbersSet.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>最后，Map是我们常说的字典类型，它的定义是这样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map的定义</span></span><br><span class="line"><span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="keyword">var</span> infoMap1 = &#123;<span class="string">'name'</span>: <span class="string">'eagle'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$infoMap1</span> <span class="subst">$&#123;infoMap1.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; infoMap2 = &#123;<span class="string">'height'</span>: <span class="number">1.88</span>, <span class="string">'address'</span>: <span class="string">'北京市'</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$infoMap2</span> <span class="subst">$&#123;infoMap2.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><h4 id="集合的常见操作"><a href="#集合的常见操作" class="headerlink" title="集合的常见操作"></a>集合的常见操作</h4><p>了解了这三个集合的定义方式之后，我们来看一些最基础的公共操作</p><p>第一类，是所有集合都支持的获取长度的属性length：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取集合的长度</span></span><br><span class="line"><span class="keyword">print</span>(letters.length);</span><br><span class="line"><span class="keyword">print</span>(lettersSet.length);</span><br><span class="line"><span class="keyword">print</span>(infoMap1.length);</span><br></pre></td></tr></table></figure><p>第二类, 是添加/删除/包含操作</p><p>并且，对List来说，由于元素是有序的，它还提供了一个删除指定索引位置上元素的方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加/删除/包含元素</span></span><br><span class="line">numbers.add(<span class="number">5</span>);</span><br><span class="line">numbersSet.add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$numbersSet</span>'</span>);</span><br><span class="line"></span><br><span class="line">numbers.remove(<span class="number">1</span>);</span><br><span class="line">numbersSet.remove(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span> <span class="subst">$numbersSet</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers.contains(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">print</span>(numbersSet.contains(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// List根据index删除元素</span></span><br><span class="line">numbers.removeAt(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$numbers</span>'</span>);</span><br></pre></td></tr></table></figure><p>第三类，是Map的操作</p><p>由于它有key和value，因此无论是读取值，还是操作，都要明确是基于key的，还是基于value的，或者是基于key/value对的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map的操作</span></span><br><span class="line"><span class="comment">// 1.根据key获取value</span></span><br><span class="line"><span class="built_in">print</span>(infoMap1[<span class="string">'name'</span>]); <span class="comment">// eagle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取所有的entries</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.entries&#125;</span> <span class="subst">$&#123;infoMap1.entries.runtimeType&#125;</span>'</span>); <span class="comment">// (MapEntry(name: eagle), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取所有的keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.keys&#125;</span> <span class="subst">$&#123;infoMap1.keys.runtimeType&#125;</span>'</span>); <span class="comment">// (name, age) _CompactIterable&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取所有的values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.values&#125;</span> <span class="subst">$&#123;infoMap1.values.runtimeType&#125;</span>'</span>); <span class="comment">// (eagle, 18) _CompactIterable&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.判断是否包含某个key或者value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1.containsKey(<span class="string">'age'</span>)&#125;</span> <span class="subst">$&#123;infoMap1.containsValue(<span class="number">18</span>)&#125;</span>'</span>); <span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.根据key删除元素</span></span><br><span class="line">infoMap1.remove(<span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;infoMap1&#125;</span>'</span>); <span class="comment">// &#123;name: eagle&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/Flutter学习之Dart语法(一).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://ityongzhen.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之类型转换</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html/</id>
    <published>2020-01-09T21:32:24.000Z</published>
    <updated>2020-03-10T02:55:45.736Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之类型转换.html/">个人博客</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>C语言风格的类型转换符<ul><li><code>(type)expression</code></li><li><code>type(expression)</code></li></ul></li><li>C++中有4个类型转换符<ul><li><code>static_cast</code></li><li><code>dynamic_cast</code></li><li><code>reinterpret_cast</code></li><li><code>const_cast</code></li><li>使用格式：<code>xx_cast&lt;type&gt;(expression)</code></li></ul></li></ul><p>我们有如下Person类和Student类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">     <span class="built_in">void</span> run() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student</span> : <span class="symbol">public</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接用子类指针指向父类对象，编译报错</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *p = <span class="keyword">new</span> <span class="type">Person</span>(); <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><p>C语言的做法一般是</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *p = (Student *)<span class="keyword">new</span> <span class="type">Person</span>(); <span class="comment">//编译正常</span></span><br></pre></td></tr></table></figure><p>强制转换只是欺骗编译器，有时候编译正常，执行会报错。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h2><ul><li>一般用于去除<code>const</code>属性，将<code>const</code>转换成非<code>const</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person *p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1-&gt;age = <span class="number">10</span>; <span class="comment">//编译报错</span></span><br><span class="line">    </span><br><span class="line">Person *p2 = <span class="keyword">const_cast</span>&lt;Person *&gt;(p1);</span><br><span class="line">p2-&gt;age = <span class="number">10</span>; <span class="comment">//编译正常</span></span><br></pre></td></tr></table></figure><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h2><ul><li>◼ 一般用于多态类型的转换，有运行时安全检测</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student *stu1 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(P1); <span class="comment">//null</span></span><br><span class="line">    Student *stu2 = <span class="keyword">dynamic_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line">    Car *car = <span class="keyword">dynamic_cast</span>&lt;Car *&gt;(P1); <span class="comment">//null</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; car&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x100660110</span></span><br><span class="line"><span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>上面的代码中，随便编译都是正常的。但是运行的事，检测到P1不是Student类型，也不是Car类型，所以转换之后的stu1和car都是Null.</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h2><p>对比dynamic_cast，缺乏运行时安全检测</p><ul><li>不能交叉转换（不是同一继承体系的，无法转换）</li><li>常用于基本数据类型的转换、非const转成const</li></ul><p>上面的代码中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student *stu1 = <span class="keyword">static_cast</span>&lt;Student *&gt;(P1);</span><br><span class="line">    Student *stu2 = <span class="keyword">static_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line"><span class="comment">//    Car *car = static_cast&lt;Car *&gt;(P1); //编译报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100555390</span></span><br><span class="line"><span class="number">0x10063e9b0</span></span><br></pre></td></tr></table></figure><p>可知<code>Person</code>类型的P1可以转换为 Person <code>类型或者</code>Student `类型</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h2><ul><li>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝</li><li>可以交叉转换</li><li>可以将指针和整数互相转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person *P1 = <span class="keyword">new</span> Person();</span><br><span class="line"> Person *P2 = <span class="keyword">new</span> Student();</span><br><span class="line"> Student *stu1 = <span class="keyword">reinterpret_cast</span>&lt;Student *&gt;(P1); <span class="comment">//null</span></span><br><span class="line"> Student *stu2 = <span class="keyword">reinterpret_cast</span>&lt;Student *&gt;(P2);</span><br><span class="line"> Car *car = <span class="keyword">reinterpret_cast</span>&lt;Car *&gt;(P1);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; stu1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; car&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出如下，可知都可以转换成功，因为只是拷贝二进制</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10062e6e0</span></span><br><span class="line"><span class="number">0x10062b940</span></span><br><span class="line"><span class="number">0x10062e6e0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之类型转换.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类型转换&quot;&gt;&lt;a href=&quot;#类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型转换&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之模板</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%9D%BF.html/</id>
    <published>2019-12-27T21:32:24.000Z</published>
    <updated>2020-03-09T02:41:02.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之模板.html/">个人博客</a></p><h2 id="模板（template）"><a href="#模板（template）" class="headerlink" title="模板（template）"></a>模板（template）</h2><ul><li><p>泛型，是一种将类型参数化以达到代码复用的技术，很多语言中都有，例如Java,Swift等，C++中使用模板来实现泛型</p></li><li><p>模板的使用格式如下</p><ul><li><code>template &lt;typename\class T&gt;</code></li><li><code>typename和class是等价的</code></li></ul></li><li><p>模板没有被使用时，是不会被实例化出来的</p></li><li><p>模板的声明和实现如果分离到.h和.cpp中，会导致链接错误</p></li><li><p>一般将模板的声明和实现统一放到一个.hpp文件中</p></li></ul><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>格式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者和下面是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 形参名，<span class="keyword">typename</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们有2个函数，分别计算int 类型和 double类型的加法运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的每个函数只能实现一种数据类型的运算，所以我们用模板就可以用一个函数来表示</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="literal">T</span>&gt;</span><br><span class="line"><span class="literal">T</span> add(<span class="literal">T</span> a, <span class="literal">T</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">int</span> c = add&lt;<span class="built_in">int</span>&gt;(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以把类型去掉，这样调用函数的时候，会隐式转换</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">int</span> c = add(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多参数模板"><a href="#多参数模板" class="headerlink" title="多参数模板"></a>多参数模板</h2><ul><li>有时候我们的可以多参数，并且是不同类型的</li></ul><p>例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>,typename <span class="built_in">T2</span>&gt;</span><br><span class="line"><span class="built_in">T2</span> <span class="keyword">add(T1 </span>a, <span class="built_in">T2</span> <span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>但是一般来说，为了避免生成不必要的中间变量，以及为了代码安全性，上面代码可以改成如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>,typename <span class="built_in">T2</span>&gt;</span><br><span class="line"><span class="built_in">T2</span> <span class="keyword">add(const </span><span class="built_in">T1</span> &amp;a,const <span class="built_in">T2</span> &amp;<span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>不仅仅有函数模板，而且还有类模板<br>例如，我们自定义一个数组类，可以接收各种类型的数据</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;, <span class="keyword">const</span> Array&lt;Item&gt; &amp;);</span><br><span class="line"><span class="comment">// 用于指向首元素</span></span><br><span class="line">Item *m_data;</span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">int</span> m_size;</span><br><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">int</span> m_capacity;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Array(<span class="keyword">int</span> capacity = <span class="number">0</span>);</span><br><span class="line">~Array();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Item value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Item value)</span></span>;</span><br><span class="line"><span class="function">Item <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">Item <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Array&lt;Item&gt;::Array(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">m_capacity = (capacity &gt; <span class="number">0</span>) ? capacity : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请堆空间</span></span><br><span class="line">m_data = <span class="keyword">new</span> Item[m_capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Array&lt;Item&gt;::~Array() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_data == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::checkIndex(<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= m_size) &#123;</span><br><span class="line"><span class="comment">// 报错：抛异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"数组下标越界"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::add(Item value) &#123;</span><br><span class="line"><span class="keyword">if</span> (m_size == m_capacity) &#123;</span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.申请一块更大的新空间</span></span><br><span class="line"><span class="comment">2.将旧空间的数据拷贝到新空间</span></span><br><span class="line"><span class="comment">3.释放旧空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只做简单的打印</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"空间不够"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_data[m_size++] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::<span class="built_in">remove</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;Item&gt;::insert(<span class="keyword">int</span> index, Item value) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Item Array&lt;Item&gt;::<span class="built_in">get</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">int</span> Array&lt;Item&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">Item Array&lt;Item&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;<span class="built_in">cout</span>, <span class="keyword">const</span> Array&lt;Item&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.m_size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.m_data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候</p><p>定义坐标类Point</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">friend ostream &amp;operator&lt;&lt;(ostream &amp;, const Point &amp;);</span><br><span class="line"><span class="built_in">int</span> m_x;</span><br><span class="line"><span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line"><span class="constructor">Point(<span class="params">int</span> <span class="params">x</span> = 0, <span class="params">int</span> <span class="params">y</span> = 0)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个数组里面可以存放Point类型的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">Point</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">get</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>也可以存放int类型数据</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>&lt;<span class="type">int</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h2 id="类模板中的友元函数"><a href="#类模板中的友元函数" class="headerlink" title="类模板中的友元函数"></a>类模板中的友元函数</h2><p>上的代码中已经包含了友元函数，是运算符号<code>&lt;&gt;</code>重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;, <span class="keyword">const</span> Array&lt;Item&gt; &amp;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream &amp;<span class="built_in">cout</span>, <span class="keyword">const</span> Array&lt;Item&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.m_size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.m_data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下使用，就可以按照我们重载的方式来打印array的数值了。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line"><span class="keyword">Array</span>&lt;<span class="type">Point</span>&gt; <span class="keyword">array</span>;</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">add</span>(<span class="type">Point</span>(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="keyword">array</span>.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">array</span>.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="keyword">array</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之模板.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;模板（template）&quot;&gt;&lt;a href=&quot;#模板（template）&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之内部类和局部类</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB.html/</id>
    <published>2019-12-19T21:32:24.000Z</published>
    <updated>2020-03-07T12:40:04.387Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之内部类和局部类.html/">个人博客</a></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>如果将类A定义在类C的内部，那么类A就是一个内部类（嵌套类）</li><li>内部类的特点<ul><li>支持public、protected、private权限</li><li>成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</li><li>成员函数可以直接不带类名、对象名访问其外部类的static成员</li><li>不会影响外部类的内存布局</li><li>可以在外部类内部声明，在外部类外面进行定义</li></ul></li></ul><p>如下的<code>Car</code>类就是<code>Person</code>类的内部类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">int</span> m_price;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><ul><li>在一个函数内部定义的类，称为局部类</li><li>局部类的特点<ul><li>作用域仅限于所在的函数内部</li><li>其所有的成员必须定义在类内部，不允许定义static成员变量</li><li>成员函数不能直接访问函数的局部变量（static变量除外）</li></ul></li></ul><p>如下<code>Car</code>类就属于局部类</p><pre><code>void test() {    static int age = 10;    // 局部类    class Car {    public:        void run() {            age = 20;        }    };    Car car;    car.run();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之内部类和局部类.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之友元函数、友元类</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%8B%E5%85%83%E7%B1%BB.html/</id>
    <published>2019-12-12T21:32:24.000Z</published>
    <updated>2020-03-07T12:14:33.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之友元函数、友元类.html/">个人博客</a></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>友元包括友元函数和友元类</li><li>如果将函数A（非成员函数）声明为类C的友元函数，那么函数A就能直接访问类C对象的所有成员</li><li>如果将类A声明为类C的友元类，那么类A的所有成员函数都能直接访问类C对象的所有成员</li><li>友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能</li></ul><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>如下代码：类Point。x和y坐标，成员变量是私有的，获取值通过get函数获取</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_x;</span><br><span class="line">    <span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">X()</span> &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Y()</span> &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="constructor">Point(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">    void display<span class="literal">()</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point add(Point p1, Point p2) &#123;</span><br><span class="line">    return <span class="constructor">Point(<span class="params">p1</span>.<span class="params">getX</span>()</span> + p2.get<span class="constructor">X()</span>, p1.get<span class="constructor">Y()</span> + p2.get<span class="constructor">Y()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义2个point，然后我们想把这两个point相加。就如下所示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    Point p1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    Point p2(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    Point p3 = add(p1, p2);</span><br><span class="line">    p3.display();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能达到要求，但是问题是，调用add函数时候，每次获取x和y的值，都要通过<code>getX()</code>或者<code>getY()</code>来取值。因为<code>m_x</code>是私有成员，使用<code>p1. m_x</code>是会报错的。</li><li>有什么办法能直接<code>p1. m_x</code>就可以访问么。同时<code>m_x</code>依然是私有成员</li></ul><h3 id="那就通过友元函数来实现"><a href="#那就通过友元函数来实现" class="headerlink" title="那就通过友元函数来实现"></a>那就通过友元函数来实现</h3><p>上的代码改成</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">     friend Point add(Point, Point);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_x;</span><br><span class="line">    <span class="built_in">int</span> m_y;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">X()</span> &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Y()</span> &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="constructor">Point(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> :m<span class="constructor">_x(<span class="params">x</span>)</span>, m<span class="constructor">_y(<span class="params">y</span>)</span> &#123;&#125;</span><br><span class="line">    void display<span class="literal">()</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point add(Point p1, Point p2) &#123;</span><br><span class="line">    return <span class="constructor">Point(<span class="params">p1</span>.<span class="params">m_x</span> + <span class="params">p2</span>.<span class="params">m_x</span>, <span class="params">p1</span>.<span class="params">m_y</span> + <span class="params">p2</span>.<span class="params">m_y</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说把<code>friend Point add(Point, Point)</code>放在<code>class Point</code>中,这样说明这个函数是朋友了嘛，既然是朋友了，那可以直接访问私有成员变量。当然了其他函数想直接访问私有成员变量依然是不可以的。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>既然和函数可以做朋友，那和类呢？答案是可以的。如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_x;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_y;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point <span class="title">add</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">        p1.m_x = <span class="number">10</span>;</span><br><span class="line">        p1.m_x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>class Point</code> 中声明了友元类<code>friend class Math;</code>那么在类<code>Math</code>中也是可以直接访问类<code>Point</code>中的私有成员变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之友元函数、友元类.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;友元&quot;&gt;&lt;a href=&quot;#友元&quot; class=&quot;headerlink&quot; title=&quot;友元&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之static、const</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8Bstatic%E3%80%81const.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8Bstatic%E3%80%81const.html/</id>
    <published>2019-12-09T21:32:24.000Z</published>
    <updated>2020-03-07T11:52:40.488Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之static、const.html/">个人博客</a></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li><p>静态成员的提出是为了解决数据共享的问题。实现共享有许多方法，如：设置全局性的变量或对象是一种方法。但是，全局变量或对象是有局限性的。</p></li><li><p>静态成员：被static修饰的成员变量\函数</p><ul><li>可以通过对象（对象.静态成员）、对象指针（对象指针-&gt;静态成员）、类访问（类名::静态成员）</li></ul></li><li><p>静态成员变量</p><ul><li>存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存</li><li>对比全局变量，它可以设定访问权限（public、protected、private），达到局部共享的目的</li><li>必须初始化，必须在类外面初始化，初始化时不能带static，如果类的声明和实现分离（在实现.cpp中初始化）</li></ul></li><li><p>静态成员函数</p><ul><li>内部不能使用this指针（this指针只能用在非静态成员函数内部）</li><li>不能是虚函数（虚函数只能是非静态成员函数）</li><li>内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数</li><li>非静态成员函数内部可以访问静态成员变量\函数</li><li>构造函数、析构函数不能是静态</li><li>当声明和实现分离时，实现部分不能带static</li></ul></li></ul><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>在C++中，可以利用static关键字在全局只有一份的特性，来写代理</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rocket</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Rocket *ms_rocket;</span><br><span class="line">    Rocket() &#123;&#125;</span><br><span class="line">    Rocket(<span class="keyword">const</span> Rocket &amp;rocket) &#123;&#125;</span><br><span class="line">    ~Rocket() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Rocket &amp;rocket) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Rocket *sharedRocket() &#123;</span><br><span class="line">        <span class="comment">// 这里要考虑多线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (ms_rocket == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ms_rocket = <span class="keyword">new</span> Rocket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ms_rocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里要考虑多线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (ms_rocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ms_rocket;</span><br><span class="line">            ms_rocket = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><ul><li>const成员：被const修饰的成员变量、非静态成员函数</li><li>const成员变量<ul><li>必须初始化（类内部初始化），可以在声明的时候直接初始化赋值</li><li>非static的const成员变量还可以在初始化列表中初始化</li></ul></li><li>const成员函数（非静态）<ul><li>const关键字写在参数列表后面，函数的声明和实现都必须带const</li><li>内部不能修改非static成员变量</li><li>内部只能调用const成员函数、static成员函数</li><li>非const成员函数可以调用const成员函数</li><li>const成员函数和非const成员函数构成重载</li><li>非const对象（指针）优先调用非const成员函数</li><li>const对象（指针）只能调用const成员函数、static成员函数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之static、const.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之虚函数、虚表</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E8%A1%A8.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E8%A1%A8.html/</id>
    <published>2019-12-07T21:32:24.000Z</published>
    <updated>2020-03-07T11:26:22.901Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之虚函数、虚表.html/">个人博客</a></p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul><li>C++中的多态通过虚函数（virtual function）来实现<ul><li>虚函数：被virtual修饰的成员函数</li><li>只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（也就是说子类中可以省略virtual关键字）</li></ul></li></ul><h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt; <span class="string">"Student::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们用<code>Person</code>指针指向<code>Student</code>对象，然后真正输出的是<code>Person::run()</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person *stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu-&gt;<span class="built_in">run</span>(); <span class="comment">//输出 Person::run()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 </p><blockquote><p>Person::run()</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>那是因为对于编译器来说，编译代码的时候，发现<code>stu</code>指针是Person类型，那么调用的时候，直接调用了<code>Person::run()</code>。有没有办法调用<code>Student::run()</code>呢？答案是有的，就是用<code>virtual</code>修饰</li><li>用<code>virtual</code>修饰的函数，是虚函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改成如上代码之后，输出结果为</p><blockquote><p>Student::run()</p></blockquote><h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2><ul><li>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表</li></ul><p>对于上面的例子中，<code>Student</code>对象的前4个字节存放的是指向虚表的地址<br>当我们调用的时候，</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *stu = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">stu-&gt;<span class="keyword">run</span>();</span><br></pre></td></tr></table></figure><p>会首先把虚表地址取出来，然后去虚表中调用<code>Student::run()</code></p><p><strong>所有的Student对象（不管在全局区、栈、堆）共用同一份虚表</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1000010e5</span> &lt;+<span class="number">53</span>&gt;: movq   <span class="number">-0x18</span>(%rbp), %rax</span><br><span class="line"><span class="number">0x1000010e9</span> &lt;+<span class="number">57</span>&gt;: movq   %rax, <span class="number">-0x10</span>(%rbp)</span><br><span class="line"><span class="number">0x1000010ed</span> &lt;+<span class="number">61</span>&gt;: movq   <span class="number">-0x10</span>(%rbp), %rax</span><br><span class="line"><span class="number">0x1000010f1</span> &lt;+<span class="number">65</span>&gt;: movq   (%rax), %rdx</span><br><span class="line"><span class="number">0x1000010f4</span> &lt;+<span class="number">68</span>&gt;: movq   %rax, %rdi</span><br><span class="line"><span class="number">0x1000010f7</span> &lt;+<span class="number">71</span>&gt;: callq  *(%rdx) <span class="comment">//rdx里面存放虚表地址</span></span><br></pre></td></tr></table></figure><p> 跟踪汇编代码调用如下的<code>Student::run:</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> C++test01`Student::<span class="built_in">run</span>:</span><br><span class="line">-&gt;  <span class="number">0x100001190</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001191</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001194</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001198</span> &lt;+<span class="number">8</span>&gt;:  movq   <span class="number">0xe61</span>(%rip), %rax         ; (<span class="keyword">void</span> *)<span class="number">0x00007fff97678760</span>: <span class="built_in">std</span>::__1::<span class="built_in">cout</span></span><br><span class="line">    <span class="number">0x10000119f</span> &lt;+<span class="number">15</span>&gt;: movq   %rdi, <span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x1000011a3</span> &lt;+<span class="number">19</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x1000011a6</span> &lt;+<span class="number">22</span>&gt;: leaq   <span class="number">0xda6</span>(%rip), %rsi         ; <span class="string">"Student::run()"</span></span><br><span class="line">    <span class="number">0x1000011ad</span> &lt;+<span class="number">29</span>&gt;: callq  <span class="number">0x100001de2</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;&amp; <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;(<span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt; &gt;&amp;, <span class="keyword">char</span> <span class="keyword">const</span>*)</span><br></pre></td></tr></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul><li>纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范</li><li>抽象类（Abstract Class） <ul><li>含有纯虚函数的类，不可以实例化（不可以创建对象）</li><li>抽象类也可以包含非纯虚函数、成员变量</li><li>如果父类是抽象类，子类没有完全重写纯虚函数，那么这个子类依然是抽象类</li></ul></li></ul><p>例如下面的<code>Person</code>类就是一个含有纯虚函数的类，可以用来定义接口规范</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line">    virtual <span class="built_in">void</span> run()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</li><li>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。</li><li>所以类纯虚函数的声明就是在告诉子类的设计者，”你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之虚函数、虚表.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之继承</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%BB%A7%E6%89%BF.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%BB%A7%E6%89%BF.html/</id>
    <published>2019-12-06T21:32:24.000Z</published>
    <updated>2020-03-07T12:17:27.124Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之继承.html/">个人博客</a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>继承，可以让子类拥有父类的所有成员（变量\函数）</li></ul><h3 id="默认私有继承"><a href="#默认私有继承" class="headerlink" title="默认私有继承"></a>默认私有继承</h3><p>例如下面的代码中，类Cat继承类Animal</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Animal::eat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">"Cat::run()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下调用的时候，发现设置父类的成员变量，访问父类的函数，会报错。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">Cat</span> <span class="keyword">cat</span>;</span><br><span class="line">    <span class="keyword">cat</span>.age =3; <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">cat</span>.height = 4;</span><br><span class="line">    <span class="keyword">cat</span>.<span class="keyword">run</span>();</span><br><span class="line">    <span class="keyword">cat</span>.eat(); <span class="comment">//编译报错</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改为public继承"><a href="#修改为public继承" class="headerlink" title="修改为public继承"></a>修改为<code>public</code>继承</h3><p>那是因为C++中默认是私有继承。如果子类想访问父类的函数等，需要public继承，改成如下就可以了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">"Cat::run()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>c++中没有类似Java中的java.lang.Object 或者ObjectC中的NSObject的基类</strong></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul><li>父类的成员变量在前，子类的成员变量在后</li></ul><p>上面的代码反汇编</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x100001160</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100001161</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100001164</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001168</span> &lt;+<span class="number">8</span>&gt;:  movl   $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x10000116f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x3</span>, <span class="number">-0x10</span>(%rbp) <span class="comment">//cat.age =3</span></span><br><span class="line">    <span class="number">0x100001176</span> &lt;+<span class="number">22</span>&gt;: movl   $<span class="number">0x4</span>, <span class="number">-0xc</span>(%rbp)<span class="comment">//cat.height =4</span></span><br><span class="line">-&gt;  <span class="number">0x10000117d</span> &lt;+<span class="number">29</span>&gt;: leaq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x100001181</span> &lt;+<span class="number">33</span>&gt;: callq  <span class="number">0x1000011a0</span>               ; Cat::run at Main.cpp:<span class="number">42</span></span><br><span class="line">    <span class="number">0x100001186</span> &lt;+<span class="number">38</span>&gt;: leaq   <span class="number">-0x10</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x10000118a</span> &lt;+<span class="number">42</span>&gt;: callq  <span class="number">0x1000011e0</span>               ; Animal::eat at Main.cpp:<span class="number">33</span></span><br><span class="line">    <span class="number">0x10000118f</span> &lt;+<span class="number">47</span>&gt;: xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100001191</span> &lt;+<span class="number">49</span>&gt;: addq   $<span class="number">0x10</span>, %rsp</span><br><span class="line">    <span class="number">0x100001195</span> &lt;+<span class="number">53</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100001196</span> &lt;+<span class="number">54</span>&gt;: retq</span><br></pre></td></tr></table></figure><p>从上面的汇编可以看到<code>age</code>在<code>height</code>的地址前面，而且是连续的内存。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ul><li>C++允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）</li></ul><p>如下所示：<code>GoodStudent</code>同时继承<code>Person</code>和<code>Student</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::play()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodStudent</span>:</span><span class="keyword">public</span> Person,<span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"GoodStudent::study()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GoodStudent stu;</span><br><span class="line">    stu.age = <span class="number">1</span>;</span><br><span class="line">    stu.<span class="built_in">height</span> = <span class="number">2</span>;</span><br><span class="line">    stu.score = <span class="number">3</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应汇编如下，可知是把父类的成员变量放在了子类中，并且内存是连续的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100000f90</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f91</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f94</span> &lt;+<span class="number">4</span>&gt;:  xorl   %eax, %eax</span><br><span class="line">    <span class="number">0x100000f96</span> &lt;+<span class="number">6</span>&gt;:  movl   $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f9d</span> &lt;+<span class="number">13</span>&gt;: movl   $<span class="number">0x1</span>, <span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000fa4</span> &lt;+<span class="number">20</span>&gt;: movl   $<span class="number">0x2</span>, <span class="number">-0xc</span>(%rbp)</span><br><span class="line">-&gt;  <span class="number">0x100000fab</span> &lt;+<span class="number">27</span>&gt;: movl   $<span class="number">0x3</span>, <span class="number">-0x8</span>(%rbp)</span><br></pre></td></tr></table></figure><h2 id="多个父类同样的函数"><a href="#多个父类同样的函数" class="headerlink" title="多个父类同样的函数"></a>多个父类同样的函数</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::play()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student::run()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类调用的时候需要区分命名空间</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu.Person::<span class="built_in">run</span>(); <span class="comment">//调用Person的run()</span></span><br><span class="line">stu.Student::<span class="built_in">run</span>();<span class="comment">//调用Student的run()</span></span><br></pre></td></tr></table></figure><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><ul><li><p>如果存在类A，同时类B和类C都继承A，有类D继承B和C。则称为菱形继承</p></li><li><p>一般在开发中，不会使用菱形继承。</p><ul><li>最底下子类从基类继承的成员变量冗余、重复</li><li>最底下子类无法访问基类的成员，有二义性</li></ul></li></ul><p>例如如下的代码中，就是菱形继承的例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student:<span class="symbol">public</span></span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Work:<span class="symbol">public</span></span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">GoodStudent:<span class="symbol">public</span></span> <span class="symbol">Student,<span class="symbol">public</span></span> <span class="symbol">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在X86架构下，一个GoodStudent对象占用内存20字节，是因为，Student和Work都从Person继承了age，那么GoodStudent中就有2个age了。同时加上score,height, salary就是5个成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GoodStudent stu;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(stu) &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出20</span></span><br></pre></td></tr></table></figure><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>为了解决菱形继承的问题，我们可以使用虚继承。</p><p>如下代码 Person类被称为虚基类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Student:<span class="symbol">virtual</span></span> <span class="symbol">public</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Work:<span class="symbol">virtual</span></span> <span class="symbol">public</span> <span class="symbol">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">GoodStudent:<span class="symbol">public</span></span> <span class="symbol">Student,<span class="symbol">public</span></span> <span class="symbol">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个GoodStudent对象里面只有一个age成员变量。当然这样做增加了虚函数表。这里不做展开。</p><h2 id="成员访问权限"><a href="#成员访问权限" class="headerlink" title="成员访问权限"></a>成员访问权限</h2><ul><li>成员访问权限、继承方式有3种 <ul><li>public：公共的，任何地方都可以访问（struct默认）</li><li>protected：子类内部、当前类内部可以访问</li><li>private：私有的，只有当前类内部可以访问（class默认）<ul><li>子类内部访问父类成员的权限，是以下2项中权限最小的那个</li></ul></li><li>成员本身的访问权限</li><li>上一级父类的继承方式<ul><li>开发中用的最多的继承方式是public，这样能保留父类原来的成员访问权限</li><li>访问权限不影响对象的内存布局</li></ul></li></ul></li></ul><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><ul><li>一种便捷的初始化成员变量的方式</li><li>只能用在构造函数中</li><li>初始化顺序只跟成员变量的声明顺序有关</li></ul><p>下面两种写法是等价的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">        this-&gt;m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>)</span>: m<span class="constructor">_age(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化列表与默认参数配合使用"><a href="#初始化列表与默认参数配合使用" class="headerlink" title="初始化列表与默认参数配合使用"></a>初始化列表与默认参数配合使用</h2><p>例如下面的代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="built_in">int</span> m_height;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span> = 0, <span class="params">int</span> <span class="params">height</span> =0)</span>:m<span class="constructor">_age(<span class="params">age</span>)</span>,m<span class="constructor">_height(<span class="params">height</span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用的时候如下三种都可以</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">Person person2(<span class="number">18</span>);</span><br><span class="line">Person person3(<span class="number">18</span>,<span class="number">188</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之继承.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之封装、构造函数、析构函数</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.html/</id>
    <published>2019-12-05T21:32:24.000Z</published>
    <updated>2020-03-07T08:13:41.263Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之封装、构造函数、析构函数.html/">个人博客</a></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>成员变量私有化，提供公共的getter和setter给外界去访问成员变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.setAge(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><ul><li><p>在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存</p></li><li><p>堆空间的申请\释放</p><ul><li><code>malloc</code> \ <code>free</code></li><li><code>new</code> \ <code>delete</code></li><li><code>new</code> [] \ <code>delete []</code></li></ul></li><li><p>注意</p><ul><li>申请堆空间成功后，会返回那一段内存空间的地址</li><li>申请和释放必须是1对1的关系，不然可能会存在内存泄露</li></ul></li><li><p>现在的很多高级编程语言不需要开发人员去管理内存（比如Java），屏蔽了很多内存细节，利弊同时存在</p><ul><li>利：提高开发效率，避免内存使用不当或泄露</li><li>弊：不利于开发人员了解本质，永远停留在API调用和表层语法糖，对性能优化无从下手</li></ul></li></ul><p>例如开盘int类型的空间，使用完之后销毁</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *p = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>));</span><br><span class="line">   *p = <span class="number">10</span>;</span><br><span class="line">   free(p);</span><br><span class="line">  </span><br><span class="line">   <span class="built_in">int</span> *p2 = new <span class="built_in">int</span>;</span><br><span class="line">   *p2 = <span class="number">20</span>;</span><br><span class="line">   delete p2;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> *p3 = new <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">   *p = <span class="number">10</span>;</span><br><span class="line">   *(p+<span class="number">1</span>) = <span class="number">20</span>;</span><br><span class="line">   *(p+<span class="number">2</span>) = <span class="number">30</span>;</span><br><span class="line">   delete [] (p3);</span><br></pre></td></tr></table></figure><h2 id="堆空间的初始化"><a href="#堆空间的初始化" class="headerlink" title="堆空间的初始化"></a>堆空间的初始化</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a><code>memset</code></h3><p><code>memset</code>函数是将较大的数据结构（比如对象、数组等）内存清零的比较快的方法</p><p>如下所示</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">Person</span> <span class="keyword">person</span>;</span><br><span class="line"> <span class="keyword">person</span>.age = 10;</span><br><span class="line"> <span class="keyword">person</span>.height = 199;</span><br><span class="line"> //从<span class="keyword">person</span>的地址开始,每个字节都赋值为0</span><br><span class="line">memset(&amp;<span class="keyword">person</span>, 0, sizeof(<span class="keyword">person</span>));</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//*p1 未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//将 *p2 的每一个字节都初始化为0</span></span><br></pre></td></tr></table></figure><p>如下几种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;           <span class="comment">//未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>();         <span class="comment">//被初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);        <span class="comment">//被初始化为5</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];        <span class="comment">//数组元素未被初始化</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]();      <span class="comment">//3个数组元素都被初始化0</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;&#125;;      <span class="comment">//3个数组元素都被初始化0</span></span><br><span class="line"><span class="keyword">int</span> *p7 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">5</span>&#125;;     <span class="comment">//数组首元素被初始化为5,其他元素被初始化为0</span></span><br></pre></td></tr></table></figure><h2 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h2><ul><li>构造函数（也叫构造器），在对象创建的时候自动调用，一般用于完成对象的初始化工作</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>函数名与类同名，无返回值（void都不能写），可以有参数，可以重载，可以有多个构造函数</li><li>一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>通过malloc分配的对象不会调用构造函数</li><li>一个广为流传的、很多教程\书籍都推崇的错误结论： <ul><li>默认情况下，编译器会为每一个类生成空的无参的构造函数</li><li>正确理解：在某些特定的情况下，编译器才会为类生成空的无参的构造函数</li></ul></li></ul><p>比如我们自己写2个构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person(int age))"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在不同的空间调用的时候，如下区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局区</span></span><br><span class="line">Person p1;      <span class="comment">//调用Person()</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">()</span></span>;    <span class="comment">//这是一个函数，函数名是p2,返回值类型是Person，无参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">18</span>)</span></span>;  <span class="comment">//调用 Person(int)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//栈空间</span></span><br><span class="line">    Person p4;      <span class="comment">//调用Person()</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">()</span></span>;    <span class="comment">//这是一个函数，函数名是p5,返回值类型是Person，无参</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(<span class="number">18</span>)</span></span>;  <span class="comment">//调用 Person(int)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//堆空间</span></span><br><span class="line">    Person *p7  = <span class="keyword">new</span> Person;      <span class="comment">//调用Person()</span></span><br><span class="line">    Person *p8  = <span class="keyword">new</span> Person();    <span class="comment">//调用Person()</span></span><br><span class="line">    Person *p9  = <span class="keyword">new</span> Person(<span class="number">20</span>);  <span class="comment">//调用 Person(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数的互相调用"><a href="#构造函数的互相调用" class="headerlink" title="构造函数的互相调用"></a>构造函数的互相调用</h2><p>下面代码中有2个构造函数，<code>Person()</code>是可以调用<code>Person(int age, int height):m_age(age),m_height(height)</code>的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> m_age;</span><br><span class="line">    <span class="built_in">int</span> m_height;</span><br><span class="line">    <span class="constructor">Person()</span>:<span class="constructor">Person(10,20)</span>&#123;&#125;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>, <span class="params">int</span> <span class="params">height</span>)</span>:m<span class="constructor">_age(<span class="params">age</span>)</span>,m<span class="constructor">_height(<span class="params">height</span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h2><ul><li>子类的构造函数默认会调用父类的无参构造函数</li><li>如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</li><li>如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>析构函数（也叫析构器），在对象销毁的时候自动调用，一般用于完成对象的清理工作</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>函数名以~开头，与类同名，无返回值（void都不能写），无参，不可以重载，有且只有一个析构函数</li></ul><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>通过malloc分配的对象free的时候不会调用析构函数</li><li>构造函数、析构函数要声明为public，才能被外界正常使用</li></ul><h3 id="例如下面的代码"><a href="#例如下面的代码" class="headerlink" title="例如下面的代码"></a>例如下面的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Cat()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Cat()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Cat()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Cat *cat;</span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Person person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">()</span></span></span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure><p>当person销毁的时候，其持有的cat并没有销毁。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>当person销毁的时候，其指向cat对象的指针销毁了，但是堆空间的cat对象依然存在，就会有内存泄露。所以需要在析构函数里面来释放掉。类似的析构函数在许多其他语言底层也是应用广泛，例如Objective-C的源码中，大量使用析构函数。</li></ul><p>代码改成如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Person()&#123;</span><br><span class="line">       <span class="keyword">delete</span> cat;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">()</span></span></span><br><span class="line">~Cat()</span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure><p>可知，cat对象才真正销毁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之封装、构造函数、析构函数.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之类(class,struct)</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB(class,struct).html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB(class,struct).html/</id>
    <published>2019-11-29T21:32:24.000Z</published>
    <updated>2020-03-06T05:06:33.691Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之类(class,struct).html/">个人博客</a></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p> C++中可以使用struct、class来定义一个类</p><h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><ul><li>struct的默认成员权限是public</li><li>class的默认成员权限是private</li><li>实际开发中，用class表示类比较多</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="操作类"><a href="#操作类" class="headerlink" title="操作类"></a>操作类</h3><ul><li>对类进行操作。我们有两种方式</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> <span class="keyword">person</span>;</span><br><span class="line">//使用对象的点语法</span><br><span class="line"><span class="keyword">person</span>.age = 10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *p = &amp;<span class="keyword">person</span>;</span><br><span class="line">//操作指针访问</span><br><span class="line">p-&gt;age = 20;</span><br></pre></td></tr></table></figure><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.age = <span class="number">10</span>; <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> pushq  <span class="symbol">%rbp</span></span><br><span class="line"> movq   <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line"> xorl   <span class="symbol">%eax</span>, <span class="symbol">%eax</span></span><br><span class="line">-&gt;   movl   $<span class="number">0xa</span>, <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>) <span class="comment">; person.age = 10</span></span><br><span class="line"><span class="comment"> popq   %rbp</span></span><br><span class="line"><span class="comment"> retq</span></span><br></pre></td></tr></table></figure><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.age = <span class="number">10</span>; <span class="comment">//这里打断点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> pushq  <span class="symbol">%rbp</span></span><br><span class="line"> movq   <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line"> xorl   <span class="symbol">%eax</span>, <span class="symbol">%eax</span></span><br><span class="line">-&gt;   movl   $<span class="number">0xa</span>, <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>) <span class="comment">; person.age = 10</span></span><br><span class="line"><span class="comment"> popq   %rbp</span></span><br><span class="line"><span class="comment"> retq</span></span><br></pre></td></tr></table></figure><p>可以看到无论是<code>struct</code>还是<code>class</code>。汇编代码完全一样</p><ul><li>实际开发中，用class表示类比较多</li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this是指向当前对象的指针"><a href="#this是指向当前对象的指针" class="headerlink" title="this是指向当前对象的指针"></a>this是指向当前对象的指针</h3><ul><li>对象在调用成员函数的时候，会自动传入当前对象的内存地址</li></ul><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"age is "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：不能用this.age来访问成员变量。因为this是指针。</strong></p><h3 id="指针访问对象成员的本质"><a href="#指针访问对象成员的本质" class="headerlink" title="指针访问对象成员的本质"></a>指针访问对象成员的本质</h3><p>下面代码最后打印出来的每个成员变量值是多少？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" id = "</span> &lt;&lt; id &lt;&lt; <span class="string">" age = "</span> &lt;&lt; age &lt;&lt; <span class="string">" height = "</span> &lt;&lt; <span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person person;</span><br><span class="line">    person.id = <span class="number">10</span>;</span><br><span class="line">    person.age = <span class="number">20</span>;</span><br><span class="line">    person.<span class="built_in">height</span> = <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Person *p = (Person *)&amp;person.age;</span><br><span class="line">    <span class="comment">//操作指针访问</span></span><br><span class="line">    p-&gt;id = <span class="number">40</span>;</span><br><span class="line">    p-&gt;age= <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    person.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一感觉是</p><blockquote><p>id = 40 age = 50 height = 30</p></blockquote><p>然后用编译器运行起来的结果是</p><blockquote><p>id = 10 age = 40 height = 50</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>因为指针<code>p</code>实际指向的是<code>person.age</code>的地址，但是<code>(Person *)&amp;person.age;</code> 欺骗编译器是指向person。</li><li>64位下<code>person</code>中每个成员变量都是Int类型，占用4个字节。</li><li>当我们修改<code>p-&gt;id = 40;</code>的时候，实际上修改的是<code>age</code>指向的内存空间。</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>打印的时候不用点语法，使用指针呢？如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>display();</span><br></pre></td></tr></table></figure><p>其结果为：其中height 的值是不确定的</p><blockquote><p>id = 40 age = 50 height = 1 </p></blockquote><ul><li>是因为，使用指针访问的时候，传入的this就是偏移了4个字节的内存空间，打印的id实际上是age,打印的age实际上是height,打印的height实际上是其他空间的数据。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之类(class,struct).html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之引用</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%BC%95%E7%94%A8.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%BC%95%E7%94%A8.html/</id>
    <published>2019-11-27T21:32:24.000Z</published>
    <updated>2020-03-07T06:12:40.958Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之引用.html/">个人博客</a></p><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><ul><li>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>引用相当于是变量的别名（基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用）</li><li>对引用做计算，就是对引用所指向的变量做计算</li><li>在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”</li><li>可以利用引用初始化另一个引用，相当于某个变量的多个别名</li><li>不存在【引用的引用、指向引用的指针、引用数组】</li></ul><p>例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line"> <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = age;</span><br><span class="line"> <span class="built_in">ref</span> = <span class="number">20</span>;</span><br><span class="line"> cout &lt;&lt; age &lt;&lt; endl; <span class="comment">//打印结果为 20</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中修改ref也就相当于修改了age。</p><h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><ul><li>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针<ul><li>一个引用占用一个指针的大小</li></ul></li></ul><h3 id="间接证明"><a href="#间接证明" class="headerlink" title="间接证明"></a>间接证明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person size is "</span> &lt;&lt; <span class="keyword">sizeof</span>(person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在X86位架构下，上面的代码输入为 <code>person size is 4</code><br>如果代码改成如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> &amp;ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person size is "</span> &lt;&lt; <span class="keyword">sizeof</span>(person) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在X86架构下，上面的代码输入为 <code>person size is 8</code><br>而我们知道在X86架构下，指针类型占用字节为8。int 类型为占用4个字节。所以引用和指针占用字节数一样。</p><h3 id="汇编证明"><a href="#汇编证明" class="headerlink" title="汇编证明"></a>汇编证明</h3><ul><li>如下使用指针的代码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">   <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">int</span> *p = &amp;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">_main:</span></span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0x3</span></span><br><span class="line"><span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"><span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><ul><li>把指针改成引用的代码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">   <span class="built_in">int</span> age = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol"> _main:</span></span><br><span class="line"><span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0x3</span></span><br><span class="line"><span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"><span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"><span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可发现，引用和指针的汇编代码完全一致。就说明最终转成机器码也是一样的。所以引用的本质就是指针。</p><h2 id="常引用（Const-Reference）"><a href="#常引用（Const-Reference）" class="headerlink" title="常引用（Const Reference）"></a>常引用（Const Reference）</h2><ul><li>引用可以被const修饰，这样就无法通过引用修改数据了，可以称为常引用</li><li>const必须写在&amp;符号的左边，才能算是常引用</li></ul><h3 id="const引用的特点"><a href="#const引用的特点" class="headerlink" title="const引用的特点"></a>const引用的特点</h3><ul><li>可以指向临时数据（常量、表达式、函数返回值等）</li><li>可以指向不同类型的数据</li><li>作为函数参数时（此规则也适用于const指针） <ul><li>可以接受const和非const实参（非const引用，只能接受非const实参）</li><li>可以跟非const引用构成重载</li></ul></li></ul><p><strong>当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量</strong></p><h3 id="常引用指向相同类型的数据"><a href="#常引用指向相同类型的数据" class="headerlink" title="常引用指向相同类型的数据"></a>常引用指向相同类型的数据</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;<span class="built_in">ref</span> = a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ref is "</span> &lt;&lt; <span class="built_in">ref</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面代码输出为12。其对应的汇编如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"> <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"> //<span class="number">10</span>赋值给[<span class="built_in">rbp</span>+var_8] 这个内存空间 也就是 变量a的地址</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">// a的地址赋值给引用ref</span><br><span class="line"> <span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span>//</span><br><span class="line"></span><br><span class="line">//把a的值改为<span class="number">12</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xc</span></span><br><span class="line"> <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h3 id="常引用指向不同类型的数据"><a href="#常引用指向不同类型的数据" class="headerlink" title="常引用指向不同类型的数据"></a>常引用指向不同类型的数据</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> long &amp;<span class="built_in">ref</span> = a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ref is "</span> &lt;&lt; <span class="built_in">ref</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面代码输出为10。其对应的汇编如下，改变了a的值，并不能改变ref的值</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">             _main:</span></span><br><span class="line"> <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"> <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">//<span class="number">10</span>赋值给[<span class="built_in">rbp</span>+var_8] 这个内存空间 也就是 变量a的地址</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">//增加一个中间变量地址为[<span class="built_in">rbp</span>+var_18] 作为引用ref的地址</span><br><span class="line"> <span class="keyword">movsxd</span>     <span class="built_in">rcx</span>, <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_18], <span class="built_in">rcx</span></span><br><span class="line"> <span class="keyword">lea</span>        <span class="built_in">rcx</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_18]</span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rcx</span></span><br><span class="line"></span><br><span class="line">//把a的值改为<span class="number">12</span></span><br><span class="line"> <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_8], <span class="number">0xc</span></span><br><span class="line"> <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之引用.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;C-引用&quot;&gt;&lt;a href=&quot;#C-引用&quot; class=&quot;headerlink&quot; title=&quot;C++ 引用&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之内联函数</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0.html/</id>
    <published>2019-11-25T21:32:24.000Z</published>
    <updated>2020-03-04T02:29:00.221Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之内联函数.html/">个人博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p></blockquote><blockquote><p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>使用inline修饰函数的声明或者实现，可以使其变成内联函数</li><li>建议声明和实现都增加inline修饰</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过内敛之后就相当于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>编译器会将函数调用直接展开为函数体代码</li><li>可以减少函数调用的开销</li><li>会增大代码体积</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>尽量不要内联超过10行代码的函数</li><li>有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数</li></ul><p>例如下面的代码就算加了inline 也不会被编译器内敛的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    test3(a--);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test3(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inline只是建议"><a href="#inline只是建议" class="headerlink" title="inline只是建议"></a><code>inline</code>只是建议</h2><p>inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p><h2 id="慎用-inline"><a href="#慎用-inline" class="headerlink" title="慎用 inline"></a>慎用 inline</h2><ul><li>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？ </li><li>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 </li><li>如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li></ul><p>以下情况不宜使用内联： </p><ul><li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 </li><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如”偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</li></ul><h2 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h2><ul><li>内联函数和宏，都可以减少函数调用的开销</li><li>对比宏，内联函数多了语法检测和函数特性</li><li>宏使用不当，会导致和我们想法不一致的情况</li></ul><p>例如下面的代码,如果是宏定义，就相当于b = (a++ + a++);结果和预期不符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) (x + x)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> b = sum(a++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。 </li><li>最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强性能，就避免使用它！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之内联函数.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之C和C++混编</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8BC%E5%92%8CC++%E6%B7%B7%E7%BC%96.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8BC%E5%92%8CC++%E6%B7%B7%E7%BC%96.html/</id>
    <published>2019-11-23T21:32:24.000Z</published>
    <updated>2020-03-03T07:46:39.782Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之C和C++混编.html/">个人博客</a></p><h2 id="extern-quot-C-quot"><a href="#extern-quot-C-quot" class="headerlink" title="extern &quot;C&quot;"></a><code>extern &quot;C&quot;</code></h2><blockquote><p><code>extern &quot;C&quot;</code>的主要作用就是为了能够正确实现<code>C++</code>代码调用其他C语言代码。加上<code>extern &quot;C&quot;</code>后，会指示编译器这部分代码按<code>C</code>语言（而不是<code>C++</code>）的方式进行编译。由于<code>C++</code>支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p></blockquote><blockquote><p>这个功能十分有用处，因为在<code>C++</code>出现以前，很多代码都是<code>C</code>语言写的，而且很底层的库也是<code>C</code>语言写的，为了更好的支持原来的<code>C</code>代码和已经写好的<code>C</code>语言库，需要在<code>C++</code>中尽可能的支持<code>C</code>，而<code>extern &quot;C&quot;</code>就是其中的一个策略。</p></blockquote><h3 id="extern-quot-C-quot-可以修饰单个函数，也可以修饰多个函数。"><a href="#extern-quot-C-quot-可以修饰单个函数，也可以修饰多个函数。" class="headerlink" title="extern &quot;C&quot; 可以修饰单个函数，也可以修饰多个函数。"></a><code>extern &quot;C&quot;</code> 可以修饰单个函数，也可以修饰多个函数。</h3><p>例如下面的三个函数都会用 C语音的方式编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明必须修饰，实现可修饰可不修饰"><a href="#声明必须修饰，实现可修饰可不修饰" class="headerlink" title="声明必须修饰，实现可修饰可不修饰"></a>声明必须修饰，实现可修饰可不修饰</h3><ul><li><p>如果函数同时有声明和实现，要让函数声明被extern “C”修饰，函数实现可以不修饰</p></li><li><p>函数的声明都被extern “C”修饰是可以编译通过的</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以编译通过</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明被extern “C”修饰，实现没有被extern “C”修饰，是可以编译通过的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以编译通过</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明没有被extern “C”修饰，实现被extern “C”修饰，不能编译通过</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能编译通过</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cplusplus"><a href="#cplusplus" class="headerlink" title="__cplusplus"></a><code>__cplusplus</code></h2><p>有时候我们的函数，不仅要在C语言中调用，还要再C++中调用。怎么做呢？</p><p>如果我们加了<code>extern &quot;C&quot;</code> 那么只能是C语言的环境编译，C++环境编译就会有问题了。</p><p>如果我们不加<code>extern &quot;C&quot;</code> 那么只能是C++语言的环境编译，C环境编译就会有问题了。</p><p>如果能够判断是C语言环境还是C++环境，这样在C++语言的环境下按照C++编译方式，在C语言的环境下按照C编译方式，岂不是都可以了。</p><p> <code>__cplusplus</code>就可以达成这样的效果。</p><p> 例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就能做到C++语言的环境下按照C++编译方式，在C语言的环境下按照C编译方式。</p><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a><code>ifndef</code></h2><p>我们知道，当引用其他文件的时候，我们要用到 <code>#include</code> 例如</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br></pre></td></tr></table></figure><p>如果我们不小心写了很多次</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"iostream"</span></span></span><br></pre></td></tr></table></figure><p>那就相当于把引用的文件的内容拷贝过来很多次，编译器编译的时候，要执行多次，浪费性能。这时候我们只需要在被引用文件里面加上如下代码即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_IOSTREAM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIBCPP_IOSTREAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。很多代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就算引用多次，也没关系。因为第二次引用的时候，判断引用过了，直接跳过。其中<code>_LIBCPP_IOSTREAM</code>这个为了避免重复，一般采用和文件同名的大写字母来命名。</p><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h2><ul><li>我们经常使用#ifndef、#define、#endif来防止头文件的内容被重复包含</li><li>#pragma once可以防止整个文件的内容被重复包含</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>受<code>C\C++</code>标准的支持，不受编译器的任何限制</li><li>有些编译器不支持<code>#pragma once</code>（较老编译器不支持，如<code>GCC 3.4</code>版本之前），兼容性不够好</li><li><code>#ifndef</code>、<code>#define</code>、<code>#endif</code>可以针对一个文件中的部分代码，而<code>#pragma once</code>只能针对整个文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之C和C++混编.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;extern-quot-C-quot&quot;&gt;&lt;a href=&quot;#extern-quot-C-quot&quot; cl
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++语法之函数重载和默认参数</title>
    <link href="https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html/"/>
    <id>https://ityongzhen.github.io/C++%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html/</id>
    <published>2019-11-20T21:32:24.000Z</published>
    <updated>2020-03-02T11:52:09.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://ityongzhen.github.io/C++语法之函数重载.html/">个人博客</a></p><h2 id="函数重载（Overload）"><a href="#函数重载（Overload）" class="headerlink" title="函数重载（Overload）"></a>函数重载（Overload）</h2><p><strong>C语言中没有函数重载</strong></p><p><strong>C++语言中有函数重载</strong></p><h3 id="函数名相同，参数个数不同、参数类型不同、参数顺序不同"><a href="#函数名相同，参数个数不同、参数类型不同、参数顺序不同" class="headerlink" title="函数名相同，参数个数不同、参数类型不同、参数顺序不同"></a>函数名相同，参数个数不同、参数类型不同、参数顺序不同</h3><p>例如下面就是函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值类型与函数重载无关"><a href="#返回值类型与函数重载无关" class="headerlink" title="返回值类型与函数重载无关"></a>返回值类型与函数重载无关</h3><p>返回值类型与函数重载无关，下面代码不构成重载，编译会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值类型与函数重载无关</span></span><br><span class="line"><span class="keyword">int</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实参的隐式类型转换可能会产生二义性"><a href="#实参的隐式类型转换可能会产生二义性" class="headerlink" title="实参的隐式类型转换可能会产生二义性"></a>实参的隐式类型转换可能会产生二义性</h3><p><strong>不同编译器有不同处理</strong></p><p>下面代码在vs上编译不过，但是在Xcode中可以编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载的本质"><a href="#函数重载的本质" class="headerlink" title="函数重载的本质"></a>函数重载的本质</h2><ul><li>采用了name mangling或者叫name decoration技术<ul><li>C++编译器默认会对符号名（比如函数名）进行改编、修饰，有些地方翻译为“命名倾轧”</li><li>重载时会生成多个不同的函数名，不同编译器（MSVC、g++）有不同的生成规则</li><li>通过IDA打开【VS_Release_禁止优化】可以看到 或者通过hopper查看</li></ul></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，<code>void sum(double a){}</code> 和 <code>void sum(int a){}</code> 是如何重载，调用函数的时候是如何能正确找到对应的函数呢？</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>我是用xcode的编译出可执行文件，放在hopper中查看</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">   __Z3sumd:</span>        // sum(double)</span><br><span class="line">0000000100000ce0         <span class="keyword">push</span>       <span class="built_in">rbp</span>         <span class="comment">; CODE XREF=_main+23</span></span><br><span class="line">0000000100000ce1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000ce4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000ce8         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">qword</span> [__ZNSt3__14coutE_100001000]</span><br><span class="line">0000000100000cef         <span class="keyword">movsd</span>      <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8], <span class="built_in">xmm0</span></span><br><span class="line">0000000100000cf4         <span class="keyword">movsd</span>      <span class="built_in">xmm0</span>, <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_8]</span><br><span class="line">0000000100000cf9         <span class="keyword">call</span>       imp___stubs___ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEd <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(double)</span></span><br><span class="line">0000000100000cfe         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span></span><br><span class="line">0000000100000d01         <span class="keyword">lea</span>        <span class="built_in">rsi</span>, <span class="built_in">qword</span> [__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_]</span><br><span class="line">0000000100000d08         <span class="keyword">call</span>       __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; (*)(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;))</span></span><br><span class="line">0000000100000d0d         <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rax</span></span><br><span class="line">0000000100000d11         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000d15         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000d16         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000d17         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br></pre></td></tr></table></figure><p>可知 <code>void sum(double a){}</code> 被编译器修改为函数<code>__Z3sumd</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">                     __Z3sumi:</span>        // sum(<span class="keyword">int</span>)</span><br><span class="line">0000000100000da0         <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line">0000000100000da1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000da4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000da8         <span class="keyword">mov</span>        <span class="built_in">rax</span>, <span class="built_in">qword</span> [__ZNSt3__14coutE_100001000]</span><br><span class="line">0000000100000daf         <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="built_in">edi</span></span><br><span class="line">0000000100000db2         <span class="keyword">mov</span>        <span class="built_in">esi</span>, <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4]</span><br><span class="line">0000000100000db5         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span></span><br><span class="line">0000000100000db8         <span class="keyword">call</span>       imp___stubs___ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)</span></span><br><span class="line">0000000100000dbd         <span class="keyword">mov</span>        <span class="built_in">rdi</span>, <span class="built_in">rax</span>                                    <span class="comment">; argument #1 for method __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E</span></span><br><span class="line">0000000100000dc0         <span class="keyword">lea</span>        <span class="built_in">rsi</span>, <span class="built_in">qword</span> [__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_]</span><br><span class="line">0000000100000dc7         <span class="keyword">call</span>       __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEPFRS3_S4_E <span class="comment">; std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; (*)(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;))</span></span><br><span class="line">0000000100000dcc         <span class="keyword">mov</span>        <span class="built_in">qword</span> [<span class="built_in">rbp</span>+var_10], <span class="built_in">rax</span></span><br><span class="line">0000000100000dd0         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000dd4         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000dd5         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000dd6         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">cs</span>:<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br></pre></td></tr></table></figure><p>可知 <code>void sum(int a){}</code> 被编译器修改为函数<code>__Z3sumi</code></p><p>这样当我们调用的时候</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    sum(<span class="number">10.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编如下，可知：因为 10.5是double类型，调用函数的时候是调用 <code>__Z3sumd</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000100000de0         <span class="keyword">push</span>       <span class="built_in">rbp</span></span><br><span class="line">0000000100000de1         <span class="keyword">mov</span>        <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">0000000100000de4         <span class="keyword">sub</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000de8         <span class="keyword">movsd</span>      <span class="built_in">xmm0</span>, <span class="built_in">qword</span> [<span class="number">0x100000f80</span>]</span><br><span class="line">0000000100000df0         <span class="keyword">mov</span>        <span class="built_in">dword</span> [<span class="built_in">rbp</span>+var_4], <span class="number">0x0</span></span><br><span class="line">0000000100000df7         <span class="keyword">call</span>       __Z3sumd        <span class="comment">; sum(double)</span></span><br><span class="line">0000000100000dfc         <span class="keyword">xor</span>        <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">0000000100000dfe         <span class="keyword">add</span>        <span class="built_in">rsp</span>, <span class="number">0x10</span></span><br><span class="line">0000000100000e02         <span class="keyword">pop</span>        <span class="built_in">rbp</span></span><br><span class="line">0000000100000e03         <span class="keyword">ret</span></span><br><span class="line">                        <span class="comment">; endp</span></span><br><span class="line">0000000100000e04         <span class="keyword">nop</span>        <span class="built_in">word</span> [<span class="built_in">cs</span>:<span class="built_in">rax</span>+<span class="built_in">rax</span>]</span><br><span class="line">0000000100000e0e         <span class="keyword">nop</span></span><br></pre></td></tr></table></figure><h3 id="函数重载结论"><a href="#函数重载结论" class="headerlink" title="函数重载结论"></a>函数重载结论</h3><p>由上面的汇编代码可知，当参数类型不同的时候，编译器会生成不同的函数名作为区别，这样就能实现函数重载。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>C++允许函数设置默认参数，在调用时可以根据情况省略实参。规则如下：</p><ul><li>默认参数只能按照右到左的顺序</li><li>如果函数同时有声明、实现，默认参数只能放在函数声明中</li><li>默认参数的值可以是常量、全局符号（全局变量、函数名）</li></ul><p>用法：如果函数的实参经常是同一个值，可以考虑使用默认参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2函数</span></span><br><span class="line"><span class="comment">// a没有默认值</span></span><br><span class="line"><span class="comment">// b 默认值是 10</span></span><br><span class="line"><span class="comment">// 最后一个参数默认值是个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">void</span> (*func)() = test)</span></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"a is "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test2(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可能有冲突，二义性"><a href="#可能有冲突，二义性" class="headerlink" title="可能有冲突，二义性"></a>可能有冲突，二义性</h3><ul><li>函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）</li></ul><p>例如下面的代码中， 调用<code>test(3);</code> 会报错，因为不知道要执行哪个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test(<span class="number">3</span>); <span class="comment">// 这里报错，因为不知道要执行哪个函数</span></span><br><span class="line">    test(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//这一句可以正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果函数的实参经常是同一个值，可以考虑使用默认参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://ityongzhen.github.io/C++语法之函数重载.html/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数重载（Overload）&quot;&gt;&lt;a href=&quot;#函数重载（Overload）&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="C++" scheme="https://ityongzhen.github.io/categories/C/"/>
    
    
  </entry>
  
</feed>
